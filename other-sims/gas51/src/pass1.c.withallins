
#ifndef _PASS1_
#define _PASS1_
#endif

#include"gas51.h"



struct instruct
 {
   int hex_code;
   const char *mnemonic;
   int nobytes;
  // int clock;
   //int noperands;
  // void (*ins_ptr)(int);
};

   //struct instruct instructions;
  struct instruct instructions[]={
					   {0X0,"NOP",1},   //
					   {0X1,"AJMP 11ADDR",2},
					   {0X2,"LJMP 16ADDR",3}, //
					   {0X3,"RR A",1}, //
					   {0X4,"INC A",1},//
/*'X' denotes dummy args. for simulator*/  {0X5,"INC 8ADDR",2},//
 /*A means address,*/			   {0X6,"INC @R0",1},//
 /*D means data*/			   {0X7,"INC @R1",1},//
 /*C means code*/			   {0X8,"INC R0",1}, //
					   {0X9,"INC R1",1}, //
					   {0XA,"INC R2",1},//
					   {0XB,"INC R3",1}, //
					   {0XC,"INC R4",1}, //
					   {0XD,"INC R5",1},  //
					   {0XE,"INC R6",1},//
					   {0XF,"INC R7",1}, //
					   {0X10,"JBC BIT,8REL",3},
					   {0X11,"ACALL 11ADDR",2},
					   {0X12,"LCALL 16ADDR",3},
					   {0X13,"RRC A",1},  //
					   {0X14,"DEC A",1}, //
					   {0X15,"DEC 8ADDR",2},    //
					   {0X16,"DEC @R0",1},   //
					   {0X17,"DEC @R1",1},  //
					   {0X18,"DEC R0",1}, //
					   {0X19,"DEC R1",1}, //
					   {0X1A,"DEC R2",1}, //
					   {0X1B,"DEC R3",1}, //
					   {0X1C,"DEC R4",1}, //
					   {0X1D,"DEC R5",1}, //
					   {0X1E,"DEC R6",1}, //
					   {0X1F,"DEC R7",1}, //
					   {0X20,"JB BIT,8REL",3},
					   {0X21,"AJMP 11ADDR",2},
					   {0X22,"RET",1},
					   {0X23,"RL A",1}, //
					   {0X24,"ADD A,#8DATA",2}, //
					   {0X25,"ADD A,8ADDR",2}, //
					   {0X26,"ADD A,@R0 ",1}, //
					   {0X27,"ADD A,@R1 ",1}, //
					   {0X28,"ADD A,R0",1}, //
					   {0X29,"ADD A,R1",1},//
					   {0X2A,"ADD A,R2",1}, //
					   {0X2B,"ADD A,R3",1},//
					   {0X2C,"ADD A,R4",1}, //
					   {0X2D,"ADD A,R5",1}, //
					   {0X2E,"ADD A,R6",1}, //
					   {0X2F,"ADD A,R7",1}, //
					   {0X30,"JNB BIT,8REL",3},
					   {0X31,"ACALL 11ADDR",2},
					   {0X32,"RETI",1},
					   {0X33,"RLC A",1},
					   {0X34,"ADDC A,#8DATA",2},
					   {0X35,"ADDC A,8ADDR",2},
					   {0X36,"ADDC A,@R0 ",1},
					   {0X37,"ADDC A,@R1 ",1},
					   {0X38,"ADDC A,R0",1},
					   {0X39,"ADDC A,R1",1},
					   {0X3A,"ADDC A,R2",1},
					   {0X3B,"ADDC A,R3",1},
					   {0X3C,"ADDC A,R4",1},
					   {0X3D,"ADDC A,R5",1},
					   {0X3E,"ADDC A,R6",1},
					   {0X3F,"ADDC A,R7",1},
					   {0X40,"JC BIT,8REL",2},
					   {0X41,"AJMP 11ADDR",2},
					   {0X42,"ORL 8ADDR,A",2},
					   {0X43,"ORL 8ADDR,#8DATA",3},
					   {0X44,"ORL A,#8DATA",2},
					   {0X45,"ORL A,8ADDR",2},
					   {0X46,"ORL A,@R0 ",1},
					   {0X47,"ORL A,@R1 ",1},
					   {0X48,"ORL A,R0",1},
					   {0X49,"ORL A,R1",1},
					   {0X4A,"ORL A,R2",1},
					   {0X4B,"ORL A,R3",1},
					   {0X4C,"ORL A,R4",1},
					   {0X4D,"ORL A,R5",1},
					   {0X4E,"ORL A,R6",1},
					   {0X4F,"ORL A,R7",1},
					   {0X50,"JNC BIT,8REL",2},
					   {0X51,"ACALL 11ADDR",2},
					   {0X52,"ANL 8ADDR,A",2},
					   {0X53,"ANL 8ADDR,#8DATA",3},
					   {0X54,"ANL A,#8DATA",2},
					   {0X55,"ANL A,8ADDR",2},
					   {0X56,"ANL A,@R0  ",1},
					   {0X57,"ANL A,@R1  ",1},
					   {0X58,"ANL A,R0",1},
					   {0X59,"ANL A,R1",1},
					   {0X5A,"ANL A,R2",1},
					   {0X5B,"ANL A,R3",1},
					   {0X5C,"ANL A,R4",1},
					   {0X5D,"ANL A,R5",1},
					   {0X5E,"ANL A,R6",1},
					   {0X5F,"ANL A,R7",1},
					   {0X60,"JZ 8REL",2},
					   {0X61,"AJMP 11ADDR",2},
					   {0X62,"XRL 8ADDR,A",2},
					   {0X63,"XRL 8ADDR,#8DATA",3},
					   {0X64,"XRL A,8ADDR#",2},
					   {0X65,"XRL A,8ADDR",2},
					   {0X66,"XRL A,@R0",1},
					   {0X67,"XRL A,@R1",1},
					   {0X68,"XRL A,R0",1},
					   {0X69,"XRL A,R1",1},
					   {0X6A,"XRL A,R2",1},
					   {0X6B,"XRL A,R3",1},
					   {0X6C,"XRL A,R4",1},
					   {0X6D,"XRL A,R5",1},
					   {0X6E,"XRL A,R6",1},
					   {0X6F,"XRL A,R7",1},
					   {0X70,"JNZ 8REL",2},
					   {0X71,"ACALL 11ADDR",2},
					   {0X72,"ORL C,BIT",2},
					   {0X73,"JMP @A+DPTR",1},
					   {0X74,"MOV A,#8DATA",2},
  /*MOV DATAADDR,#DATA*/		   {0X75,"MOV 8ADDR,#8DATA",3},
					   {0X76,"MOV @R0,#8DATA",2},
					   {0X77,"MOV @R1,#8DATA",2},
					   {0X78,"MOV R0,#8DATA",2},
					   {0X79,"MOV R1,#8DATA",2},
					   {0X7A,"MOV R2,#8DATA",2},
					   {0X7B,"MOV R3,#8DATA",2},
					   {0X7C,"MOV R4,#8DATA",2},
					   {0X7D,"MOV R5,#8DATA",2},
					   {0X7E,"MOV R6,#8DATA",2},
					   {0X7F,"MOV R7,#8DATA",2},
					   {0X80,"SJMP 8REL",2},
					   {0X81,"AJMP 11ADDR",2},
					   {0X82,"ANL C,BIT",2},
					   {0X83,"MOVC A,@A+PC ",1},
					   {0X84,"DIV AB",1},
					   {0X85,"MOV 8ADDR,8ADDR",3},
					   {0X86,"MOV 8ADDR,@R0",2},
					   {0X87,"MOV 8ADDR,@R1",2},
					   {0X88,"MOV 8ADDR,R0",2},
					   {0X89,"MOV 8ADDR,R1",2},
					   {0X8A,"MOV 8ADDR,R2",2},
					   {0X8B,"MOV 8ADDR,R3",2},
					   {0X8C,"MOV 8ADDR,R4",2},
					   {0X8D,"MOV 8ADDR,R5",2},
					   {0X8E,"MOV 8ADDR,R6",2},
					   {0X8F,"MOV 8ADDR,R7",2},
					   {0X90,"MOV DPTR,#16DATA",3},
					   {0X91,"ACALL 11ADDR",2},
					   {0X92,"MOV BIT,C",2},
					   {0X93,"MOVC A,@A+DPTR",1},
					   {0X94,"SUBB A,#8DATA",2},
					   {0X95,"SUBB A,8ADDR",2},
					   {0X96,"SUBB A,@R0 ",1},
					   {0X97,"SUBB A,@R1 ",1},
					   {0X98,"SUBB A,R0",1},
					   {0X99,"SUBB A,R1",1},
					   {0X9A,"SUBB A,R2",1},
					   {0X9B,"SUBB A,R3",1},
					   {0X9C,"SUBB A,R4",1},
					   {0X9D,"SUBB A,R5",1},
					   {0X9E,"SUBB A,R6",1},
					   {0X9F,"SUBB A,R7",1},
					   {0XA0,"ORL C,/BIT",2},
					   {0XA1,"AJMP 11ADDR",2},
					   {0XA2,"MOV C,BIT",2},
					   {0XA3,"INC DPTR",1},
					   {0XA4,"MUL AB",1},
					   {0XA5," ",0},          // no instruction for this opcode...nobytes changed to 0..necessary...
					   {0XA6,"MOV @R0,8ADDR",2},
					   {0XA7,"MOV @R1,8ADDR",2},
					   {0XA8,"MOV R0,8ADDR",2},
					   {0XA9,"MOV R1,8ADDR",2},
					   {0XAA,"MOV R2,8ADDR",2},
					   {0XAB,"MOV R3,8ADDR",2},
					   {0XAC,"MOV R4,8ADDR",2},
					   {0XAD,"MOV R5,8ADDR",2},
					   {0XAE,"MOV R6,8ADDR",2},
					   {0XAF,"MOV R7,8ADDR",2},
					   {0XB0,"ANL C,/BIT",2},
					   {0XB1,"ACALL 11ADDR",2},
					   {0XB2,"CPL BIT",2},
					   {0XB3,"CPL C",1},
					   {0XB4,"CJNE A,#8DATA,8REL",3},
					   {0XB5,"CJNE A,8ADDR,8REL",3},
					   {0XB6,"CJNE @R0,#8DATA,8REL",3},
					   {0XB7,"CJNE @R1,#8DATA,8REL",3},
					   {0XB8,"CJNE R0,#8DATA,8REL",3},
					   {0XB9,"CJNE R1,#8DATA,8REL",3},
					   {0XBA,"CJNE R2,#8DATA,8REL",3},
					   {0XBB,"CJNE R3,#8DATA,8REL",3},
					   {0XBC,"CJNE R4,#8DATA,8REL",3},
					   {0XBD,"CJNE R5,#8DATA,8REL",3},
					   {0XBE,"CJNE R6,#8DATA,8REL",3},
					   {0XBF,"CJNE R7,#8DATA,8REL",3},
					   {0XC0,"PUSH 8ADDR",2},
					   {0XC1,"AJMP 11ADDR",2},
					   {0XC2,"CLR BIT",2,},
					   {0XC3,"CLR C",1},
					   {0XC4,"SWAP A",1},
					   {0XC5,"XCH A,8ADDR",2},
					   {0XC6,"XCH A,@R0",1},
					   {0XC7,"XCH A,@R1",1},
					   {0XC8,"XCH A,R0",1},
					   {0XC9,"XCH A,R1",1},
					   {0XCA,"XCH A,R2",1},
					   {0XCB,"XCH A,R3",1},
					   {0XCC,"XCH A,R4",1},
					   {0XCD,"XCH A,R5",1},
					   {0XCE,"XCH A,R6",1},
					   {0XCF,"XCH A,R7",1},
					   {0XD0,"POP 8ADDR",2},
					   {0XD1,"ACALL 11ADDR",2},
					   {0XD2,"SETB BIT",2},
					   {0XD3,"SETB C",1},
					   {0XD4,"DA A",1},
					   {0XD5,"DJNZ 8DATA,8REL",3},
					   {0XD6,"XCHD A,@R0",1},
					   {0XD7,"XCHD A,@R1",1},
					   {0XD8,"DJNZ R0,8REL",2},
					   {0XD9,"DJNZ R1,8REL",2},
					   {0XDA,"DJNZ R2,8REL",2},
					   {0XDB,"DJNZ R3,8REL",2},
					   {0XDC,"DJNZ R4,8REL",2},
					   {0XDD,"DJNZ R5,8REL",2},
					   {0XDE,"DJNZ R6,8REL",2},
					   {0XDF,"DJNZ R7,8REL",2},
					   {0XE0,"MOVX A,@DPTR",1},
					   {0XE1,"AJMP 11ADDR",2},
					   {0XE2,"MOVX A,@R0",1},
					   {0XE3,"MOVX A,@R1",1},
					   {0XE4,"CLR A",1},
					   {0XE5,"MOV A,8ADDR",2},
					   {0XE6,"MOV A,@R0",1},
					   {0XE7,"MOV A,@R1",1},
					   {0XE8,"MOV A,R0",1},
					   {0XE9,"MOV A,R1",1},
					   {0XEA,"MOV A,R2",1},
					   {0XEB,"MOV A,R3",1},
					   {0XEC,"MOV A,R4",1},
					   {0XED,"MOV A,R5",1},
					   {0XEE,"MOV A,R6",1},
					   {0XEF,"MOV A,R7",1},
					   {0XF0,"MOVX @DPTR,A",1},
					   {0XF1,"ACALL 11ADDR",2},
					   {0XF2,"MOVX @R0,A",1},
					   {0XF3,"MOVX @R1,A",1},
					   {0XF4,"CPL A",1},
					   {0XF5,"MOV 8ADDR,A",2},
					   {0XF6,"MOV @R0,A",1},
					   {0XF7,"MOV @R1,A",1},
					   {0XF8,"MOV R0,A",1,},
					   {0XF9,"MOV R1,A",1,},
					   {0XFA,"MOV R2,A",1,},
					   {0XFB,"MOV R3,A",1,},
					   {0XFC,"MOV R4,A",1,},
					   {0XFD,"MOV R5,A",1,},
					   {0XFE,"MOV R6,A",1,},
					   {0XFF,"MOV R7,A",1,},
  /* dummy for hex 100*/         	   {0X100," ",0}  // nobytes changed to 0..necessary...

	
			      };





extern void dump_file(FILE *fp);
extern char * substr(char *,int,int);
extern char * remove_all_spaces(char *);
extern char * trim(char *);   // this functions removes all leading and trailing white spaces and reduces all interveining spaces to one...


struct instruct *info ;
struct gas51_file_info *temp_info ;

//info = (struct instruct *)malloc(sizeof(struct instruct));
//temp_info = (struct gas51_file_info *)malloc(sizeof(struct gas51_file_info)) ;



struct instruct * assemble(char *);   //this returns the number of bytes in an instruction...

void push (struct gas51_file_info *temp_info );  

struct gas51_file_info * pop(void);

int get_tokens(char t_addr[][],char *instruction);

FILE *pass1(FILE *fpasmfile)
{
	/* inside pass1 of assembler...*/
//	info = (struct instruct *)malloc(sizeof(struct instruct));
//	temp_info = (struct gas51_file_info *)malloc(sizeof(struct gas51_file_info)) ;


	FILE *fpdest ;
	static unsigned int LocCounter=0;   //location counter for pass1 of assembler...
	static unsigned int symtab_index=0;
	//int no_bytes;
	static char esc_seq[2]={187,'\0'};
	unsigned int i;
	unsigned char buff[160],tempbuff[160]; // unsigned char is taken so that the gas51 escape character comes within range...
	char AssemblyInstruction[80];
	char Label[20];
	char ch ,str[10] ;  //dummy variables...	
	dump_file(fpasmfile);
	
	//puts(gas51_file_being_assembled);	
	//fpasmfile = fopen(gas51_file_being_assembled,"r" );
	info = (struct instruct *)malloc(sizeof(struct instruct));
	temp_info = (struct gas51_file_info *)malloc(sizeof(struct gas51_file_info)) ;


	printf("\n\n\n\n");
	rewind(fpasmfile);   //rewinding pointer before beginning pass1 of assembly process...
	fpdest = tmpfile();
	while( fgets(buff,160,fpasmfile))

	{
		gas51_line_no++ ;
		if( (i=pat_index(buff,esc_seq))==0 )	
		{
		
		for(i=0;i<strlen(buff);i++)
		{	
		    if(buff[i]==';' )  // in order to account for the comment indicator... 
		    	break;	    
		}
		buff[i]='\0' ;

		
		
		//puts(buff);
		if( (i=pat_index(buff,":"))   )
		{
			strcpy(Label,substr(buff,1,i));
			strcpy(Label,remove_all_spaces(Label));
			strcpy(AssemblyInstruction,substr(buff,i+1,strlen(buff)-i-1));  //extracting the last part of the instruction...
			strcpy(AssemblyInstruction,trim(AssemblyInstruction));
		 	
			
			if((strcasecmp(AssemblyInstruction," " ))==0)
				continue;
			
			info = assemble(AssemblyInstruction) ; //getting all the info about the instruction in a struct...
			
			fprintf(fpdest,"%.4X %.2X\n",LocCounter,info->hex_code);  //writing into temp hexfile...
			strcpy(gas51_symbol_table[symtab_index].Symbol , Label);   //copying the label into the symbol table...
			gas51_symbol_table[symtab_index].Address = LocCounter ;
		        symtab_index++;	
			LocCounter += info->nobytes ;			//and incrementing the LC by sizeof present instruction...
			//printf("%s\n",AssemblyInstruction);
			//printf("%s\n",Label);
		
		}
		
		else 
			if(i==0)
			{
				strcpy(AssemblyInstruction,trim(buff));
				
				if((strcasecmp(AssemblyInstruction," " ))==0)
					continue;
						
				info = assemble(AssemblyInstruction) ; //getting the number of bytes in the instruction
				fprintf(fpdest,"%.4X %.2X\n",LocCounter,info->hex_code);  //writing into temp hexfile...
				LocCounter += info->nobytes ;			// incrementing the LC by sizeof present instruction...
				
				
				//printf("%s\n",AssemblyInstruction);
			}
		//sscanf(buff,"%s:%s",Label,Mnemonic);
		
		//printf("%s %s\n",Label,Mnemonic);
		



	}
	
	
		else   // code to handle gas51 special escape sequence...
		{
			if(pat_index(buff,":start"))
				{
					strcpy(temp_info->file,gas51_file_being_assembled);
					temp_info->file_line_no = gas51_line_no ;
					
					push(temp_info);     // pushing the current file info into stack...
					//push(gas51_line_no);
					sscanf(buff,"%c%s%s",&ch,gas51_file_being_assembled,str); //reinit'ing file and line no...	
					gas51_line_no = 0 ;
				}
			else
				if(pat_index(buff,":end"))
					{
						temp_info=pop();
					        strcpy(gas51_file_being_assembled,temp_info->file);
						gas51_line_no = temp_info->file_line_no;	
						gas51_line_no--; // to compensate for the '++' op at start...				
						//current_line_no=pop();
					
					}
					
			
		}
	
	
	
	
	
    }  


	
	
	
	
for(i=0;i<=20;i++)
	
	if(strlen(gas51_symbol_table[i].Symbol)!=0)	
		printf("%s  ->   %d\n",gas51_symbol_table[i].Symbol,gas51_symbol_table[i].Address );
dump_file(fpdest);




}




struct instruct *  assemble(char *Instruction)
{

	
	unsigned int i;
	char tokens[5][10];  //a 2D  array of chars to hold instruction tokens...
	char found_flag=0;  //flag to denote match status -> 0 means match not found while 1 means match found...
	int num ;	
/*	tokens[0]=malloc(10*sizeof(char));
	tokens[1]=malloc(10*sizeof(char));
	tokens[2]=malloc(10*sizeof(char));
	tokens[3]=malloc(10*sizeof(char));
	tokens[4]=malloc(10*sizeof(char));   */
	
	
	for (i=0;i<=0xFF;i++)
	{
		if(!strcasecmp(instructions[i].mnemonic,Instruction ))
		{
			found_flag = 1;			// this is the code to test for 1 byte  ins...
			break ;
		}
		
	
	}
	
	
	if(found_flag==1)  //means instruction matched with opcode...
	{
		info = &instructions[i] ;
		return info ;
	
	
	}
	
	
	else
	{
		//do some stuff here to match a 2 byte instruction...
		// and break the loop immediately if a match occurs..
	
		 num = get_tokens(tokens,Instruction);  //all tokens copied into token array...returns total number of tokens...
		 
		if ((strcasecmp(tokens[0],"cjne")==0) && (num > 4)  )  // when a cjne ins contains more than 4 tokens...
       			{
				gas51_errno = 5 ;
				gas51_perror() ;

			}			

		else if ( (strcasecmp(tokens[0],"cjne")==0) && (num < 4)  )  // when a cjne ins contains less  than 4 tokens...
		{
			gas51_errno = 6 ;
			gas51_perror();


		}

		else if( strcasecmp(tokens[0],"cjne")  &&   num < 3 )
		{
			gas51_errno = 6 ;
			gas51_perror();
			


		}
		
		else if ( strcasecmp(tokens[0],"cjne") &&   num > 3 )
		{

			gas51_errno = 5 ;
			gas51_perror();

		}

		else 
		{	//everything ok...number of tokens are correct...proceeding with matching process...
			
			if (!isstandard(tokens[0]) )   //isstandard() returns 1 if standard , 0 if non-standard token...
			{
				if(substr(tokens[0],"#"))
					strcpy(newtokens[0],#8DATA);
				else 
					strcpy(newtokens[0],ADDR


			}
								



		}


		


	}



		
	
	
	

	if(found_flag==1 )
	{
		info = &instructions[i] ;
		return info ;

	}
	
	
	else
	{

		// do some stuff here to match a 3 byte instruction...
		// and break the loop immediately if a match occurs...




	}
	
	
	if(found_flag==1)
	{
		info = &instructions[i];
		return info ;


	}


			      // we have reached here means that all possible ins have been searched..so there must be an error...	
	else                          // this should come after all instructions are checked...
	{
		gas51_errno = 4 ;   // 4 is the error code for illegal instruction...
		gas51_perror();
		//exit(1);			
	}
	
	
	
	
	//return 0;

}



void push (struct gas51_file_info *temp_info )  
{
	gas51_file_info_stack[gas51_stack_index] = *(temp_info) ;  // hope this copies the whole structure...
	gas51_stack_index++ ;
	
}




struct gas51_file_info * pop(void)

{

	struct  gas51_file_info *temp_info ;
	gas51_stack_index--;

	temp_info = &(gas51_file_info_stack[gas51_stack_index]);

	return temp_info ;
	

}


int get_tokens(char t_addr[][10],char *instruction)
{

	unsigned int i,j,k;
	char buff[10];
	i=0;
	j=0;
	k=1;
	puts(instruction);
	while(instruction[i]!=' '   )   //at this point we may be sure that only a sinle space will be between 1st and 2nd token...
	{
		buff[j]=instruction[i] ;
		i++;
		j++;	


	}		

	buff[j] = '\0' ; // terminating buff with a trailing NULL...
	strcpy(t_addr[0],buff);   //first token gone...two more to go...

	i++;  //to get over the single space...
	j=0 ;  //reiniting j for a new buff...   
	
while(1)
{
	if(instruction[i]=='\n' || instruction[i]=='\0')
	{
		
		buff[j] = '\0' ;
		strcpy(t_addr[k],buff);
		if(strlen(buff))   //increment only if buff is non empty...
		  k++;
		break ;

	}

	
	if(instruction[i]==',' || instruction[i]==' ' || instruction[i]=='\t')
	{ 
		buff[j] = '\0' ;
		strcpy(t_addr[k],buff);
		if(strlen(buff))   // increment only if buff is non empty...
			k++;
		i++;
		j=0;
	}

	else
	{
		buff[j]=instruction[i];
		i++;
		j++;


	}



}

	
	
	
	
	
	/*	while(1)
	{
		





	}   */



	
	
/*	while(instruction[i]!=',' )
	{
		buff[j] = instruction[i];
		i++;
		j++;
	}
	
	buff[j] = '\0' ; //terminating buff with a trailing NULL...	
	strcpy(t_addr[1],buff);  //second token gone...one more to go...
	
	i++;
	j=0;
	while(instruction[i]!='\n')
	{
		buff[j] = instruction[i];
		i++;
		j++;
		



	}    */

	





	
	
return k ;   // returning the total number of tokens found...

	
}



	


	


	

