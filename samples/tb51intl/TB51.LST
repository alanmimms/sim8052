MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE    1


ISIS-II MCS-51 MACRO ASSEMBLER V2.0
OBJECT MODULE PLACED IN :F5:TB51.OBJ
ASSEMBLER INVOKED BY:  :F4:ASM51 :F5:TB51.SRC WF(:F9:)
                       

LOC  OBJ            LINE     SOURCE

                       1     $ERRORPRINT TITLE(MCS-51(TM) TINY BASIC INTERPRETER 8/26/80)
                       2     ;
                       3     ;       TINY BASIC INTERPRETER PROGRAM  (CREATED 3/10/80   JHW)
                       4     ;       ==============================
                       5     ;
                       6     ;       INSITE ORDER NO. BF10
                       7     ;
  0022                 8     VERS    EQU     22H
                       9     ;
                      10     ;
                      11     ; Modified from 2.1 to 2.2 by lss 4 jan 1983 to fix errors in the divide routine; and the r
                             andom number generator.
                      12     ;
                      13     ;
                      14     
                      15     ;       STATUS:
                      16     ;       ======
                      17     ;
                      18     ;
                      19     ;       NEW FEATURES/GIMMICKS TO BE CONSIDERED:
                      20     ;
                      21     ;       On power-up, system should adapt itself to whatever RAM it can
                      22     ;       find off-chip.
                      23     ;       Should allow for and/or identify multiple baud rates for serial link.
                      24     ;       Should allow other physical devices (software serial I/O, etc.).
                      25     ;
                      26     ;       Amount of RAM consumed by BASIC variables should be user-alterable.
                      27     ;       16-bit variable array handling should be provided when external RAM
                      28     ;       is available.
                      29     ;       Program buffering in internal RAM and/or line buffering in external RAM
                      30     ;       (when available/not available) might be nice.
                      31     ;
                      32     ;       INNUM could be changed to allow line editing and expression input.
                      33     ;
                      34     ;       Interrupt handlers should be provided for, and supported by strapping
                      35     ;       options so that CRT is not required.
                      36     ;
                      37     ;       Symbolically-accessable 8-bit pseudo CPU-registers, ports,
                      38     ;       etc. desired to support ML debug.
                      39     ;       During CALL, pseudo-registers should be loaded/saved.
                      40     ;
                      41     ;       Capability to load and dump programs to MDS or twin system desired.
                      42     ;       Download command desired compatible with ISIS hex file format.
                      43     ;       Line buffering should ignore initial line-feed to be compatible
                      44     ;       with down-load or cross-load, and terminate on <cntrl-Z>.
                      45     ;
                      46     ;       Expression evaluation algorithm should be changed to use less stack
                      47     ;       and allow more precedence levels.
                      48     ;       Since EXPR recursive, hardware stack can overflow (not checked).
                      49     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE    2


LOC  OBJ            LINE     SOURCE

                      50     ;       NEXT command should verify that a valid loop record is on the AES 
                      51     ;       as opposed to GOSUB return address, and vice-versa.
                      52     ;       STEP values other than +1 should be considered.
                      53     ;
                      54     ;       Error reporting could re-type line and indicate error point.
                      55     ;       Error numbers (if retained) should make some sense.
                      56     ;       Might be indices for error message strings.
                      57     ;
                      58     ;       TRACE mode could aid BASIC debug by typing each source line # executed.
                      59     ;
                      60     ;       RND number seed should be easily alterable for games, etc.
                      61     ;
                      62 +1  $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE    3


LOC  OBJ            LINE     SOURCE

                      63     ;
                      64     ;       AESTHETIC IMPROVEMENTS DESIRED:
                      65     ;
                      66     ;       Disallow 0 and >7FFFH line numbers.
                      67     ;
                      68     ;       Source modules could be re-grouped to be more readable
                      69     ;       and re-ordered to minimize use of LJMPs and LCALLs.
                      70     ;       Linkage jumps might be created in second 2K page to provide efficient
                      71     ;       access to first 2K.
                      72     ;
                      73     ;       PRN could insert zeros before leading Hex digits.
                      74     ;
                      75     ;       IDIV uses variable storage inefficiently (TMP0-TMP4).
                      76     ;       Should be modified to make use of actual stack variables.
                      77     ;
                      78     ;       TST could use optimized algorithm for single character token tests.
                      79     ;       String tests should skip over unsearched strings more efficiently.
                      80     ;
                      81     ;       Program buffer searching could be speeded by giving line length 
                      82     ;       before text string and computing branch over undesired lines.
                      83     ;
                      84     ;       Math and AES operations might be optimized by dedicating R1 as AESP
                      85     ;       to be loaded and saved only on entering/leaving execution mode.
                      86     ;
                      87     ;       Input radix should be determined by 'H' suffix presence.
                      88     ;       Otherwise labels (GOTO destinations) should always be decimal.
                      89     ;
                      90     ;       Space between GO and TO might be forgiven.
                      91     ;
                      92     ;       Certain commands might be disallowed in each operating mode:
                      93     ;       No LIST in execution, no INPUT in interactive, for instance.
                      94     ;       Some commands (FOR, GOTO, RETURN, etc.) must be last command in line.
                      95     ;
                      96     ;       GETLN could be made somewhat more abstract, so that L_INIT and READ_C
                      97     ;       return characters from edited line buffer in interactive mode and
                      98     ;       code buffer in execution mode.  Dual execution loops in main IL program
                      99     ;       can then be combined.  (Line insertion should default when no keyword
                     100     ;       tokens would be detected during parsing.)
                     101     ;
                     102     ;       Get rid of LIST and FNDLBL kludge which falsely sets RUNFLG to fool
                     103     ;       READ_C subroutine.
                     104     ;
                     105     ;       Sequential string testing (command parsing, operator recognition, etc.)
                     106     ;       could be made table-driven, eliminating repeated "CALL TST"s.
                     107     ;
                     108     ;       All data structures need to be better defined in listing.
                     109     ;       It would be a wise exercize to gather each 
                     110     ;       data-structure definition/declaration/accessing-routine set
                     111     ;       into isolated functional modules (like objects),
                     112     ;       with communication only via global variables.
                     113     
                     114     ;
                     115 +1  $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE    4


LOC  OBJ            LINE     SOURCE

                     116     ;
                     117     ;       GLOBAL VARIABLE AND DATA STRUCTURE DECLARATIONS:
                     118     ;       ====== ======== === ==== ========= ============
                     119     ;
                     120     ;       Intended System Configuration Constants:
                     121     ;
  2034               122     EXTRAM  EQU     2034H           ;External program buffer begins after 26 vars.
  3000               123     RAMLIM  EQU     3000H           ;Allowance made for 4K RAM buffer.
  1080               124     EXTROM  EQU     1080H           ;Start of external ROM space.
  0008               125     TABSIZ  EQU     8               ;Formatted column spacing.
  0024               126     AESLEN  EQU     36              ;AES Length.
                     127     ;
                     128     ;       Working Register Definitions.
                     129     ;
  REG                130     PNTR_L  EQU     R0              ;Program buffer pointer.
  REG                131     DEST_L  EQU     R1              ;Destination pointer for line insertion.
  REG                132     PNTR_H  EQU     R2              ;High-order pointer byte (temp. cursor)
  REG                133     DEST_H  EQU     R3
  REG                134     CHAR    EQU     R4              ;BASIC source string character being parsed.
  REG                135     LP_CNT  EQU     R5
  REG                136     TOS_L   EQU     R6
  REG                137     TOS_H   EQU     R7              ;Variable popped from stack for math routines.
                     138     ;
----                 139             DSEG
0008                 140             ORG     08H
                     141     ;
                     142     ;       Temporary variables used by IDIV routine.
                     143     ;
0008                 144     TMP0:   DS      1
0009                 145     TMP1:   DS      1
000A                 146     TMP2:   DS      1
000B                 147     TMP3:   DS      1
000C                 148     TMP4:   DS      1
                     149     ;
                     150     ;       Random number key.
                     151     ;
000D                 152     SEED_L: DS      1
000E                 153     SEED_H: DS      1
                     154     ;
                     155     ;
000F                 156     STRLEN: DS      1               ;Length of text string in L_BUF.
                     157     ;
                     158     ;US_VAR         User Variable (A,B,...) Array:
                     159     ;
  000C               160     NO_VAR  EQU     12              ;Allow 12 internal variables A - L.
0010                 161     US_VAR: DS      2*NO_VAR        ;Allocate variable storage space.
                     162     ;
0028                 163     MODE:   DS      1               ;Operating mode bits.
  0040               164     EXTVAR  BIT     MODE.0          ;Set when BASIC variables in external RAM.
  0041               165     ROMMOD  BIT     MODE.1          ;Set when BASIC programs executed from ROM.
  0042               166     EXTMOD  BIT     MODE.2          ;Set when BASIC programs fetched externally.
  0043               167     RUNMOD  BIT     MODE.3          ;Set when stored BASIC program is running.
  0044               168     HEXMOD  BIT     MODE.4          ;Set when operations should use HEX radix.
                     169     ;
0029                 170     FLAGS:  DS      1               ;Interroutine communication flags.
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE    5


LOC  OBJ            LINE     SOURCE

  0048               171     ZERSUP  BIT     FLAGS.0         ;If set, suppress printing leading zeroes.
  0049               172     CHAR_FLG  BIT   FLAGS.1         ;Set when CHAR has not been processed.
  004A               173     SGN_FLG BIT     FLAGS.2         ;Keeps track of operand(s) sign during math.
  004B               174     SEQ_FLG BIT     FLAGS.3         ;
  004C               175     MOD_FLG BIT     FLAGS.4         ;Set if divide routine should return MOD value.
  004D               176     H_FLG   BIT     FLAGS.5         ;Used to sense allow 'H' suffix in HEX mode.
                     177     ;
                     178     ;AES    Arithmetic Expression Stack.
                     179     ;
002A                 180     AESP:   DS      1               ;AES Stack Pointer
002B                 181     AES:    DS      AESLEN          ;Buffer allocation.
                     182     ;
                     183     ;
                     184     ;       Line Buffer Variables:
004F                 185     L_CURS: DS      1               ;Cursor for line buffer.
                     186     ;
0050                 187     TABCNT: DS      1               ;Column formatting count.
                     188     ;
                     189     ;CURSOR Source line cursor.
0051                 190     CURS_L: DS      1
0052                 191     CURS_H: DS      1
0053                 192     C_SAVE: DS      1               ;CHAR saved during SAVE_PNTR.
                     193     ;
0054                 194     LABL_L: DS      1               ;BASIC program source line counter.
0055                 195     LABL_H: DS      1               ;  "       "       "     high byte.
                     196     ;
  0055               197     SP_BASE EQU     $-1             ;Initialization value for hardware SP.
                     198     ;
  000D               199     CR      EQU     0DH             ;ASCII CODE FOR <CARRIAGE RETURN>.
  000A               200     LF      EQU     0AH             ;  "    "    "  <LINE FEED>.
  0007               201     BEL     EQU     07H             ;  "    "    "  <BELL>.
                     202     ;
                     203 +1  $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE    6


LOC  OBJ            LINE     SOURCE

                     204 +1  $SAVE NOGEN
                     205     ;
----                 206             CSEG
0000                 207             ORG     0000H
0000 020026          208             JMP     S_INIT          ;Jump to system initialization routine.
                     209     ;
                     210     ;       Interrupt routine expansion hooks:
                     211     ;
0003                 212     %DEBUG  ORG     0003H
0003 021003          213     %DEBUG  JMP     1003H           ;External interrupt 0 service routine.
                     214     ;
000B                 215     %DEBUG  ORG     000BH
000B 02100B          216     %DEBUG  JMP     100BH           ;Timer 0 service routine.
                     217     ;
0013                 218     %DEBUG  ORG     0013H
0013 021013          219     %DEBUG  JMP     1013H           ;External interrupt 1 service routine.
                     220     ;
001B                 221     %DEBUG  ORG     001BH
001B 02101B          222     %DEBUG  JMP     101BH           ;Timer 1 service routine.
                     223     ;
0023                 224     %DEBUG  ORG     0023H
0023 021023          225     %DEBUG  JMP     1023H           ;Serial port interrupt service routine.
                     226     ;
                     227     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE    7


LOC  OBJ            LINE     SOURCE

                     228     ;
                     229     ;       CONSOLE I/O ROUTINES AND DRIVERS:
                     230     ;       ======= === ======== === =======
                     231     ;
0026 E4              232     S_INIT: CLR     A
0027 F5D0            233             MOV     PSW,A
0029 F50E            234             MOV     SEED_H,A
002B F50D            235             MOV     SEED_L,A
002D 758155          236             MOV     SP,#SP_BASE     ;Re-initialize hardware stack.
0030 120714          237             CALL    RAM_INIT        ;Clear-out variable RAM.
0033 30B03F          238     SP_INI: JNB     RXD,RUNROM
0036 C28E            239             CLR     TR1
0038 75985A          240             MOV     SCON,#01011010B ;TI set indicates transmitter ready.
003B 758921          241             MOV     TMOD,#00100001B ;Timer 1 is set to auto-reload timer mode.
003E 758D00          242             MOV     TH1,#0          ;Assume fastest rate.
0041 7890            243             MOV     R0,#144
0043 20B0FD          244             JB      RXD,$
0046 D8FE            245     BAUDID: DJNZ    R0,$
0048 158D            246             DEC     TH1
004A 785E            247             MOV     R0,#94
004C 30B0F7          248             JNB     RXD,BAUDID
004F 20B0FD          249             JB      RXD,$           ;Hang-up here until space char. over.
0052 30B0FD          250             JNB     RXD,$
0055 D28E            251             SETB    TR1
0057 1200EB          252             CALL    STROUT
005A 0D              253             DB      CR,'MCS-51 TINY BASIC V'
005B 4D43532D
005F 35312054
0063 494E5920
0067 42415349
006B 432056
006E 32              254             DB      '0'+VERS/10H,'.','0'+(VERS AND 0FH),CR OR 80H
006F 2E
0070 32
0071 8D
0072 02085F          255             JMP     START
                     256     ;
0075 D242            257     RUNROM: SETB    EXTMOD
0077 D241            258             SETB    ROMMOD
0079 020880          259             JMP     XEC
                     260     ;
                     261     ;=======
                     262     ;
                     263     C_IN:
                     264     ;       Console character input routine.
                     265     ;       Waits for next input from console device and returns with character
                     266     ;       code in accumulator.
                     267     ;       If character is <CNTRL-C> process syntax error.
                     268     ;       Adjust lower-case alphabetics to upper case.
                     269     ;
007C 3098FD          270     %DEBUG  JNB     RI,$            ;Wait until character received.
007F E599            271             MOV     A,SBUF          ;Read input character.
0081 C298            272             CLR     RI              ;Clear reception flag.
0083 547F            273             ANL     A,#7FH          ;Mask off data bits.
0085 B40303          274             CJNE    A,#03H,C_IN_2   ;Test for CNTRL-C code.
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE    8


LOC  OBJ            LINE     SOURCE

0088 020114          275             JMP     SYN_ER          ;Abort if detected.
                     276     ;
008B B46100          277     C_IN_2: CJNE    A,#'a',$+3      ;Check for lower-case alphabetics.
008E 4007            278             JC      C_IN_1
0090 B47B00          279             CJNE    A,#'z'+1,$+3
0093 5002            280             JNC     C_IN_1
0095 54DF            281             ANL     A,#11011111B    ;Force upper-case code.
0097 22              282     C_IN_1: RET                     ;Return to calling routine.
                     283     ;
                     284     ;=======
                     285     ;
                     286     %*DEFINE(NLINE)
                                     (CALL   NLINE)
                     287     ;
                     288     NLINE:
                     289     ;       Transmit <CR><LF> sequence to console device.
                     290     ;
0098 740D            291             MOV     A,#CR
                     292     C_OUT:
                     293     ;       Console character output routine.
                     294     ;       Outputs character received in accumulator to console output device.
                     295     ;
009A 3099FD          296     %DEBUG  JNB     TI,$            ;Wait until transmission completed.
009D C299            297     %DEBUG  CLR     TI              ;Clear interrupt flag.
009F F599            298             MOV     SBUF,A          ;Write out character.
00A1 B40D0A          299             CJNE    A,#CR,COUT_2
00A4 3099FD          300     %DEBUG  JNB     TI,$
00A7 C299            301     %DEBUG  CLR     TI
00A9 75990A          302             MOV     SBUF,#LF        ;Output linefeed.
00AC 8004            303             SJMP    COUT_3
                     304     ;
00AE C3              305     COUT_2: CLR     C
00AF D55004          306             DJNZ    TABCNT,COUT_1   ;Monitor output field position.
00B2 755008          307     COUT_3: MOV     TABCNT,#TABSIZ  ;Reload field counter.
00B5 D3              308             SETB    C
00B6 22              309     COUT_1: RET
                     310     ;
                     311     ;=======
                     312     ;
                     313     %*DEFINE(CNTRL)
                                     (CALL   CNTRL)
                     314     ;
00B7 30980A          315     CNTRL:  JNB     RI,CNTRET       ;Poll whether character has been typed.
00BA 117C            316             CALL    C_IN
00BC B41305          317             CJNE    A,#13H,CNTRET   ;Check if char. is <CNTRL-S>.
00BF 117C            318     CNTR_2: CALL    C_IN            ;If so, hang up...
00C1 B411FB          319             CJNE    A,#11H,CNTR_2   ;    ...until <CNTRL-Q> received.
00C4 22              320     CNTRET: RET
                     321     ;
                     322     ;=======
                     323     ;
                     324     %*DEFINE(SPC)
                                     (CALL   SPC)
                     325     ;
                     326     SPC:
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE    9


LOC  OBJ            LINE     SOURCE

                     327     ;       Transmit one or more space characters to console to move console
                     328     ;       cursor to start of next field.
                     329     ;
00C5 7420            330             MOV     A,#' '  ;Load ASCII code for space character.
00C7 119A            331             CALL    C_OUT
00C9 50FA            332             JNC     SPC             ;Repeat until at TAB boundary.
00CB 22              333             RET
                     334     ;
                     335     ;===============
                     336     ;
                     337     ;NIBOUT
                     338     ;       If low-order nibble in Acc. is non-zero or ZERSUP flag is cleared,
                     339     ;       output the corresponding ASCII value and clear ZERSUP flag.
                     340     ;       Otherwise return without affecting output or ZERSUP.
                     341     ;
00CC 540F            342     NIBOUT: ANL     A,#0FH          ;Mask out low-order bits.
00CE 7003            343             JNZ     NIBO_2          ;Output ASCII code for Acc contents.
00D0 204807          344             JB      ZERSUP,NIBO_3
00D3 C248            345     NIBO_2: CLR     ZERSUP          ;Mark that non-zero character encountered.
00D5 2403            346             ADD     A,#(ASCTBL-(NIBO_1+1))  ;Offset to start of table.
00D7 83              347     NIBO_1: MOVC    A,@A+PC         ;Look up corresponding code.
00D8 119A            348             CALL    C_OUT           ;Output character.
00DA 22              349     NIBO_3: RET
                     350     ;
00DB 30313233        351     ASCTBL: DB      '0123456789ABCDEF'
00DF 34353637
00E3 38394142
00E7 43444546
                     352     ;
                     353     ;=======
                     354     ;
                     355     ;STROUT
                     356     ;       Copy in-line character string to console output device.
                     357     ;
00EB D083            358     STROUT: POP     DPH             ;Access in-line string.
00ED D082            359             POP     DPL
00EF E4              360     STRO_1: CLR     A
00F0 93              361             MOVC    A,@A+DPTR       ;Read next byte.
00F1 A3              362             INC     DPTR            ;Bump pointer.
00F2 10E704          363             JBC     ACC.7,STRO_2    ;Escape after last character.
00F5 119A            364             CALL    C_OUT           ;Output character.
00F7 80F6            365             SJMP    STRO_1          ;Loop until done.
                     366     ;
00F9 119A            367     STRO_2: CALL    C_OUT           ;Output character.
00FB E4              368             CLR     A
00FC 73              369             JMP     @A+DPTR         ;Return to program.
                     370     ;
                     371     ;=======
                     372     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   10


LOC  OBJ            LINE     SOURCE

                     373     ERROUT:
                     374     ;       Error handling routine common entry point. 
                     375     ;       (Could retype bad line, etc.)
                     376     ;
00FD 020862          377             JMP     ERRENT          ;Return to executive.
                     378     ;
                     379     ;=======
                     380     ;
                     381     ;EXP_ER Expression evaluation error.
0100 11EB            382     EXP_ER: CALL    STROUT          ;Output error message.
0102 484F573F        383             DB      'HOW?',CR OR 80H
0106 8D
0107 80F4            384             JMP     ERROUT          ;Return to executive.
                     385     ;
                     386     ;=======
                     387     ;
                     388     ;AES_ER Arithmetic expression stack error handling routine.
0109 11EB            389     AES_ER: CALL    STROUT          ;Output error message.
010B 534F5252        390             DB      'SORRY!',CR OR 80H
010F 5921
0111 8D
0112 80E9            391             JMP     ERROUT          ;Return to executive.
                     392     ;
                     393     ;
                     394     ;=======
                     395     ;
                     396     ;SYN_ER Syntax error handling routine.
0114 11EB            397     SYN_ER: CALL    STROUT          ;Output error message.
0116 0D              398             DB      CR,'WHAT?',CR OR 80H
0117 57484154
011B 3F
011C 8D
011D 80DE            399             JMP     ERROUT          ;Process error.
                     400     ;
                     401     ;=======
                     402     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   11


LOC  OBJ            LINE     SOURCE

                     403     $INCLUDE(TBMATH.SRC)
                =1   404     ;
                =1   405     ;       ARITHMETIC SUBROUTINE PACKAGE  (8/12/80)
                =1   406     ;
                =1   407     ;=======
                =1   408     ;
                =1   409     POP_TOS:
                =1   410     ;       Verify that stack holds at least on (16-bit) entry.
                =1   411     ;       (Call AES_ER otherwise.)
                =1   412     ;       Pop TOS into registers TOS_H and TOS_L,
                =1   413     ;       update AESP,
                =1   414     ;       and return with R1 pointing to low-order byte of previous NOS.
                =1   415     ;       Do not affect accumulator contents.
                =1   416     ;
011F A92A       =1   417             MOV     R1,AESP
0121 B92C00     =1   418             CJNE    R1,#AES+1,$+3   ;Compare pointer with min. legal level.
0124 4021       =1   419             JC      STK_ER
0126 FE         =1   420             MOV     TOS_L,A
0127 E7         =1   421             MOV     A,@R1
0128 FF         =1   422             MOV     TOS_H,A
0129 19         =1   423             DEC     R1
012A E7         =1   424             MOV     A,@R1
012B CE         =1   425             XCH     A,TOS_L         ;Store byte and reload ACC.
012C 19         =1   426             DEC     R1
012D 892A       =1   427             MOV     AESP,R1
012F 19         =1   428             DEC     R1
0130 22         =1   429             RET
                =1   430     ;
                =1   431     ;=======
                =1   432     ;
                =1   433     POP_ACC:
                =1   434     ;       Pop TOS into accumulator and update AESP.
                =1   435     ;
0131 A92A       =1   436             MOV     R1,AESP
0133 E7         =1   437             MOV     A,@R1
0134 152A       =1   438             DEC     AESP
0136 22         =1   439             RET
                =1   440     ;
                =1   441     ;=======
                =1   442     ;
                =1   443     PUSH_TOS:
                =1   444     ;       Verify that the AES is not full,
                =1   445     ;       push registers TOS_H and TOS_L onto AES,
                =1   446     ;       and update AESP.
                =1   447     ;
0137 A92A       =1   448             MOV     R1,AESP
0139 B94D00     =1   449             CJNE    R1,#AES+AESLEN-2,$+3    ;Compare pointer with max. legal level.
013C 5009       =1   450             JNC     STK_ER
013E 09         =1   451             INC     R1
013F EE         =1   452             MOV     A,TOS_L         ;Push low-order byte.
0140 F7         =1   453             MOV     @R1,A
0141 09         =1   454             INC     R1
0142 EF         =1   455             MOV     A,TOS_H         ;Push high-order byte.
0143 F7         =1   456             MOV     @R1,A
0144 892A       =1   457             MOV     AESP,R1
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   12


LOC  OBJ            LINE     SOURCE

0146 22         =1   458             RET
                =1   459     ;
0147 3109       =1   460     STK_ER: CALL    AES_ER
0149 0F         =1   461             DB      0FH
                =1   462     ;
                =1   463     ;=======
                =1   464     ;
                =1   465     %*DEFINE(DUPL)
                =1                   (CALL   DUPL)
                =1   466     ;
                =1   467     DUPL:
                =1   468     ;       Verify that the AES is not full,
                =1   469     ;       then duplicate the top element and update AESP.
                =1   470     ;
014A A92A       =1   471             MOV     R1,AESP
014C B94D00     =1   472             CJNE    R1,#AES+AESLEN-2,$+3    ;Compare pointer with max. legal level.
014F 50F6       =1   473             JNC     STK_ER
0151 19         =1   474             DEC     R1
0152 E7         =1   475             MOV     A,@R1
0153 09         =1   476             INC     R1
0154 87F0       =1   477             MOV     B,@R1
0156 09         =1   478             INC     R1
0157 F7         =1   479             MOV     @R1,A                   ;Push low-order byte.
0158 09         =1   480             INC     R1
0159 A7F0       =1   481             MOV     @R1,B
015B 892A       =1   482             MOV     AESP,R1
015D 22         =1   483             RET
                =1   484     ;
                =1   485     ;=======
                =1   486     ;
                =1   487     ;LIT    (K)
                =1   488     ;       Report error if arithmetic expression stack is full.
                =1   489     ;       Otherwise push the one-byte constant K onto AES.
                =1   490     ;       Return with carry=1, since LIT marks a successful match.
                =1   491     ;
                =1   492     %*DEFINE(LIT(K))
                =1                  (CALL    LIT
                =1                     DB      %K)
015E D083       =1   493     LIT:    POP     DPH             ;Get parameter address.
0160 D082       =1   494             POP     DPL
0162 E4         =1   495             CLR     A
0163 93         =1   496             MOVC    A,@A+DPTR       ;Read literal value.
0164 052A       =1   497             INC     AESP            ;Reserve storage on top of AES.
0166 A92A       =1   498             MOV     R1,AESP         ;Point to free entry on stack.
0168 B94F02     =1   499             CJNE    R1,#AES+AESLEN,LIT_1
016B 809C       =1   500             JMP     AES_ER
                =1   501     ;
016D F7         =1   502     LIT_1:  MOV     @R1,A           ;Store literal.
016E 7401       =1   503             MOV     A,#1            ;Branch over constant on return.
0170 D3         =1   504             SETB    C
0171 73         =1   505             JMP     @A+DPTR         ;Return to IL program.
                =1   506     ;
                =1   507     ;=======
                =1   508     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   13


LOC  OBJ            LINE     SOURCE

                =1   509     ;
                =1   510     ;       BASIC VARIABLE ACCESSING OPERATIONS  (8/20/80)
                =1   511     ;       ===== ======== ========= ==========
                =1   512     ;
                =1   513     ;
                =1   514     ;       Direct address mode emulation tables:
                =1   515     ;
0172 80         =1   516     SFRTBL: DB      80H
0173 90         =1   517             DB      90H
0174 A0         =1   518             DB      0A0H
0175 B0         =1   519             DB      0B0H
0176 88         =1   520             DB      88H
0177 98         =1   521             DB      98H
0178 A8         =1   522             DB      0A8H
0179 B8         =1   523             DB      0B8H
017A 89         =1   524             DB      89H
017B 8A         =1   525             DB      8AH
017C 8B         =1   526             DB      8BH
017D 8C         =1   527             DB      8CH
017E 8D         =1   528             DB      8DH
017F 99         =1   529             DB      99H
  000E          =1   530     NO_SFR  EQU     $-SFRTBL
                =1   531     ;
                =1   532     ;===
                =1   533     ;
0180 8E80       =1   534     STRTBL: MOV     80H,TOS_L
0182 22         =1   535             RET
0183 8E90       =1   536             MOV     90H,TOS_L
0185 22         =1   537             RET
0186 8EA0       =1   538             MOV     0A0H,TOS_L
0188 22         =1   539             RET
0189 8EB0       =1   540             MOV     0B0H,TOS_L
018B 22         =1   541             RET
018C 8E88       =1   542             MOV     88H,TOS_L
018E 22         =1   543             RET
018F 8E98       =1   544             MOV     98H,TOS_L
0191 22         =1   545             RET
0192 8EA8       =1   546             MOV     0A8H,TOS_L
0194 22         =1   547             RET
0195 8EB8       =1   548             MOV     0B8H,TOS_L
0197 22         =1   549             RET
0198 8E89       =1   550             MOV     89H,TOS_L
019A 22         =1   551             RET
019B 8E8A       =1   552             MOV     8AH,TOS_L
019D 22         =1   553             RET
019E 8E8B       =1   554             MOV     8BH,TOS_L
01A0 22         =1   555             RET
01A1 8E8C       =1   556             MOV     8CH,TOS_L
01A3 22         =1   557             RET
01A4 8E8D       =1   558             MOV     8DH,TOS_L
01A6 22         =1   559             RET
01A7 8E99       =1   560             MOV     99H,TOS_L
01A9 22         =1   561             RET
                =1   562     ;
                =1   563     ;===
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   14


LOC  OBJ            LINE     SOURCE

                =1   564     ;
01AA E580       =1   565     INDTBL: MOV     A,80H
01AC 22         =1   566             RET
01AD E590       =1   567             MOV     A,90H
01AF 22         =1   568             RET
01B0 E5A0       =1   569             MOV     A,0A0H
01B2 22         =1   570             RET
01B3 E5B0       =1   571             MOV     A,0B0H
01B5 22         =1   572             RET
01B6 E588       =1   573             MOV     A,88H
01B8 22         =1   574             RET
01B9 E598       =1   575             MOV     A,98H
01BB 22         =1   576             RET
01BC E5A8       =1   577             MOV     A,0A8H
01BE 22         =1   578             RET
01BF E5B8       =1   579             MOV     A,0B8H
01C1 22         =1   580             RET
01C2 E589       =1   581             MOV     A,89H
01C4 22         =1   582             RET
01C5 E58A       =1   583             MOV     A,8AH
01C7 22         =1   584             RET
01C8 E58B       =1   585             MOV     A,8BH
01CA 22         =1   586             RET
01CB E58C       =1   587             MOV     A,8CH
01CD 22         =1   588             RET
01CE E58D       =1   589             MOV     A,8DH
01D0 22         =1   590             RET
01D1 E599       =1   591             MOV     A,99H
01D3 22         =1   592             RET
                =1   593     ;
                =1   594     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   15


LOC  OBJ            LINE     SOURCE

                =1   595     SFR_ID:
                =1   596     ;       Identify which SFR is indicated by the contents of R1.
                =1   597     ;       Return with acc holding (Index of said register)*3.
                =1   598     ;       Call error routine if register number not found.
                =1   599     ;
01D4 900172     =1   600             MOV     DPTR,#SFRTBL
01D7 E4         =1   601             CLR     A
01D8 FD         =1   602             MOV     LP_CNT,A
01D9 ED         =1   603     SFID_1: MOV     A,LP_CNT
01DA 93         =1   604             MOVC    A,@A+DPTR
01DB 69         =1   605             XRL     A,R1
01DC 7004       =1   606             JNZ     SFID_2
01DE ED         =1   607             MOV     A,LP_CNT
01DF 23         =1   608             RL      A
01E0 2D         =1   609             ADD     A,LP_CNT
01E1 22         =1   610             RET
                =1   611     ;
01E2 0D         =1   612     SFID_2: INC     LP_CNT
01E3 ED         =1   613             MOV     A,LP_CNT
01E4 B40EF2     =1   614             CJNE    A,#NO_SFR,SFID_1
01E7 2100       =1   615     ADR_ER: JMP     EXP_ER
                =1   616     ;
                =1   617     ;=======
                =1   618     ;
                =1   619     STRDIR:
                =1   620     ;       Store data byte in ACC into direct on-chip RAM address held in R1.
                =1   621     ;
01E9 FE         =1   622             MOV     TOS_L,A
01EA E9         =1   623             MOV     A,R1
01EB 20E703     =1   624             JB      ACC.7,STRSFR    ;Direct addresses above 7FH are SFRs.
01EE EE         =1   625             MOV     A,TOS_L
01EF F7         =1   626             MOV     @R1,A           ;Store low-order byte in RAM.
01F0 22         =1   627             RET
                =1   628     ;
01F1 31D4       =1   629     STRSFR: CALL    SFR_ID
01F3 900180     =1   630             MOV     DPTR,#STRTBL
01F6 73         =1   631             JMP     @A+DPTR         ;Jump into store sequence.
                =1   632     ;
                =1   633     ;=======
                =1   634     ;
                =1   635     FETDIR:
                =1   636     ;       Fetch on-chip directly addressed byte indicated by R1 into Acc. 
                =1   637     ;       and return.
                =1   638     ;
01F7 E9         =1   639             MOV     A,R1
01F8 20E702     =1   640             JB      ACC.7,FETSFR
01FB E7         =1   641             MOV     A,@R1
01FC 22         =1   642             RET
                =1   643     ;
01FD 31D4       =1   644     FETSFR: CALL    SFR_ID
01FF 9001AA     =1   645             MOV     DPTR,#INDTBL
0202 73         =1   646             JMP     @A+DPTR
                =1   647     ;
                =1   648     ;=======
                =1   649     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   16


LOC  OBJ            LINE     SOURCE

                =1   650     SPLIT_DBA:
                =1   651     ;       Called with TOS_L containing a direct on-chip bit address.
                =1   652     ;       Return the direct &byte& address of encompassing 
                =1   653     ;       register in R1, and load B with a mask containing a single 1 
                =1   654     ;       corresponding to the bit's position in a field of zeroes.
                =1   655     ;
0203 EE         =1   656             MOV     A,TOS_L
0204 54F8       =1   657             ANL     A,#11111000B
0206 20E704     =1   658             JB      ACC.7,SPLSFR
0209 23         =1   659             RL      A
020A C4         =1   660             SWAP    A
020B 2420       =1   661             ADD     A,#20H          ;Address of bit-address space.
020D F9         =1   662     SPLSFR: MOV     R1,A
020E EE         =1   663             MOV     A,TOS_L
020F 5407       =1   664             ANL     A,#07H          ;Mask off bit-displacement field.
0211 2403       =1   665             ADD     A,#MSKTBL-MSK_PC
0213 83         =1   666             MOVC    A,@A+PC         ;Read mask byte.
                =1   667     MSK_PC:
0214 F5F0       =1   668             MOV     B,A
0216 22         =1   669             RET
                =1   670     ;
0217 01         =1   671     MSKTBL: DB      00000001B
0218 02         =1   672             DB      00000010B
0219 04         =1   673             DB      00000100B
021A 08         =1   674             DB      00001000B
021B 10         =1   675             DB      00010000B
021C 20         =1   676             DB      00100000B
021D 40         =1   677             DB      01000000B
021E 80         =1   678             DB      10000000B
                =1   679     ;
                =1   680     ;=======
                =1   681     ;
                =1   682     %*DEFINE(SEQ_STORE)
                =1                  (CALL    SEQ_STORE)
                =1   683     ;
                =1   684     SEQ_STORE:
                =1   685     ;       Same as STORE, below, except that index is retained
                =1   686     ;       rather than being popped.
021F D24B       =1   687             SETB    SEQ_FLG
0221 8002       =1   688             SJMP    STOR_0
                =1   689     ;
                =1   690     %*DEFINE(STORE)
                =1                  (CALL    STORE)
                =1   691     ;
                =1   692     STORE:
                =1   693     ;       When STORE is called, AES contains
                =1   694     ;       (TOS:)  2 byte VALUE to be stored,
                =1   695     ;               2 byte INDEX of destination variable,
                =1   696     ;               1 byte TYPE code for variable space.
                =1   697     ;                       (0=BASIC variable,
                =1   698     ;                        1=DBYTE,
                =1   699     ;                        2=RBIT,
                =1   700     ;                        3=XBYTE,
                =1   701     ;                        4=CBYTE.)
                =1   702     ;       Store (VAR_1) into appropriate variable memory at location of (INDEX).
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   17


LOC  OBJ            LINE     SOURCE

                =1   703     ;
0223 C24B       =1   704             CLR     SEQ_FLG
0225 311F       =1   705     STOR_0: CALL    POP_TOS
0227 8E08       =1   706             MOV     TMP0,TOS_L
0229 8F09       =1   707             MOV     TMP1,TOS_H
022B 311F       =1   708             CALL    POP_TOS
022D 3131       =1   709             CALL    POP_ACC         ;Load TYPE code.
022F 304B06     =1   710             JNB     SEQ_FLG,STOR_1  ;Jump forward if simple store.
0232 052A       =1   711             INC     AESP
0234 052A       =1   712             INC     AESP
0236 052A       =1   713             INC     AESP
0238 90023D     =1   714     STOR_1: MOV     DPTR,#STRJTB
023B 93         =1   715             MOVC    A,@A+DPTR
023C 73         =1   716             JMP     @A+DPTR
                =1   717     ;
023D 05         =1   718     STRJTB: DB      STRVAR-STRJTB
023E 23         =1   719             DB      STRDBY-STRJTB
023F 29         =1   720             DB      STRRBI-STRJTB
0240 3E         =1   721             DB      STRXBY-STRJTB
0241 3E         =1   722             DB      STRCBY-STRJTB
                =1   723     ;
                =1   724     ;=======
                =1   725     ;
                =1   726     ;       All of the following routines are called with 
                =1   727     ;       TOS_L holding the low-order address of the destination,
                =1   728     ;       TOS_H holding the high-order address (if necessary),
                =1   729     ;       and <TMP1><TMP0> holding the 8- or 16-bit data to be stored.
                =1   730     ;
0242 EE         =1   731     STRVAR: MOV     A,TOS_L
0243 23         =1   732             RL      A               ;Multiply by two for 2 byte variables.
0244 20400D     =1   733             JB      EXTVAR,STREXT   ;Branch if vars in external RAM.
0247 2410       =1   734             ADD     A,#US_VAR       ;Offset for variable array.
0249 F9         =1   735             MOV     R1,A
024A 24D9       =1   736             ADD     A,#-(US_VAR+2*NO_VAR-1) ;Compare with maximum legal address.
024C 4099       =1   737             JC      ADR_ER
024E A708       =1   738             MOV     @R1,TMP0
0250 09         =1   739             INC     R1
0251 A709       =1   740             MOV     @R1,TMP1
0253 22         =1   741             RET
                =1   742     ;
0254 F9         =1   743     STREXT: MOV     R1,A
0255 75A020     =1   744     %DEBUG  MOV     P2,#HIGH EXTRAM
0258 E508       =1   745             MOV     A,TMP0
025A F3         =1   746             MOVX    @R1,A
025B 09         =1   747             INC     R1              ;Bump pointers.
025C E509       =1   748             MOV     A,TMP1          ;Move high-order byte into variable array.
025E F3         =1   749             MOVX    @R1,A
025F 22         =1   750             RET
                =1   751     ;
                =1   752     ;===
                =1   753     ;
0260 EE         =1   754     STRDBY: MOV     A,TOS_L         ;Load acc. with low-order dest. addr.
0261 F9         =1   755             MOV     R1,A
0262 E508       =1   756             MOV     A,TMP0
0264 8083       =1   757             JMP     STRDIR
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   18


LOC  OBJ            LINE     SOURCE

                =1   758     ;
                =1   759     ;===
                =1   760     ;
0266 5103       =1   761     STRRBI: CALL    SPLIT_DBA
0268 31F7       =1   762             CALL    FETDIR
026A FE         =1   763             MOV     TOS_L,A
026B E508       =1   764             MOV     A,TMP0
026D 20E006     =1   765             JB      ACC.0,SETRBI
                =1   766     ;
                =1   767     ;       Clear RBIT.
                =1   768     ;
0270 E5F0       =1   769             MOV     A,B
0272 F4         =1   770             CPL     A
0273 5E         =1   771             ANL     A,TOS_L
0274 21E9       =1   772             JMP     STRDIR
                =1   773     ;
0276 E5F0       =1   774     SETRBI: MOV     A,B
0278 4E         =1   775             ORL     A,TOS_L
0279 21E9       =1   776             JMP     STRDIR
                =1   777     ;
                =1   778     ;===
                =1   779     ;
                =1   780     STRXBY:
027B 8FA0       =1   781     STRCBY: MOV     P2,TOS_H
027D EE         =1   782             MOV     A,TOS_L
027E F9         =1   783             MOV     R1,A
027F E508       =1   784             MOV     A,TMP0
0281 F3         =1   785             MOVX    @R1,A
0282 22         =1   786             RET
                =1   787     ;
                =1   788     ;===============
                =1   789     ;
                =1   790     %*DEFINE(SEQ_FETCH)
                =1                  (CALL    SEQ_FETCH)
                =1   791     ;
                =1   792     SEQ_FETCH:
                =1   793     ;       Same as FETCH, below, except that index is retained
                =1   794     ;       rather than being popped.
0283 D24B       =1   795             SETB    SEQ_FLG
0285 8002       =1   796             SJMP    FET_0
                =1   797     ;
                =1   798     %*DEFINE(IND)
                =1                  (CALL    FETCH)
                =1   799     ;
                =1   800     FETCH:
                =1   801     ;       When FETCH is called, AES contains
                =1   802     ;       (TOS:)  2 byte INDEX of source variable,
                =1   803     ;               1 byte TYPE code for variable space.
                =1   804     ;                       (0=BASIC variable,
                =1   805     ;                        1=DBYTE,
                =1   806     ;                        2=RBIT,
                =1   807     ;                        3=XBYTE,
                =1   808     ;                        4=CBYTE.)
                =1   809     ;       Read 8- or 16-bit variable from the appropriate variable 
                =1   810     ;       memory at location of (INDEX) and return on AES.
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   19


LOC  OBJ            LINE     SOURCE

                =1   811     ;
0287 C24B       =1   812             CLR     SEQ_FLG
0289 311F       =1   813     FET_0:  CALL    POP_TOS
028B 3131       =1   814             CALL    POP_ACC
028D 304B06     =1   815             JNB     SEQ_FLG,FET_1   ;Jump forward if simple store.
0290 052A       =1   816             INC     AESP
0292 052A       =1   817             INC     AESP
0294 052A       =1   818             INC     AESP
0296 90029B     =1   819     FET_1:  MOV     DPTR,#FETJTB
0299 93         =1   820             MOVC    A,@A+DPTR
029A 73         =1   821             JMP     @A+DPTR
                =1   822     ;
029B 05         =1   823     FETJTB: DB      FETVAR-FETJTB
029C 25         =1   824             DB      FETDBY-FETJTB
029D 2B         =1   825             DB      FETRBI-FETJTB
029E 37         =1   826             DB      FETXBY-FETJTB
029F 3E         =1   827             DB      FETCBY-FETJTB
                =1   828     ;
                =1   829     ;=======
                =1   830     ;
                =1   831     ;       All of the following routines are called with 
                =1   832     ;       TOS_L holding the low-order index of the desired variable,
                =1   833     ;       and TOS_H holding the high-order index (if necessary).
                =1   834     ;
02A0 EE         =1   835     FETVAR: MOV     A,TOS_L
02A1 23         =1   836             RL      A               ;Correct for double-byte entries.
02A2 20400E     =1   837             JB      EXTVAR,FETEXT
02A5 2410       =1   838             ADD     A,#US_VAR       ;Offset for variable array.
02A7 F9         =1   839             MOV     R1,A            ;Index to variable storage array.
02A8 24D9       =1   840             ADD     A,#-(US_VAR+2*NO_VAR-1)
02AA 4012       =1   841             JC      FETERR
02AC E7         =1   842             MOV     A,@R1           ;Load low-order byte of variable.
02AD FE         =1   843             MOV     TOS_L,A         ;And store on AES.
02AE 09         =1   844             INC     R1              ;Bump pointer.
02AF E7         =1   845             MOV     A,@R1           ;Transfer high-order byte of variable.
02B0 FF         =1   846             MOV     TOS_H,A
02B1 2137       =1   847             JMP     PUSH_TOS
                =1   848     ;
                =1   849     ;===
                =1   850     ;
02B3 F9         =1   851     FETEXT: MOV     R1,A            ;Index to variable storage array.
02B4 75A020     =1   852     %DEBUG  MOV     P2,#HIGH EXTRAM
02B7 E3         =1   853             MOVX    A,@R1           ;Load low-order byte of variable.
02B8 FE         =1   854             MOV     TOS_L,A         ;And store on AES.
02B9 09         =1   855             INC     R1              ;Bump pointers.
02BA E3         =1   856             MOVX    A,@R1           ;Transfer high-order byte of variable.
02BB FF         =1   857             MOV     TOS_H,A
02BC 2137       =1   858             JMP     PUSH_TOS
                =1   859     ;
02BE 21E7       =1   860     FETERR: JMP     ADR_ER
                =1   861     ;
                =1   862     ;===
                =1   863     ;
02C0 EE         =1   864     FETDBY: MOV     A,TOS_L
02C1 F9         =1   865             MOV     R1,A
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   20


LOC  OBJ            LINE     SOURCE

02C2 31F7       =1   866             CALL    FETDIR
02C4 8019       =1   867             SJMP    FETBDN          ;Byte fetch done.
                =1   868     ;
                =1   869     ;===
                =1   870     ;
02C6 5103       =1   871     FETRBI: CALL    SPLIT_DBA
02C8 31F7       =1   872             CALL    FETDIR
02CA 55F0       =1   873             ANL     A,B
02CC 24FF       =1   874             ADD     A,#0FFH
02CE E4         =1   875             CLR     A
02CF 33         =1   876             RLC     A
02D0 800D       =1   877             SJMP    FETBDN
                =1   878     ;
                =1   879     ;===
                =1   880     ;
02D2 8FA0       =1   881     FETXBY: MOV     P2,TOS_H
02D4 EE         =1   882             MOV     A,TOS_L
02D5 F9         =1   883             MOV     R1,A
02D6 E3         =1   884             MOVX    A,@R1
02D7 8006       =1   885             SJMP    FETBDN
                =1   886     ;
                =1   887     ;===
                =1   888     ;
02D9 8F83       =1   889     FETCBY: MOV     DPH,TOS_H
02DB 8E82       =1   890             MOV     DPL,TOS_L
02DD E4         =1   891             CLR     A
02DE 93         =1   892             MOVC    A,@A+DPTR
02DF 7F00       =1   893     FETBDN: MOV     TOS_H,#00H      ;FETCH sequence for Bytes Done.
02E1 FE         =1   894             MOV     TOS_L,A         ;FETCH sequence for words done.
02E2 2137       =1   895             JMP     PUSH_TOS
                =1   896     ;
                =1   897     ;=======
                =1   898     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   21


LOC  OBJ            LINE     SOURCE

                =1   899     ;
                =1   900     ;CREATE
                =1   901     ;       Test the contents of Acc.
                =1   902     ;       If CHAR holds the ASCII code for a legitimate decimal digit,
                =1   903     ;       create a two-byte entry in <TOS_H><TOS_L> holding low-order ACC nibble
                =1   904     ;       and return with CY set.
                =1   905     ;       Otherwise, return with CY cleared.
                =1   906     ;
02E4 24D0       =1   907     CREATE: ADD     A,#-'0'         ;Correct for ASCII digit offset.
02E6 B40A00     =1   908             CJNE    A,#10,$+3       ;Compare to maximum legal digit.
02E9 5005       =1   909             JNC     CREA_1          ;Abort if first char is not decimal digit.
02EB FE         =1   910             MOV     TOS_L,A         ;Save initial digit read.
02EC 7F00       =1   911             MOV     TOS_H,#0        ;Clear high-order bits.
02EE C24D       =1   912             CLR     H_FLG
02F0 22         =1   913     CREA_1: RET
                =1   914     ;
                =1   915     ;===============
                =1   916     ;
                =1   917     ;APPEND
                =1   918     ;       Test ASCII code in Acc.
                =1   919     ;       If it is a legal digit in the current radix,
                =1   920     ;       modify <TOS_H><TOS_L> to include this digit and return with CY set.
                =1   921     ;       Otherwise leave AES and CHAR unchanged and return with CY cleared.
                =1   922     ;       Operating mode determined by HEXMOD flag (1=Hex).
                =1   923     ;
02F1 204D3E     =1   924     APPEND: JB      H_FLG,APND_2    ;Nothing allowed after trailing 'H' received.
02F4 24D0       =1   925             ADD     A,#-'0'         ;Correct for ASCII offset.
02F6 B40A00     =1   926             CJNE    A,#10,$+3       ;Verify whether legal digit.
02F9 4013       =1   927             JC      APND_1          ;Insert decimal digit as is.
02FB 304434     =1   928             JNB     HEXMOD,APND_2   ;If in decimal mode, character isn't legal.
02FE 24EF       =1   929             ADD     A,#'0'-'A'      ;Acc now equals 0 if 'A' received.
0300 B40600     =1   930             CJNE    A,#6,$+3
0303 4007       =1   931             JC      APND_4          ;Process Hex digit.
                =1   932     ;
                =1   933     ;       Char was not hexidecimal digit, but if it was the first 'H', that's OK.
                =1   934     ;
0305 B4072A     =1   935             CJNE    A,#'H'-'A',APND_2       ;Compare original input with 'H'.
0308 D24D       =1   936             SETB    H_FLG           ;Mark that 'H' was detected but don't process.
030A D3         =1   937             SETB    C
030B 22         =1   938             RET
                =1   939     ;
030C 240A       =1   940     APND_4: ADD     A,#10           ;Value of lowest hex digit.
030E CE         =1   941     APND_1: XCH     A,TOS_L         ;Save nibble to be appended.
030F 75F00A     =1   942             MOV     B,#10           ;(Assuming radix=decimal.)
0312 304403     =1   943             JNB     HEXMOD,XRAD_1   ;Skip ahead if assumption correct.
0315 75F010     =1   944             MOV     B,#16           ;If mode is actually hex.
0318 C0F0       =1   945     XRAD_1: PUSH    B               ;Save for re-use.
031A A4         =1   946             MUL     AB              ;Multiply by radix.
031B 2E         =1   947             ADD     A,TOS_L         ;Append new digit.
031C FE         =1   948             MOV     TOS_L,A         ;Save low-order shifted value.
031D E4         =1   949             CLR     A
031E 35F0       =1   950             ADDC    A,B             ;Incremented high-order product if carry.
0320 CF         =1   951             XCH     A,TOS_H
0321 D0F0       =1   952             POP     B
0323 A4         =1   953             MUL     AB
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   22


LOC  OBJ            LINE     SOURCE

0324 2F         =1   954             ADD     A,TOS_H
0325 FF         =1   955             MOV     TOS_H,A
0326 72E7       =1   956             ORL     C,ACC.7         ;Detect if most significant bit set.
0328 E5F0       =1   957             MOV     A,B
032A 34FF       =1   958             ADDC    A,#0FFH         ;Simulate "ORL  C,NZ" instruction.
032C B044       =1   959             ANL     C,/HEXMOD       ;Overflow only relevent in decimal mode.
032E 4004       =1   960             JC      APN_ER          ;Error if bit 7 overflow occurred.
0330 D3         =1   961             SETB    C               ;CHAR processed as legal character.
0331 22         =1   962             RET
                =1   963     ;
0332 C3         =1   964     APND_2: CLR     C
0333 22         =1   965             RET
                =1   966     ;
                =1   967     ;
0334 3100       =1   968     APN_ER: CALL    EXP_ER          ;Indicate illegal entry.
0336 02         =1   969             DB      2
                =1   970     ;
                =1   971     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   23


LOC  OBJ            LINE     SOURCE

                =1   972     ;
                =1   973     OV_TST:
                =1   974     ;       If OV is set and operation is BCD mode then call EXP_ER routine.
                =1   975     ;
0337 A2D2       =1   976             MOV     C,OV
0339 B044       =1   977             ANL     C,/HEXMOD
033B 4001       =1   978             JC      EXP_OV
033D 22         =1   979             RET
                =1   980     ;
033E 3100       =1   981     EXP_OV: CALL    EXP_ER
0340 06         =1   982             DB      6
                =1   983     ;
                =1   984     ;=======
                =1   985     ;
0341 E7         =1   986     ADD_16: MOV     A,@R1           ;Add low-order bytes.
0342 2E         =1   987             ADD     A,TOS_L
0343 F7         =1   988             MOV     @R1,A           ;Save sum.
0344 09         =1   989             INC     R1
0345 E7         =1   990             MOV     A,@R1           ;Add high-order bytes.
0346 3F         =1   991             ADDC    A,TOS_H
0347 F7         =1   992             MOV     @R1,A           ;Save sum.
0348 22         =1   993             RET
                =1   994     ;
                =1   995     ;=======
                =1   996     ;
                =1   997     %*DEFINE(IADD)
                =1                  (CALL    IADD)
                =1   998     ;
                =1   999     IADD:
                =1  1000     ;       Pop VAR from AES (two bytes).
                =1  1001     ;       TOS <= TOS + VAR
                =1  1002     ;
0349 311F       =1  1003             CALL    POP_TOS
034B 7141       =1  1004             CALL    ADD_16
034D 80E8       =1  1005             JMP     OV_TST
                =1  1006     ;
                =1  1007     ;===============
                =1  1008     ;
                =1  1009     ;ISUB
                =1  1010     ;       Pop VAR from AES (two bytes).
                =1  1011     ;       TOS <= TOS - VAR
                =1  1012     ;
                =1  1013     %*DEFINE(ISUB)
                =1                  (CALL    ISUB)
                =1  1014     ;
034F 311F       =1  1015     ISUB:   ACALL   POP_TOS
0351 C3         =1  1016             CLR     C               ;Set up for subtraction with borrow.
0352 E7         =1  1017             MOV     A,@R1           ;Subtract low-order bytes.
0353 9E         =1  1018             SUBB    A,TOS_L
0354 F7         =1  1019             MOV     @R1,A           ;Save difference.
0355 09         =1  1020             INC     R1              ;Bump pointers.
0356 E7         =1  1021             MOV     A,@R1           ;Subtract high-order bytes.
0357 9F         =1  1022             SUBB    A,TOS_H
0358 F7         =1  1023             MOV     @R1,A           ;Save difference.
0359 80DC       =1  1024             JMP     OV_TST
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   24


LOC  OBJ            LINE     SOURCE

                =1  1025     ;
                =1  1026     ;=======
                =1  1027     ;
                =1  1028     %*DEFINE(IAND)
                =1                  (CALL    IAND)
                =1  1029     ;
                =1  1030     IAND:
                =1  1031     ;       Pop VAR from AES (two bytes).
                =1  1032     ;       TOS <= TOS AND VAR
                =1  1033     ;
035B 311F       =1  1034             CALL    POP_TOS
035D E7         =1  1035             MOV     A,@R1           ;AND low-order bytes.
035E 5E         =1  1036             ANL     A,TOS_L
035F F7         =1  1037             MOV     @R1,A           ;Save result.
0360 09         =1  1038             INC     R1
0361 E7         =1  1039             MOV     A,@R1           ;AND high-order bytes.
0362 5F         =1  1040             ANL     A,TOS_H
0363 F7         =1  1041             MOV     @R1,A           ;Save result.
0364 22         =1  1042             RET
                =1  1043     ;
                =1  1044     ;=======
                =1  1045     ;
                =1  1046     %*DEFINE(IOR)
                =1                  (CALL    IOR)
                =1  1047     ;
                =1  1048     IOR:
                =1  1049     ;       Pop VAR from AES (two bytes).
                =1  1050     ;       TOS <= TOS OR VAR
                =1  1051     ;
0365 311F       =1  1052             CALL    POP_TOS
0367 E7         =1  1053             MOV     A,@R1           ;OR low-order bytes.
0368 4E         =1  1054             ORL     A,TOS_L
0369 F7         =1  1055             MOV     @R1,A           ;Save result.
036A 09         =1  1056             INC     R1
036B E7         =1  1057             MOV     A,@R1           ;OR high-order bytes.
036C 4F         =1  1058             ORL     A,TOS_H
036D F7         =1  1059             MOV     @R1,A           ;Save result.
036E 22         =1  1060             RET
                =1  1061     ;
                =1  1062     ;=======
                =1  1063     ;
                =1  1064     %*DEFINE(IXOR)
                =1                  (CALL    IXOR)
                =1  1065     ;
                =1  1066     IXOR:
                =1  1067     ;       Pop VAR from AES (two bytes).
                =1  1068     ;       TOS <= TOS XOR VAR
                =1  1069     ;
036F 311F       =1  1070             CALL    POP_TOS
0371 E7         =1  1071             MOV     A,@R1           ;XOR low-order bytes.
0372 6E         =1  1072             XRL     A,TOS_L
0373 F7         =1  1073             MOV     @R1,A           ;Save result.
0374 09         =1  1074             INC     R1
0375 E7         =1  1075             MOV     A,@R1           ;XOR high-order bytes.
0376 6F         =1  1076             XRL     A,TOS_H
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   25


LOC  OBJ            LINE     SOURCE

0377 F7         =1  1077             MOV     @R1,A           ;Save result.
0378 22         =1  1078             RET
                =1  1079     ;
                =1  1080     ;===============
                =1  1081     ;
                =1  1082     %*DEFINE(NEG)
                =1                  (CALL    NEG)
                =1  1083     ;
                =1  1084     NEG:
                =1  1085     ;       TOS <= -TOS
                =1  1086     ;
0379 C3         =1  1087             CLR     C
037A B24A       =1  1088             CPL     SGN_FLG
037C A92A       =1  1089     NEG_0:  MOV     R1,AESP         ;Compute variable address.
037E 19         =1  1090             DEC     R1              ;Index for low-order byte of VAR_1.
037F E4         =1  1091             CLR     A               ;Subtract VAR_1 from 0000H.
0380 97         =1  1092             SUBB    A,@R1
0381 F7         =1  1093             MOV     @R1,A           ;Save difference.
0382 09         =1  1094             INC     R1              ;Bump pointer.
0383 E4         =1  1095             CLR     A
0384 97         =1  1096             SUBB    A,@R1           ;Subtract high-order byte.
0385 F7         =1  1097             MOV     @R1,A           ;Save difference.
0386 80AF       =1  1098             JMP     OV_TST
                =1  1099     ;
                =1  1100     ;=======
                =1  1101     ;
                =1  1102     %*DEFINE(ICPL)
                =1                   (CALL   ICPL)
                =1  1103     ;
                =1  1104     ICPL:
                =1  1105     ;       TOS <= /TOS  (ones complement)
0388 D3         =1  1106             SETB    C
0389 80F1       =1  1107             SJMP    NEG_0
                =1  1108     ;
                =1  1109     ;===============
                =1  1110     ;
                =1  1111     %*DEFINE(IABS)
                =1                   (CALL   IABS)
                =1  1112     ;
                =1  1113     IABS:
                =1  1114     ;       If in decimal mode and TOS < 0 
                =1  1115     ;       then complement SGN_FLG and negate TOS.
                =1  1116     ;
038B A92A       =1  1117             MOV     R1,AESP
038D E7         =1  1118             MOV     A,@R1
038E A2E7       =1  1119             MOV     C,ACC.7
0390 B044       =1  1120             ANL     C,/HEXMOD
0392 40E5       =1  1121             JC      NEG
0394 22         =1  1122             RET
                =1  1123     ;
                =1  1124     ;=======
                =1  1125     ;
                =1  1126     NEG_IF_NEG:
                =1  1127     ;       If SGN_FLG is set then negate TOS and complement SGN_FLG,
                =1  1128     ;       else return with TOS unchanged.
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   26


LOC  OBJ            LINE     SOURCE

0395 204AE1     =1  1129             JB      SGN_FLG,NEG
0398 22         =1  1130             RET
                =1  1131     ;
                =1  1132     ;=======
                =1  1133     ;
                =1  1134     %*DEFINE(IINC)
                =1                  (CALL    IINC)
                =1  1135     ;
                =1  1136     IINC:
                =1  1137     ;       TOS <= TOS+1
                =1  1138     ;
0399 A92A       =1  1139             MOV     R1,AESP         ;Compute variable address.
039B 19         =1  1140             DEC     R1              ;Index for low-order byte of VAR_1.
039C 07         =1  1141             INC     @R1
039D B70002     =1  1142             CJNE    @R1,#00,IINC_1
03A0 09         =1  1143             INC     R1              ;Bump pointer.
03A1 07         =1  1144             INC     @R1
03A2 22         =1  1145     IINC_1: RET
                =1  1146     ;
                =1  1147     ;=======
                =1  1148     ;
                =1  1149     MUL_16:
                =1  1150     ;       Multiply unsigned 16-bit quantity in <TOS_H><TOS_L> by entry
                =1  1151     ;       on top of stack, and return with product on stack.
                =1  1152     ;       If product exceeds 16-bits, set OV flag.
                =1  1153     ;
03A3 C2D5       =1  1154             CLR     F0              ;Initialize overflow flag.
03A5 A92A       =1  1155             MOV     R1,AESP         ;Point to MSB of NOS.
03A7 E7         =1  1156             MOV     A,@R1
03A8 6005       =1  1157             JZ      IMUL_1          ;High-order byte of either param. must be 0.
03AA EF         =1  1158             MOV     A,TOS_H
03AB 6002       =1  1159             JZ      IMUL_1
03AD D2D5       =1  1160             SETB    F0              ;Mark that both parameters exceed 255.
03AF 19         =1  1161     IMUL_1: DEC     R1              ;Index low-order NOS.
03B0 E7         =1  1162             MOV     A,@R1
03B1 8FF0       =1  1163             MOV     B,TOS_H
03B3 A4         =1  1164             MUL     AB              ;Low-order product.
03B4 30D202     =1  1165             JNB     OV,IMUL_2
03B7 D2D5       =1  1166             SETB    F0
03B9 09         =1  1167     IMUL_2: INC     R1
03BA C7         =1  1168             XCH     A,@R1           ;Save low-order prod. and load high-order NOS.
03BB 8EF0       =1  1169             MOV     B,TOS_L
03BD A4         =1  1170             MUL     AB
03BE 30D202     =1  1171             JNB     OV,IMUL_3       ;Mark if overflow.
03C1 D2D5       =1  1172             SETB    F0
03C3 27         =1  1173     IMUL_3: ADD     A,@R1
03C4 F7         =1  1174             MOV     @R1,A           ;Save high-order sum.
03C5 72D5       =1  1175             ORL     C,F0
03C7 92D5       =1  1176             MOV     F0,C
03C9 19         =1  1177             DEC     R1              ;Address low-order NOS.
03CA E7         =1  1178             MOV     A,@R1
03CB 8EF0       =1  1179             MOV     B,TOS_L
03CD A4         =1  1180             MUL     AB
03CE F7         =1  1181             MOV     @R1,A
03CF E5F0       =1  1182             MOV     A,B
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   27


LOC  OBJ            LINE     SOURCE

03D1 09         =1  1183             INC     R1
03D2 27         =1  1184             ADD     A,@R1
03D3 F7         =1  1185             MOV     @R1,A           ;Save high-order product.
03D4 72D5       =1  1186             ORL     C,F0            ;Check if carry or sign-bit set.
03D6 72E7       =1  1187             ORL     C,ACC.7         ;Check if sign-bit set.
03D8 92D2       =1  1188             MOV     OV,C
03DA 22         =1  1189             RET
                =1  1190     ;
                =1  1191     ;=======
                =1  1192     ;
                =1  1193     %*DEFINE(IMUL)
                =1                  (CALL    IMUL)
                =1  1194     ;
                =1  1195     IMUL:
                =1  1196     ;       Pop VAR from AES (two bytes).
                =1  1197     ;       TOS <= TOS * VAR
                =1  1198     ;
03DB C24A       =1  1199             CLR     SGN_FLG         ;Initialize sign monitor flag.
03DD 718B       =1  1200             CALL    IABS            ;Take absolute value of TOS.
03DF 311F       =1  1201             CALL    POP_TOS         ;Pop top entry.
03E1 718B       =1  1202             CALL    IABS            ;Take absolute value of NOS.
03E3 71A3       =1  1203             CALL    MUL_16
03E5 7137       =1  1204             CALL    OV_TST          ;Check if OV relevent.
03E7 7195       =1  1205             CALL    NEG_IF_NEG
03E9 22         =1  1206             RET
                =1  1207     ;
                =1  1208     ;===============
                =1  1209     ;
                =1  1210     %*DEFINE(IMOD)
                =1                  (CALL    IMOD)
                =1  1211     ;
03EA D24C       =1  1212     IMOD:   SETB    MOD_FLG         ;Indicate modulo entry point.
03EC 8002       =1  1213             SJMP    IDIV_0
                =1  1214     ;
                =1  1215     ;=======
                =1  1216     ;
                =1  1217     %*DEFINE(IDIV)
                =1                  (CALL    IDIV)
                =1  1218     ;
                =1  1219     IDIV:
                =1  1220     ;       Pop VAR from AES (two bytes).
                =1  1221     ;       TOS <= TOS / VAR
                =1  1222     ;       If divide-by-zero attempted report error.
                =1  1223     ;
03EE C24C       =1  1224             CLR     MOD_FLG         ;Indicate division entry point.
03F0 D24A       =1  1225     IDIV_0: SETB    SGN_FLG         ;Initialize sign monitor flag.
03F2 718B       =1  1226             CALL    IABS
03F4 7179       =1  1227             CALL    NEG
03F6 311F       =1  1228             CALL    POP_TOS
                =1  1229     ;???
                =1  1230     ; The next line of code added by lss 21-dec-1982
                =1  1231     ;???
03F8 EE         =1  1232             mov     a,tos_l
03F9 4F         =1  1233             ORL     A,TOS_H
03FA 604D       =1  1234             JZ      DIV_NG
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   28


LOC  OBJ            LINE     SOURCE

03FC A24A       =1  1235             MOV     C,SGN_FLG
03FE B04C       =1  1236             ANL     C,/MOD_FLG      ;Clear SGN_FLG if MOD funtion being done.
0400 924A       =1  1237             MOV     SGN_FLG,C
0402 718B       =1  1238             CALL    IABS
0404 F509       =1  1239             MOV     TMP1,A
0406 19         =1  1240             DEC     R1
0407 E7         =1  1241             MOV     A,@R1
0408 F508       =1  1242             MOV     TMP0,A
040A E4         =1  1243             CLR     A
040B F50B       =1  1244             MOV     TMP3,A
040D F50A       =1  1245             MOV     TMP2,A
040F 7D11       =1  1246             MOV     LP_CNT,#17
0411 C3         =1  1247             CLR     C
0412 8017       =1  1248             SJMP    DIV_RP
                =1  1249     ;
0414 E50A       =1  1250     DIV_LP: MOV     A,TMP2
0416 33         =1  1251             RLC     A
0417 F50A       =1  1252             MOV     TMP2,A
0419 C50B       =1  1253             XCH     A,TMP3
041B 33         =1  1254             RLC     A
041C C50B       =1  1255             XCH     A,TMP3
041E 2E         =1  1256             ADD     A,TOS_L
041F F50C       =1  1257             MOV     TMP4,A
0421 E50B       =1  1258             MOV     A,TMP3
0423 3F         =1  1259             ADDC    A,TOS_H
0424 5005       =1  1260             JNC     DIV_RP
0426 850C0A     =1  1261             MOV     TMP2,TMP4
0429 F50B       =1  1262             MOV     TMP3,A
042B E508       =1  1263     DIV_RP: MOV     A,TMP0
042D 33         =1  1264             RLC     A
042E F508       =1  1265             MOV     TMP0,A
0430 E509       =1  1266             MOV     A,TMP1
0432 33         =1  1267             RLC     A
0433 F509       =1  1268             MOV     TMP1,A
0435 DDDD       =1  1269             DJNZ    LP_CNT,DIV_LP
0437 204C07     =1  1270             JB      MOD_FLG,DIV_1
043A A708       =1  1271             MOV     @R1,TMP0
043C 09         =1  1272             INC     R1
043D A709       =1  1273             MOV     @R1,TMP1
043F 8005       =1  1274             SJMP    DIV_2
                =1  1275     ;
0441 A70A       =1  1276     DIV_1:  MOV     @R1,TMP2
0443 09         =1  1277             INC     R1
0444 A70B       =1  1278             MOV     @R1,TMP3
0446 7195       =1  1279     DIV_2:  CALL    NEG_IF_NEG
0448 22         =1  1280             RET
                =1  1281     ;
0449 613E       =1  1282     DIV_NG: AJMP    EXP_OV          ;Report expression overflow.
                =1  1283     ;
                =1  1284     ;===============
                =1  1285     ;
                =1  1286     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   29


LOC  OBJ            LINE     SOURCE

                =1  1287     ;
                =1  1288     %*DEFINE(RND)
                =1                   (CALL   RND)
                =1  1289     ;
                =1  1290     RND:
                =1  1291     ;       Generate a new 16-bit random number from RND_KEY,
                =1  1292     ;       and push onto the AES.
044B AE0D       =1  1293             MOV     TOS_L,SEED_L
044D AF0E       =1  1294             MOV     TOS_H,SEED_H
044F 3137       =1  1295             CALL    PUSH_TOS
0451 7E55       =1  1296             MOV     TOS_L,#LOW 25173
0453 7F62       =1  1297             MOV     TOS_H,#HIGH 25173
0455 71A3       =1  1298             CALL    MUL_16
0457 7E19       =1  1299             MOV     TOS_L,#LOW 13849
0459 7F36       =1  1300             MOV     TOS_H,#HIGH 13849
045B A92A       =1  1301             MOV     R1,AESP
045D 19         =1  1302             DEC     R1
045E 7141       =1  1303             CALL    ADD_16
0460 311F       =1  1304             CALL    POP_TOS
                =1  1305     ;
                =1  1306     ;???
                =1  1307     ; The code from here to label no_problem added by lss 21 dec 1982
                =1  1308     ; to cure a extraneous overflow if seed=8000h.
                =1  1309     ;???
                =1  1310     ;
0462 BE0007     =1  1311             cjne    tos_l,#0,no_problem
0465 BF8004     =1  1312             cjne    tos_h,#80h,no_problem
                =1  1313     big_problem:                               ; tos=8000h will generate an overflow
0468 7E2A       =1  1314             mov     tos_l,#low(12586)          ; when control gets to iabs.
046A 7F31       =1  1315             mov     tos_h,#high(12586)         ; Load the precalculated seed.
                =1  1316     no_problem:
046C 8E0D       =1  1317             MOV     SEED_L,TOS_L
046E 8F0E       =1  1318             MOV     SEED_H,TOS_H
0470 3137       =1  1319             CALL    PUSH_TOS
0472 22         =1  1320             RET
                =1  1321     ;
                =1  1322     ;===============
                =1  1323     ;
                =1  1324     %*DEFINE(CMPR)
                =1                  (CALL    CMPR)
                =1  1325     ;
                =1  1326     CMPR:
                =1  1327     ;       When CMPR is called, AES contains:
                =1  1328     ;       (TOS:)  VAR_2 (two bytes),
                =1  1329     ;               C_CODE (one byte),
                =1  1330     ;               VAR_1 (two bytes).
                =1  1331     ;       Pop all 5 bytes from stack and test relation between VAR_1 and VAR_2.
                =1  1332     ;           If C_CODE=010 then test whether (VAR_1) =  (VAR_2)
                =1  1333     ;           If C_CODE=100 then test whether (VAR_1) <  (VAR_2)
                =1  1334     ;           If C_CODE=110 then test whether (VAR_1) <= (VAR_2)
                =1  1335     ;           If C_CODE=101 then test whether (VAR_1) <> (VAR_2)
                =1  1336     ;           If C_CODE=001 then test whether (VAR_1) >  (VAR_2)
                =1  1337     ;           If C_CODE=011 then test whether (VAR_1) >= (VAR_2)
                =1  1338     ;       If true then return 0001H on AES;
                =1  1339     ;       otherwise return 0000H.
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   30


LOC  OBJ            LINE     SOURCE

                =1  1340     ;
0473 311F       =1  1341             CALL    POP_TOS
0475 3131       =1  1342             CALL    POP_ACC
0477 F5F0       =1  1343             MOV     B,A
0479 A92A       =1  1344             MOV     R1,AESP
047B 19         =1  1345             DEC     R1
047C C3         =1  1346             CLR     C               ;...in preparation for string subtract.
047D E7         =1  1347             MOV     A,@R1           ;Compare low-order parameter bytes.
047E 9E         =1  1348             SUBB    A,TOS_L
047F 09         =1  1349             INC     R1              ;Bump pointer.
0480 C7         =1  1350             XCH     A,@R1           ;Save difference.
0481 204406     =1  1351             JB      HEXMOD,CMPR_4
0484 6480       =1  1352             XRL     A,#80H          ;Offset variable by 80H for unsigned compare.
0486 CF         =1  1353             XCH     A,TOS_H
0487 6480       =1  1354             XRL     A,#80H
0489 CF         =1  1355             XCH     A,TOS_H
048A 9F         =1  1356     CMPR_4: SUBB    A,TOS_H
048B 47         =1  1357             ORL     A,@R1           ;Add any non-zero high-order bits to acc.
048C 7004       =1  1358             JNZ     CMPR_1          ;Jump ahead VAR_1 <> VAR_2.
                =1  1359     ;
                =1  1360     ;       VAR_1 = VAR_2:
                =1  1361     ;
048E A2F1       =1  1362             MOV     C,B.1           ;Load VAR_1 = VAR_2 test flag.
0490 8008       =1  1363             SJMP    PUSH_C
                =1  1364     ;
0492 4004       =1  1365     CMPR_1: JC      CMPR_2          ;Jump ahead if VAR_1 < VAR_2.
                =1  1366     ;
                =1  1367     ;       VAR_1 > VAR_2:
                =1  1368     ;
0494 A2F0       =1  1369             MOV     C,B.0           ;Load VAR_1 > VAR_2 test flag.
0496 8002       =1  1370             SJMP    PUSH_C
                =1  1371     ;
                =1  1372     ;       VAR_1 < VAR_2:
                =1  1373     ;
0498 A2F2       =1  1374     CMPR_2: MOV     C,B.2           ;Load VAR_1 < VAR_2 test flag.
049A E4         =1  1375     PUSH_C: CLR     A
049B F7         =1  1376             MOV     @R1,A
049C 33         =1  1377             RLC     A
049D 19         =1  1378             DEC     R1
049E F7         =1  1379             MOV     @R1,A
049F 22         =1  1380             RET
                =1  1381     ;
                =1  1382     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   31


LOC  OBJ            LINE     SOURCE

                    1383     $INCLUDE(TBPARS.SRC)
                =1  1384     ;       BASIC SOURCE PROGRAM LINE ACCESSING ROUTINES:
                =1  1385     ;       ===== ====== ======= ==== ======= ==========
                =1  1386     ;
                =1  1387     ;       The general methodology of the various parsing routines is as follows:
                =1  1388     ;       The POINTER (PNTR_L, PNTR_H) is used to indicate the next BASIC
                =1  1389     ;       source character or string to be parsed
                =1  1390     ;       by routines TST, TSTV, TSTN, TSTL, and TSTS.
                =1  1391     ;       GET_C reads the indicated character from the appropriate
                =1  1392     ;       program buffer space into acc. and returns.
                =1  1393     ;       READ_CHAR reads the character into CHAR as well as acc. and 
                =1  1394     ;       increments the 16-bit pointer.
                =1  1395     ;       When done, each routine calls D_BLANK to remove any trailing spaces,
                =1  1396     ;       and leaves READ_CHAR ready to fetch the next non-blank character.
                =1  1397     ;
                =1  1398     ;=======
                =1  1399     ;
                =1  1400     ;REWIND
                =1  1401     ;       Reset Cursor to start of current program buffer space.
                =1  1402     ;
04A0 C249       =1  1403     REWIND: CLR     CHAR_FLG
04A2 204105     =1  1404             JB      ROMMOD,REWROM
04A5 7A20       =1  1405             MOV     PNTR_H,#HIGH EXTRAM
04A7 7834       =1  1406             MOV     PNTR_L,#LOW EXTRAM
04A9 22         =1  1407             RET
                =1  1408     ;
04AA 204205     =1  1409     REWROM: JB      EXTMOD,RWXROM
04AD 7A0C       =1  1410             MOV     PNTR_H,#HIGH INTROM
04AF 781D       =1  1411             MOV     PNTR_L,#LOW INTROM
04B1 22         =1  1412             RET
                =1  1413     ;
04B2 7A10       =1  1414     RWXROM: MOV     PNTR_H,#HIGH EXTROM
04B4 7880       =1  1415             MOV     PNTR_L,#LOW EXTROM
04B6 22         =1  1416             RET
                =1  1417     ;
                =1  1418     ;=======
                =1  1419     ;
                =1  1420     SAVE_PNTR:
                =1  1421     ;       Save PNTR variables in cursor.
                =1  1422     ;
04B7 8851       =1  1423             MOV     CURS_L,PNTR_L
04B9 8A52       =1  1424             MOV     CURS_H,PNTR_H
04BB 8C53       =1  1425             MOV     C_SAVE,CHAR
04BD 22         =1  1426             RET
                =1  1427     ;
                =1  1428     ;=======
                =1  1429     ;
                =1  1430     LOAD_PNTR:
                =1  1431     ;       Reload pointer with value saved earlier by SAVE_PNTR.
                =1  1432     ;
04BE AA52       =1  1433             MOV     PNTR_H,CURS_H
04C0 A851       =1  1434             MOV     PNTR_L,CURS_L
04C2 AC53       =1  1435             MOV     CHAR,C_SAVE
04C4 22         =1  1436             RET
                =1  1437     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   32


LOC  OBJ            LINE     SOURCE

                =1  1438     ;=======
                =1  1439     ;
                =1  1440     GET_C:
                =1  1441     ;       Read character from logical buffer space into A and return.
                =1  1442     ;
04C5 204302     =1  1443             JB      RUNMOD,GET_BUF
04C8 E6         =1  1444             MOV     A,@PNTR_L
04C9 22         =1  1445             RET
                =1  1446     ;
                =1  1447     GET_BUF:
                =1  1448     ;       Read character from active program buffer space into A and return.
04CA 204104     =1  1449             JB      ROMMOD,GETROM
04CD 8AA0       =1  1450     %DEBUG  MOV     P2,PNTR_H       ;Select variable storage page.
04CF E2         =1  1451             MOVX    A,@PNTR_L               ;Read from external address space.
04D0 22         =1  1452             RET
                =1  1453     ;
04D1 E8         =1  1454     GETROM: MOV     A,PNTR_L
04D2 C582       =1  1455             XCH     A,DPL
04D4 CA         =1  1456             XCH     A,PNTR_H
04D5 C583       =1  1457             XCH     A,DPH
04D7 F8         =1  1458             MOV     PNTR_L,A
04D8 E4         =1  1459             CLR     A
04D9 93         =1  1460             MOVC    A,@A+DPTR
04DA C8         =1  1461             XCH     A,PNTR_L                ;Save char. and load old DPH.
04DB C583       =1  1462             XCH     A,DPH
04DD CA         =1  1463             XCH     A,PNTR_H
04DE C582       =1  1464             XCH     A,DPL
04E0 C8         =1  1465             XCH     A,PNTR_L                ;Store DPL and reload byte read.
04E1 22         =1  1466             RET
                =1  1467     ;
                =1  1468     ;=======
                =1  1469     ;
                =1  1470     READ_CHAR:
                =1  1471     ;       READ_CHAR first tests the state of CHAR_FLG.
                =1  1472     ;       If it is still cleared, the character most recently read from the line
                =1  1473     ;       buffer or program buffer has been processed, so read the next
                =1  1474     ;       character, bump the buffer pointer, and return with the character
                =1  1475     ;       in both Acc. and CHAR and the CHAR_FLG cleared.
                =1  1476     ;       If CHAR_FLG has been set by the parsing routines,
                =1  1477     ;       then CHAR still holds a previously read character which has
                =1  1478     ;       not yet been processed.  Read this character into Acc. and return
                =1  1479     ;       with CHAR_FLG again cleared.
                =1  1480     ;
04E2 104909     =1  1481             JBC     CHAR_FLG,REREAD
04E5 91C5       =1  1482             CALL    GET_C
04E7 FC         =1  1483             MOV     CHAR,A
04E8 08         =1  1484             INC     PNTR_L
04E9 B80001     =1  1485             CJNE    PNTR_L,#00,RDCHDN
04EC 0A         =1  1486             INC     PNTR_H
04ED 22         =1  1487     RDCHDN: RET
                =1  1488     ;
04EE EC         =1  1489     REREAD: MOV     A,CHAR
04EF 22         =1  1490             RET
                =1  1491     ;
                =1  1492     ;=======
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   33


LOC  OBJ            LINE     SOURCE

                =1  1493     ;
                =1  1494     PUT_BUF:
                =1  1495     ;       Put the contents of the acc. into program buffer space
                =1  1496     ;       currently active at the address held in <DEST_H><DEST_L>.
                =1  1497     ;
04F0 204104     =1  1498             JB      ROMMOD,PUTROM
04F3 8BA0       =1  1499     %DEBUG  MOV     P2,DEST_H
04F5 F3         =1  1500             MOVX    @DEST_L,A
04F6 22         =1  1501             RET
                =1  1502     ;
04F7 2100       =1  1503     PUTROM: JMP     EXP_ER
                =1  1504     ;
                =1  1505     ;=======
                =1  1506     ;
                =1  1507     WRITE_CHAR:
                =1  1508     ;       Converse of READ_CHAR.
                =1  1509     ;       Write contents of acc. into appropriate memory space (@DEST),
                =1  1510     ;       increment DEST, and return.
                =1  1511     ;
04F9 91F0       =1  1512             CALL    PUT_BUF
04FB 09         =1  1513             INC     DEST_L
04FC B90001     =1  1514             CJNE    DEST_L,#00H,WRCH_1
04FF 0B         =1  1515             INC     DEST_H
0500 22         =1  1516     WRCH_1: RET
                =1  1517     ;
                =1  1518     ;=======
                =1  1519     ;
                =1  1520     D_BLNK:
                =1  1521     ;       Remove leading blanks from BASIC source line, update cursor,
                =1  1522     ;       load first non-blank character into CHAR,
                =1  1523     ;       and leave pointer loaded with its address.
                =1  1524     ;       (This routine is jumped to by parsing routines when successful,
                =1  1525     ;       so set C before returning to original routines.)
                =1  1526     ;
0501 91E2       =1  1527             CALL    READ_CHAR
0503 6420       =1  1528             XRL     A,#' '          ;Verify that it is non-blank.
0505 60FA       =1  1529             JZ      D_BLNK          ;Loop until non-blank leading character.
0507 D249       =1  1530             SETB    CHAR_FLG
0509 D3         =1  1531             SETB    C
050A 22         =1  1532             RET                     ;Return to scanning code.
                =1  1533     ;
                =1  1534     ;=======
                =1  1535     ;
                =1  1536     ;SKPLIN
                =1  1537     ;       Skip Cursor over entire BASIC source line, leaving
                =1  1538     ;       cursor pointing to character after terminating <CR>.
                =1  1539     ;SKPTXT
                =1  1540     ;       Skip remainder of line in progress, assuming line number 
                =1  1541     ;       has already been passed over.
                =1  1542     ;       (Note that either byte of binary line number could be
                =1  1543     ;       mis-interpreted as a CR.)
                =1  1544     ;
                =1  1545     %*DEFINE(SKPTXT)
                =1                   (CALL   SKPTXT)
                =1  1546     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   34


LOC  OBJ            LINE     SOURCE

050B 91E2       =1  1547     SKPLIN: CALL    READ_CHAR
050D 91E2       =1  1548             CALL    READ_CHAR
050F 91E2       =1  1549     SKPTXT: CALL    READ_CHAR
0511 B40DFB     =1  1550             CJNE    A,#CR,SKPTXT    ;Verify that it is non-<CR>.
0514 22         =1  1551             RET                     ;Return to scanning code.
                =1  1552     ;
                =1  1553     ;=======
                =1  1554     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   35


LOC  OBJ            LINE     SOURCE

                =1  1555     ;
                =1  1556     ;       Token recognition and processing routines.
                =1  1557     ;
                =1  1558     %*DEFINE(TST(LBL,TEMPLATE))
                =1                  (CALL    TST
                =1           %IF     (%LEN(%TEMPLATE) GT 1) THEN
                =1           (         DB      '%SUBSTR(%TEMPLATE,1,%LEN(%TEMPLATE)-1)','%SUBSTR(%TEMPLATE,
                =1                                   %LEN(%TEMPLATE),1)' OR 80H)
                =1           ELSE
                =1           (         DB      '%TEMPLATE' OR 80H)
                =1           FI
                =1                     JNC     %LBL)
                =1  1559     ;
                =1  1560     TST:
                =1  1561     ;       If "TEMPLATE" matches the BASIC character string read by 
                =1  1562     ;       READ_CHAR then move pointer over string and any trailing blanks
                =1  1563     ;       and continue with the following IL instruction.
                =1  1564     ;       Otherwise leave pointer unchanged and branch to IL instruction at LBL.
                =1  1565     ;
0515 D083       =1  1566             POP     DPH             ;Get in-line parameter base address from stack.
0517 D082       =1  1567             POP     DPL
0519 91E2       =1  1568             CALL    READ_CHAR
051B 91B7       =1  1569             CALL    SAVE_PNTR
051D E4         =1  1570     TST_1:  CLR     A
051E 93         =1  1571             MOVC    A,@A+DPTR       ;Read next character from template string.
051F A2E7       =1  1572             MOV     C,ACC.7         ;Save terminator bit.
0521 547F       =1  1573             ANL     A,#7FH          ;Mask off terminator.
0523 6C         =1  1574             XRL     A,CHAR          ;Compare with template.
0524 7012       =1  1575             JNZ     T_BAD           ;Abort if first characters miscompare.
0526 A3         =1  1576             INC     DPTR            ;Pass over template character just checked.
0527 400B       =1  1577             JC      T_GOOD          ;Done if template character bit 7 set.
0529 91E2       =1  1578             CALL    READ_CHAR       ;Fetch next character for test.
052B BC2EEF     =1  1579             CJNE    CHAR,#'.',TST_1 ;Done if input string abbreviated at this point
052E E4         =1  1580     TST_2:  CLR     A               ;Fetch template characters until end of string
052F 93         =1  1581             MOVC    A,@A+DPTR
0530 A3         =1  1582             INC     DPTR
0531 30E7FA     =1  1583             JNB     ACC.7,TST_2     ;Loop until last character detected.
0534 B101       =1  1584     T_GOOD: CALL    D_BLNK
0536 E4         =1  1585             CLR     A
0537 73         =1  1586             JMP     @A+DPTR         ;Return to next IL instruction
                =1  1587     ;
                =1  1588     ;       Strings do not match.  Leave cursor at start of string.
                =1  1589     ;
0538 E4         =1  1590     T_BAD:  CLR     A
0539 93         =1  1591             MOVC    A,@A+DPTR       ;Search for final template character.
053A A3         =1  1592             INC     DPTR
053B 30E7FA     =1  1593             JNB     ACC.7,T_BAD     ;Loop until terminator found.
053E 91BE       =1  1594             CALL    LOAD_PNTR
0540 D249       =1  1595             SETB    CHAR_FLG
0542 C3         =1  1596             CLR     C               ;Mark string not found.
0543 E4         =1  1597             CLR     A
0544 73         =1  1598             JMP     @A+DPTR         ;Return to mismatch branch instruction.
                =1  1599     ;
                =1  1600     ;===============
                =1  1601     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   36


LOC  OBJ            LINE     SOURCE

                =1  1602     ;TSTV   (LBL)
                =1  1603     %*DEFINE(TSTV(LBL))
                =1                  (CALL    TSTV
                =1                     JNC     %LBL)
                =1  1604     ;
                =1  1605     ;
                =1  1606     TSTV:
                =1  1607     ;       Test if first non-blank string is a legal variable symbol.
                =1  1608     ;       If so, move cursor over string and any trailing blanks,
                =1  1609     ;       compute variable index value,
                =1  1610     ;       push onto arithmetic expression stack,
                =1  1611     ;       and continue with following IL instruction.
                =1  1612     ;       Otherwise branch to IL instruction at LBL with cursor unaffected.
                =1  1613     ;
0545 91E2       =1  1614             CALL    READ_CHAR
0547 24BF       =1  1615             ADD     A,#-'A'         ;Subtract offset for base variable.
0549 FE         =1  1616             MOV     TOS_L,A         ;Save index in case needed later.
054A 24E6       =1  1617             ADD     A,#-26
054C 5004       =1  1618             JNC     ALPHAB          ;First character is alphabetic if C=0.
054E D249       =1  1619             SETB    CHAR_FLG
0550 C3         =1  1620             CLR     C
0551 22         =1  1621             RET
                =1  1622     ;
0552 91B7       =1  1623     ALPHAB: CALL    SAVE_PNTR       ;In case variable name not found.
0554 91E2       =1  1624             CALL    READ_CHAR       ;Verify that next character is not alphabetic.
0556 24BF       =1  1625             ADD     A,#-'A'         ;Alphabetic characters now <= 25.
0558 24E6       =1  1626             ADD     A,#-26          ;Non-alphabetics cause overflow.
055A 5003       =1  1627             JNC     NOTVAR          ;Alphabetic character means illegal var. name.
055C BC2E40     =1  1628             CJNE    CHAR,#'.',TSTV_1        ;Period indicates abbreviated keyword.
055F 91BE       =1  1629     NOTVAR: CALL    LOAD_PNTR
0561 D249       =1  1630             SETB    CHAR_FLG
0563 B115       =1  1631             %TST    (TSTRBI,DBYTE)  ;Test if direct byte token.
056C 315E       =1  1634             %LIT    (1)
056F 8027       =1  1636             SJMP    INDEX
                =1  1637     ;
0571 B115       =1  1638     TSTRBI: %TST    (TSTXBY,RBIT)
0579 315E       =1  1641             %LIT    (2)
057C 801A       =1  1643             SJMP    INDEX
                =1  1644     ;
057E B115       =1  1645     TSTXBY: %TST    (TSTCBY,XBYTE)  ;Test if expansion RAM byte token.
0587 315E       =1  1648             %LIT    (3)
058A 800C       =1  1650             SJMP    INDEX
                =1  1651     ;
058C B115       =1  1652     TSTCBY: %TST    (NOTSYM,CBYTE)  ;Test if program memory byte token.
0595 315E       =1  1655             %LIT    (4)
0598 120B8B     =1  1657     INDEX:  CALL    VAR
059B D3         =1  1658             SETB    C
059C 22         =1  1659             RET
                =1  1660     ;
059D C3         =1  1661     NOTSYM: CLR     C               ;Indicate that condition tested wasn't true.
059E 22         =1  1662             RET
                =1  1663     ;
                =1  1664     ;       BASIC Variable name is legitimate (A-Z).
                =1  1665     ;
059F 315E       =1  1666     TSTV_1: %LIT    (0)
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   37


LOC  OBJ            LINE     SOURCE

05A2 7F00       =1  1668             MOV     TOS_H,#0
05A4 3137       =1  1669             CALL    PUSH_TOS
05A6 D249       =1  1670             SETB    CHAR_FLG
05A8 A101       =1  1671             JMP     D_BLNK          ;Remove leading blanks from source line.
                =1  1672     ;
                =1  1673     ;===============
                =1  1674     ;
                =1  1675     ;TSTN   (LBL)
                =1  1676     ;       Test if indicated string is an unsigned number.
                =1  1677     ;       If so, move cursor over string and trailing blanks,
                =1  1678     ;       compute number's binary value,
                =1  1679     ;       push onto arithmetic expression stack, and continue with
                =1  1680     ;       following IL instruction.
                =1  1681     ;       Otherwise restore cursor and branch to IL instruction at LBL.
                =1  1682     ;
                =1  1683     %*DEFINE(TSTN(LBL))
                =1                  (CALL    TSTN
                =1                     JNC     %LBL)
                =1  1684     ;
05AA 91E2       =1  1685     TSTN:   CALL    READ_CHAR
05AC 51E4       =1  1686             CALL    CREATE          ;Create entry on AES if legit. digit.
05AE 4003       =1  1687             JC      TSTN_1          ;Abort if CHAR is not decimal digit.
05B0 D249       =1  1688             SETB    CHAR_FLG
05B2 22         =1  1689             RET
                =1  1690     ;
05B3 91E2       =1  1691     TSTN_1: CALL    READ_CHAR       ;Move over matched character.
05B5 51F1       =1  1692             CALL    APPEND          ;Append new digit to entry on TOS.
05B7 40FA       =1  1693             JC      TSTN_1          ;Continue processing while legal characters.
05B9 3137       =1  1694             CALL    PUSH_TOS
05BB D249       =1  1695             SETB    CHAR_FLG
05BD A101       =1  1696             JMP     D_BLNK          ;Remove leading blank characters.
                =1  1697     ;
                =1  1698     ;===============
                =1  1699     ;
                =1  1700     ;TSTL   (LBL)
                =1  1701     ;       Test if first non-blank string is a BASIC source line number.
                =1  1702     ;       If so, move cursor over string and following blanks,
                =1  1703     ;       compute number's binary value,
                =1  1704     ;       push onto arithmetic expression stack, 
                =1  1705     ;       and continue with next IL instruction.
                =1  1706     ;       If invalid source line number report syntax error.
                =1  1707     ;       If line number not present restore cursor
                =1  1708     ;       and branch to IL instruction at LBL.
                =1  1709     ;
                =1  1710     %*DEFINE(TSTL(LBL))
                =1                  (CALL    TSTN
                =1                     JNC     %LBL)
                =1  1711     ;
                =1  1712     ;===============
                =1  1713     ;
                =1  1714     ;TSTS   (LBL)
                =1  1715     ;       Test if first character is a quote.
                =1  1716     ;       If so, print characters from the BASIC source program to the console
                =1  1717     ;       until a (closing) quote is encountered,
                =1  1718     ;       pass over any trailing blanks,
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   38


LOC  OBJ            LINE     SOURCE

                =1  1719     ;       leave source cursor pointing to first non-blank character,
                =1  1720     ;       and branch to IL instruction at location (LBL).
                =1  1721     ;       (Report syntax error if <CR> encountered before quote.)
                =1  1722     ;       If first character is not a quote, return to next
                =1  1723     ;       sequential IL instruction with cursor unchanged.
                =1  1724     ;
                =1  1725     %*DEFINE(TSTS(LBL))
                =1                  (CALL    TSTS
                =1                     JC      %LBL)
                =1  1726     ;
05BF 91E2       =1  1727     TSTS:   CALL    READ_CHAR
05C1 F508       =1  1728             MOV     TMP0,A
05C3 6422       =1  1729             XRL     A,#'"'
05C5 6008       =1  1730             JZ      TSTS_1
05C7 6405       =1  1731             XRL     A,#'''' XOR '"'
05C9 6004       =1  1732             JZ      TSTS_1
05CB C3         =1  1733             CLR     C
05CC D249       =1  1734             SETB    CHAR_FLG
05CE 22         =1  1735             RET
                =1  1736     ;
05CF 91E2       =1  1737     TSTS_1: CALL    READ_CHAR       ;Read next string character.
05D1 B50802     =1  1738             CJNE    A,TMP0,TSTS_2
05D4 A101       =1  1739             JMP     D_BLNK
                =1  1740     ;
05D6 119A       =1  1741     TSTS_2: CALL    C_OUT           ;Call output routine.
05D8 B40DF4     =1  1742             CJNE    A,#CR,TSTS_1    ;<CR> before closing quote is illegal.
05DB 2114       =1  1743             JMP     SYN_ER          ;Transmit error message.
                =1  1744     ;
                =1  1745     ;===============
                =1  1746     ;
                =1  1747     ;DONE
                =1  1748     ;       Delete leading blanks from the BASIC source line.
                =1  1749     ;       Return with the cursor positioned over the first non-blank
                =1  1750     ;       character, which must be a colon or <CR> in the source line.
                =1  1751     ;       If any other characters are encountered report a syntax error.
                =1  1752     ;
                =1  1753     %*DEFINE(DONE)
                =1                  (CALL    DONE)
                =1  1754     ;
                =1  1755     %*DEFINE(LNDONE)
                =1                  (CALL    LNDONE)
                =1  1756     ;
05DD 91E2       =1  1757     DONE:   CALL    READ_CHAR
05DF BC3A03     =1  1758             CJNE    CHAR,#':',DONE_1        ;Colon indicates resume interpretation.
05E2 22         =1  1759             RET                     ;Return to IL.
                =1  1760     ;
05E3 91E2       =1  1761     LNDONE: CALL    READ_CHAR
05E5 BC0D01     =1  1762     DONE_1: CJNE    CHAR,#CR,DONE_2 ;Any non-colon, non-CR characters are illegal.
05E8 22         =1  1763             RET
                =1  1764     ;
05E9 D249       =1  1765     DONE_2: SETB    CHAR_FLG
05EB 2114       =1  1766             JMP     SYN_ER          ;Process syntax error if so.
                =1  1767     ;
                =1  1768     ;=======
                =1  1769     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   39


LOC  OBJ            LINE     SOURCE

                =1  1770     ;IFDONE (LBL)
                =1  1771     ;       If the first non-blank character is a colon or <CR> in the source line
                =1  1772     ;       then branch to the IL instruction specified by (LBL).
                =1  1773     ;       If any other characters are encountered
                =1  1774     ;       then continue with next IL instruction.
                =1  1775     ;
                =1  1776     %*DEFINE(IFDONE(LBL))
                =1                  (CALL    IFDONE
                =1                     JNC     %LBL)
                =1  1777     ;
05ED 91E2       =1  1778     IFDONE: CALL    READ_CHAR
05EF BC3A01     =1  1779             CJNE    CHAR,#':',IFDN_1        ;Colon indicates resume interpretation.
05F2 22         =1  1780             RET                     ;Return to IL.
                =1  1781     ;
05F3 BC0D01     =1  1782     IFDN_1: CJNE    CHAR,#CR,IFDN_2 ;Any non-colon, non-CR characters are illegal.
05F6 22         =1  1783             RET
                =1  1784     ;
05F7 D249       =1  1785     IFDN_2: SETB    CHAR_FLG
05F9 D3         =1  1786             SETB    C
05FA 22         =1  1787             RET
                =1  1788     ;
                =1  1789     ;=======
                    1790     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   40


LOC  OBJ            LINE     SOURCE

                    1791     READ_LABEL:
                    1792     ;       Read next two characters from program buffer into <LABL_H><LABL_L>.
                    1793     ;       Return with carry set if bit 15 of LABL is set (indicating EOF).
                    1794     ;
05FB 91E2           1795             CALL    READ_CHAR
05FD F555           1796             MOV     LABL_H,A
05FF 91E2           1797             CALL    READ_CHAR
0601 F554           1798             MOV     LABL_L,A
0603 E555           1799             MOV     A,LABL_H
0605 A2E7           1800             MOV     C,ACC.7
0607 22             1801             RET
                    1802     ;
                    1803     ;=======
                    1804     ;
                    1805     %*DEFINE(LINIT)
                                     (CALL   L_INIT
                                       JC      ERRENT)
                    1806     ;
                    1807     L_INIT:
                    1808     ;       Initialize for execution of new BASIC source line.
                    1809     ;       If none present, or if not in sequential execution mode, 
                    1810     ;       then return to line collection operation.
                    1811     ;
0608 304302         1812             JNB     RUNMOD,LINI_1   ;Determine operating mode.
060B 80EE           1813             JMP     READ_LABEL
                    1814     ;
060D D3             1815     LINI_1: SETB    C
060E 22             1816             RET
                    1817     ;
                    1818     ;=======
                    1819     ;
                    1820     %*DEFINE(NL_NXT)
                                    (JMP     NL_NXT)
                    1821     ;
                    1822     %*DEFINE(NXT)
                                    (JMP     NXT)
                    1823     ;
                    1824     NL_NXT:
                    1825     ;       Output a <CR><LF> and continue with NXT routine.
                    1826     ;
060F 1198           1827             CALL    NLINE
                    1828     ;
                    1829     NXT:
                    1830     ;       A colon or carriage return has been previously READ_CHARed.
                    1831     ;       If CHAR holds a colon,
                    1832     ;       continue interpretation of source line in current mode
                    1833     ;       from IL program instruction "TOKEN".
                    1834     ;       Otherwise CHAR is a <CR>, and line has been completed.
                    1835     ;       Resume execution from IL instruction "STMT".
                    1836     ;
0611 BC3A05         1837             CJNE    CHAR,#':',NXT_1 ;Skip ahead unless colon detected.
0614 B101           1838             CALL    D_BLNK
0616 020888         1839             JMP     TOKEN           ;Continue with interpretation.
                    1840     ;
0619 020883         1841     NXT_1:  JMP     STMT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   41


LOC  OBJ            LINE     SOURCE

                    1842     ;
                    1843     ;=======
                    1844     ;
                    1845     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   42


LOC  OBJ            LINE     SOURCE

                    1846     ;
                    1847     %*DEFINE(GETLN)
                                    (CALL    GETLN)
                    1848     ;
                    1849     GETLN:
                    1850     ;       Input a line from console input device and put in line buffer
                    1851     ;       in internal RAM.
                    1852     ;
061C E52A           1853             MOV     A,AESP
061E 2404           1854             ADD     A,#4
0620 F508           1855             MOV     TMP0,A
0622 A808           1856     GETL_0: MOV     R0,TMP0         ;Point to beginning of line buffer.
0624 11EB           1857             CALL    STROUT
0626 BE             1858             DB      '>' OR 80H
0627 117C           1859     GETL_1: CALL    C_IN            ;Get next character from console.
0629 B41212         1860             CJNE    A,#12H,GETL_5   ;Re-type line on <CNTRL-R>.
062C 11EB           1861             CALL    STROUT
062E 8D             1862             DB      CR OR 80H       ;Newline.
062F 8851           1863             MOV     CURS_L,R0       ;Save old value of cursor.
0631 A808           1864             MOV     R0,TMP0         ;Start at beginning of line buffer.
0633 E8             1865     GETL_6: MOV     A,R0            ;Check if re-write done.
0634 6551           1866             XRL     A,CURS_L
0636 60EF           1867             JZ      GETL_1          ;Continue with line input.
0638 E6             1868             MOV     A,@R0           ;Load character to re-write.
0639 119A           1869             CALL    C_OUT
063B 08             1870             INC     R0
063C 80F5           1871             SJMP    GETL_6          ;Continue until done.
                    1872     ;
063E B41806         1873     GETL_5: CJNE    A,#18H,GETL_7   ;Cancel whole line on <CNTRL-X>.
0641 11EB           1874             CALL    STROUT
0643 23             1875             DB      '#',CR OR 80H   ;Advance to next line.
0644 8D
0645 80DB           1876             SJMP    GETL_0
                    1877     ;
0647 B47F11         1878     GETL_7: CJNE    A,#7FH,GETL_3
064A E8             1879             MOV     A,R0
064B B50805         1880             CJNE    A,TMP0,GETL_4   ;Delete previous character (if any).
064E 11EB           1881             CALL    STROUT
0650 87             1882             DB      BEL OR 80H      ;Echo <BEL>.
0651 80D4           1883             SJMP    GETL_1          ;Ignore rubouts at beginning of line
                    1884     ;
0653 11EB           1885     GETL_4: CALL    STROUT
0655 08             1886             DB      08H,' ',88H     ;BKSP,SPC,BKSP
0656 20
0657 88
0658 18             1887             DEC     R0              ;Wipeout last char.
0659 80CC           1888             SJMP    GETL_1
                    1889     ;
065B B84E05         1890     GETL_3: CJNE    R0,#AES+AESLEN-1,GETL_2 ;Test if buffer full.
065E 11EB           1891             CALL    STROUT          ;Echo <BEL>.
0660 87             1892             DB      BEL OR 80H
0661 80C4           1893             SJMP    GETL_1          ;If so, override character received.
                    1894     ;
0663 F6             1895     GETL_2: MOV     @R0,A           ;Store into line buffer.
0664 119A           1896             CALL    C_OUT           ;Echo character.
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   43


LOC  OBJ            LINE     SOURCE

0666 08             1897             INC     R0              ;Bump pointer.
0667 B40DBD         1898             CJNE    A,#CR,GETL_1    ;Repeat for next character.
066A A808           1899             MOV     PNTR_L,TMP0     ;Point cursor to beginning of line buffer.
066C C249           1900             CLR     CHAR_FLG
066E 22             1901             RET
                    1902     ;
                    1903     ;===============
                    1904     ;
                    1905     %*DEFINE(PRN)
                                     (CALL   PRN)
                    1906     ;
                    1907     PRN:
                    1908     ;       Pop top of arithmetic expression stack (AES), 
                    1909     ;       convert to decimal number,
                    1910     ;       and print to console output device, suppressing leading zeroes.
                    1911     ;
066F C24A           1912             CLR     SGN_FLG
0671 718B           1913             CALL    IABS
0673 311F           1914             CALL    POP_TOS
0675 D248           1915     PRNTOS: SETB    ZERSUP          ;Set zero suppression flag.
0677 E4             1916             CLR     A
0678 F508           1917             MOV     TMP0,A
067A 7D10           1918             MOV     LP_CNT,#16      ;Conversion precision.
067C 20441D         1919             JB      HEXMOD,PRNHEX
067F 304A03         1920             JNB     SGN_FLG,PRN_1   ;Skip ahead if positive number.
0682 11EB           1921             CALL    STROUT          ;Output minus sign if negative.
0684 AD             1922             DB      '-' OR 80H
0685 CE             1923     PRN_1:  XCH     A,TOS_L
0686 33             1924             RLC     A
0687 CE             1925             XCH     A,TOS_L
0688 CF             1926             XCH     A,TOS_H
0689 33             1927             RLC     A
068A CF             1928             XCH     A,TOS_H
068B C508           1929             XCH     A,TMP0
068D 35E0           1930             ADDC    A,ACC
068F D4             1931             DA      A
0690 C508           1932             XCH     A,TMP0
0692 35E0           1933             ADDC    A,ACC
0694 D4             1934             DA      A
0695 DDEE           1935             DJNZ    LP_CNT,PRN_1
0697 FF             1936             MOV     TOS_H,A
0698 EE             1937             MOV     A,TOS_L
0699 33             1938             RLC     A
069A AE08           1939             MOV     TOS_L,TMP0
069C 11CC           1940     PRNHEX: CALL    NIBOUT
069E EF             1941             MOV     A,TOS_H
069F C4             1942             SWAP    A
06A0 11CC           1943             CALL    NIBOUT          ;Print second digit.
06A2 EF             1944             MOV     A,TOS_H
06A3 11CC           1945             CALL    NIBOUT          ;Print third digit.
06A5 304402         1946             JNB     HEXMOD,PRNH_1
06A8 C248           1947             CLR     ZERSUP          ;Print out last two chars. (at least) in hex.
06AA EE             1948     PRNH_1: MOV     A,TOS_L         ;Read into Acc.
06AB C4             1949             SWAP    A               ;Interchange nibbles.
06AC 11CC           1950             CALL    NIBOUT          ;Print fourth digit.
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   44


LOC  OBJ            LINE     SOURCE

06AE C248           1951             CLR     ZERSUP
06B0 EE             1952             MOV     A,TOS_L         ;Reload byte.
06B1 11CC           1953             CALL    NIBOUT          ;Print last digit.
06B3 304403         1954             JNB     HEXMOD,PRNRET
06B6 11EB           1955             CALL    STROUT          ;Print trailing "H".
06B8 C8             1956             DB      'H' OR 80H
06B9 22             1957     PRNRET: RET
                    1958     ;
                    1959     ;===============
                    1960     ;
                    1961     LSTLIN:
                    1962     ;       Check Label of Program line pointed to by Cursor.
                    1963     ;       If legal, print line number, source line, and <CR><LF> to console,
                    1964     ;       adjust Cursor to start of next line, 
                    1965     ;       and return with carry set.
                    1966     ;       Else return with carry cleared.
                    1967     ;
06BA B1FB           1968             CALL    READ_LABEL
06BC 4012           1969             JC      LSTL_1
06BE AF55           1970             MOV     TOS_H,LABL_H
06C0 AE54           1971             MOV     TOS_L,LABL_L
06C2 C24A           1972             CLR     SGN_FLG
06C4 D175           1973             CALL    PRNTOS
06C6 11EB           1974             CALL    STROUT          ;Insert space before user's source line.
06C8 A0             1975             DB      ' ' OR 80H
06C9 91E2           1976     LSTL_2: CALL    READ_CHAR
06CB 119A           1977             CALL    C_OUT
06CD B40DF9         1978             CJNE    A,#CR,LSTL_2
06D0 22             1979     LSTL_1: RET
                    1980     ;
                    1981     ;===============
                    1982     ;
                    1983     ;LST
                    1984     ;       List the contents of the program memory area.
                    1985     ;
                    1986     %*DEFINE(LST)
                                    (CALL    LST)
                    1987     ;
06D1 D243           1988     LST:    SETB    RUNMOD
06D3 91A0           1989             CALL    REWIND          ;Point to first char of external buffer.
06D5 11B7           1990     LST_1:  CALL    CNTRL
06D7 4004           1991             JC      LSTRET
06D9 D1BA           1992             CALL    LSTLIN          ;Print out current line if present.
06DB 50F8           1993             JNC     LST_1           ;Repeat if successful.
06DD C243           1994     LSTRET: CLR     RUNMOD
06DF 22             1995             RET
                    1996     ;
                    1997     ;===============
                    1998     ;
                    1999     %*DEFINE(INNUM)
                                    (CALL    INNUM)
                    2000     ;
                    2001     INNUM:
                    2002     ;       Read a numeric character string from the console input device.
                    2003     ;       Convert to binary value and push onto arithmetic expression stack.
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   45


LOC  OBJ            LINE     SOURCE

                    2004     ;       Report error if illegal characters read.
                    2005     ;
06E0 C24A           2006             CLR     SGN_FLG         ;Assume number will be positive.
06E2 11EB           2007             CALL    STROUT
06E4 3A             2008             DB      ':',' ' OR 80H  ;Print input prompt.
06E5 A0
06E6 117C           2009     INUM_0: CALL    C_IN
06E8 119A           2010             CALL    C_OUT           ;Echo input
06EA B42002         2011             CJNE    A,#' ',INUM_3
06ED 80F7           2012             SJMP    INUM_0
                    2013     ;
06EF B42B02         2014     INUM_3: CJNE    A,#'+',INUM_4
06F2 80F2           2015             SJMP    INUM_0
                    2016     ;
06F4 B42D04         2017     INUM_4: CJNE    A,#'-',INUM_5
06F7 B24A           2018             CPL     SGN_FLG
06F9 80EB           2019             SJMP    INUM_0
                    2020     ;
06FB 51E4           2021     INUM_5: CALL    CREATE          ;Create value on stack if legal decimal digit.
06FD 5007           2022             JNC     INUM_2          ;Abort if first character received not legal.
06FF 117C           2023     INUM_1: CALL    C_IN            ;Get additional characters.
0701 119A           2024             CALL    C_OUT           ;Echo input.
0703 B47F06         2025             CJNE    A,#7FH,INUM_6   ;Start over if delete char detected.
0706 11EB           2026     INUM_2: CALL    STROUT
0708 23             2027             DB      '#',CR OR 80H
0709 8D
070A 80D4           2028             SJMP    INNUM
                    2029     ;
070C 51F1           2030     INUM_6: CALL    APPEND          ;Incorporate into stack entry.
070E 40EF           2031             JC      INUM_1          ;Loop while legal characters arrive.
0710 3137           2032             CALL    PUSH_TOS
0712 6195           2033             JMP     NEG_IF_NEG
                    2034     ;
                    2035     ;===============
                    2036     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   46


LOC  OBJ            LINE     SOURCE

                    2037     RAM_INIT:
0714 E4             2038             CLR     A               ;Many bytes to be cleared...
0715 F528           2039             MOV     MODE,A          ;Interactive mode, decimal radix.
0717 F529           2040             MOV     FLAGS,A         ;Interroutine flags.
0719 75A020         2041     %DEBUG  MOV     P2,#HIGH EXTRAM ;Select first External RAM page.
071C F8             2042             MOV     R0,A
071D 745A           2043             MOV     A,#5AH          ;Random bit pattern.
071F F2             2044             MOVX    @R0,A
0720 E2             2045             MOVX    A,@R0
0721 645A           2046             XRL     A,#5AH
0723 600A           2047             JZ      EXTINI
0725 E4             2048             CLR     A
0726 7810           2049             MOV     R0,#US_VAR      ;Clear variable array.
0728 F6             2050     INIT_1: MOV     @R0,A
0729 08             2051             INC     R0
072A B828FB         2052             CJNE    R0,#US_VAR+2*NO_VAR,INIT_1      ;Loop until all vars cleared.
072D 8009           2053             SJMP    INIT_3
                    2054     ;
072F D240           2055     EXTINI: SETB    EXTVAR
0731 E4             2056             CLR     A
0732 F8             2057             MOV     R0,A            ;Clear variable array.
0733 F2             2058     INIT_2: MOVX    @R0,A
0734 08             2059             INC     R0
0735 B834FB         2060             CJNE    R0,#2*26,INIT_2 ;Loop until all vars cleared.
0738 22             2061     INIT_3: RET
                    2062     ;
                    2063     ;========
                    2064     ;
                    2065     ;INIT
                    2066     ;       Perform global initialization:
                    2067     ;       Clear program memory, empty all I/O buffers, reset all stack
                    2068     ;       pointers, etc.
                    2069     ;
                    2070     %*DEFINE(INIT)
                                    (CALL    INIT)
                    2071     ;
0739 F114           2072     INIT:   CALL    RAM_INIT
073B 7834           2073             MOV     R0,#LOW EXTRAM
073D 74FF           2074             MOV     A,#0FFH
073F F2             2075             MOVX    @R0,A
0740 22             2076             RET
                    2077     ;
                    2078     ;===============
                    2079     ;
                    2080     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   47


LOC  OBJ            LINE     SOURCE

                    2081     ;
                    2082     ;       BASIC PROGRAM LINE SEQUENCE CONTROL MACROS:
                    2083     ;       ===== ======= ==== ======== ======= ======
                    2084     ;
                    2085     ;XINIT
                    2086     ;       Perform initialization needed before starting sequential execution.
                    2087     ;       Empty stacks, set BASIC line number to 1, etc.
                    2088     ;
                    2089     %*DEFINE(XINIT)
                                    (CALL    XINIT)
                    2090     ;
0741 752A2A         2091     XINIT:  MOV     AESP,#AES-1     ;Initialize AE Stack.
0744 91A0           2092             CALL    REWIND
0746 D243           2093             SETB    RUNMOD
0748 22             2094             RET                     ;Begin execution.
                    2095     ;
                    2096     ;===============
                    2097     ;
                    2098     FNDLBL:
                    2099     ;       Search program buffer for line with label passed on AES (Pop AES).
                    2100     ;       If found, return with CURSOR pointing to start of line (before label)
                    2101     ;       and carry cleared.
                    2102     ;       If not found return with carry set and pointer at start of first
                    2103     ;       line with a greater label value (possible EOF).
                    2104     ;
0749 D243           2105             SETB    RUNMOD          ;Kludge to make GET_C fetch from prog. buffer.
074B 91A0           2106             CALL    REWIND
074D 311F           2107             CALL    POP_TOS
074F 91B7           2108     FND_1:  CALL    SAVE_PNTR       ;Store position of beginning of line.
0751 B1FB           2109             CALL    READ_LABEL
0753 4012           2110             JC      FNDDON
0755 EE             2111             MOV     A,TOS_L
0756 9554           2112             SUBB    A,LABL_L
0758 F554           2113             MOV     LABL_L,A        ;Save non-zero bits.
075A EF             2114             MOV     A,TOS_H
075B 9555           2115             SUBB    A,LABL_H
075D 4554           2116             ORL     A,LABL_L        ;Test for non-zero bits.
075F 6006           2117             JZ      FNDDON
0761 4004           2118             JC      FNDDON          ;Carry=1 if a greater label value found.
0763 B10F           2119             CALL    SKPTXT          ;Skip over remaining text portion of line.
0765 80E8           2120             SJMP    FND_1
                    2121     ;
0767 81BE           2122     FNDDON: JMP     LOAD_PNTR
                    2123     ;
                    2124     ;=======
                    2125     ;
                    2126     KILL_L:
                    2127     ;       Kill (delete) line from code buffer indicated by pointer.
                    2128     ;       When called, CURSOR and POINTER hold the address of first LABEL byte of
                    2129     ;       line to be deleted.
                    2130     ;
0769 A951           2131             MOV     DEST_L,CURS_L
076B AB52           2132             MOV     DEST_H,CURS_H
076D B10B           2133             CALL    SKPLIN          ;Pass pointer over full text line.
                    2134     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   48


LOC  OBJ            LINE     SOURCE

                    2135     ;       Pointer now indicates first label byte of following line.
                    2136     ;       Cursor and DEST still indicate first label byte of obsolete line.
                    2137     ;
076F 91E2           2138     KILL_2: CALL    READ_CHAR       ;Copy down first label byte.
0771 91F9           2139             CALL    WRITE_CHAR      ;Transfer first byte of label number.
0773 20E70D         2140             JB      ACC.7,KILL_9    ;Quit when End of Code sentinel reached.
0776 91E2           2141             CALL    READ_CHAR       ;Copy down second label byte.
0778 91F9           2142             CALL    WRITE_CHAR      ;Store second byte of label number.
077A 91E2           2143     KILL_3: CALL    READ_CHAR       ;Transfer text character.
077C 91F9           2144             CALL    WRITE_CHAR
077E B40DF9         2145             CJNE    A,#CR,KILL_3    ;Loop until full line moved.
0781 80EC           2146             SJMP    KILL_2          ;Continue until all code moved forward.
                    2147     ;
0783 22             2148     KILL_9: RET                     ;Full line now deleted.
                    2149     ;
                    2150     ;=======
                    2151     ;
                    2152     OPEN_L:
                    2153     ;       Open space for new line in code buffer starting at Cursor.
                    2154     ;
0784 91BE           2155             CALL    LOAD_PNTR       ;Load address of point for insertion.
0786 C249           2156             CLR     CHAR_FLG
0788 91E2           2157     OPEN_3: CALL    READ_CHAR       ;Test first label byte of following line.
078A 20E709         2158             JB      ACC.7,OPEN_4
078D 91E2           2159             CALL    READ_CHAR       ;Pass over next LABEL byte.
078F 91E2           2160     OPEN_5: CALL    READ_CHAR
0791 B40DFB         2161             CJNE    A,#CR,OPEN_5
0794 80F2           2162             SJMP    OPEN_3
                    2163     ;
                    2164     ;       Pointer now indicates end-of-buffer sentinel.
                    2165     ;
0796 E50F           2166     OPEN_4: MOV     A,STRLEN        ;Number of bytes needed for BASIC text.
0798 2403           2167             ADD     A,#3            ;Space needed for for label and <CR>.
079A 28             2168             ADD     A,R0            ;Low-order byte of old pointer.
079B F9             2169             MOV     DEST_L,A
079C E4             2170             CLR     A
079D 3A             2171             ADDC    A,PNTR_H
079E FB             2172             MOV     DEST_H,A
079F B43002         2173             CJNE    A,#HIGH RAMLIM,OPEN_1
07A2 2109           2174             JMP     AES_ER
                    2175     ;
                    2176     ;       Transfer characters from source back to destination
                    2177     ;       until pointer at original CURSOR value.
                    2178     ;
07A4 91CA           2179     OPEN_1: CALL    GET_BUF         ;Move back next character.
07A6 91F0           2180             CALL    PUT_BUF
07A8 E8             2181             MOV     A,PNTR_L
07A9 B55105         2182             CJNE    A,CURS_L,OPEN_2
07AC EA             2183             MOV     A,PNTR_H
07AD B55201         2184             CJNE    A,CURS_H,OPEN_2
                    2185     ;
                    2186     ;       All bytes have been moved back.
                    2187     ;
07B0 22             2188             RET
                    2189     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   49


LOC  OBJ            LINE     SOURCE

                    2190     OPEN_2:
                    2191     ;       Decrement src. and dest. pointers and repeat.
                    2192     ;
07B1 18             2193             DEC     PNTR_L
07B2 B8FF01         2194             CJNE    PNTR_L,#0FFH,OPEN_6
07B5 1A             2195             DEC     PNTR_H
07B6 19             2196     OPEN_6: DEC     DEST_L
07B7 B9FFEA         2197             CJNE    DEST_L,#0FFH,OPEN_1
07BA 1B             2198             DEC     DEST_H
07BB 80E7           2199             SJMP    OPEN_1          ;Repeat for next character.
                    2200     ;
                    2201     ;=======
                    2202     ;
                    2203     INSR_L:
                    2204     ;       Insert program line label (still held in <TOS_H><TOS_L> from earlier
                    2205     ;       call to FNDLBL)
                    2206     ;       and character string in line buffer (pointed at by L_CURS)
                    2207     ;       into program buffer gap created by OPEN_L routine
                    2208     ;       (still pointed at by CURSOR).
                    2209     ;
07BD A951           2210             MOV     DEST_L,CURS_L
07BF AB52           2211             MOV     DEST_H,CURS_H
07C1 EF             2212             MOV     A,TOS_H
07C2 91F9           2213             CALL    WRITE_CHAR
07C4 EE             2214             MOV     A,TOS_L
07C5 91F9           2215             CALL    WRITE_CHAR
07C7 A84F           2216             MOV     PNTR_L,L_CURS
07C9 E6             2217     INSL_1: MOV     A,@PNTR_L
07CA 91F9           2218             CALL    WRITE_CHAR
07CC 08             2219             INC     PNTR_L
07CD B40DF9         2220             CJNE    A,#CR,INSL_1
07D0 22             2221             RET
                    2222     ;
                    2223     ;=======
                    2224     ;
                    2225     %*DEFINE(INSRT)
                                    (CALL    INSRT)
                    2226     ;
                    2227     INSRT:
                    2228     ;       Pop line number from top of arithmetic expression stack.
                    2229     ;       Search BASIC source program for corresponding line number.
                    2230     ;       If found, delete old line.
                    2231     ;       Otherwise position cursor before next sequential line number.
                    2232     ;       If line buffer is not empty then insert line number, contents of
                    2233     ;       line buffer, and line terminator.
                    2234     ;
07D1 18             2235             DEC     PNTR_L          ;Since previous D_BLNK passed over first char.
07D2 884F           2236             MOV     L_CURS,PNTR_L
07D4 F149           2237             CALL    FNDLBL
07D6 4002           2238             JC      INSR_1
07D8 F169           2239             CALL    KILL_L          ;Delete line iff label found in buffer.
07DA A94F           2240     INSR_1: MOV     R1,L_CURS
07DC 19             2241             DEC     R1
07DD 09             2242     INSR_2: INC     R1
07DE E7             2243             MOV     A,@R1
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   50


LOC  OBJ            LINE     SOURCE

07DF B40DFB         2244             CJNE    A,#CR,INSR_2
07E2 E9             2245             MOV     A,R1
07E3 C3             2246             CLR     C
07E4 954F           2247             SUBB    A,L_CURS
07E6 F50F           2248             MOV     STRLEN,A
07E8 6004           2249             JZ      INSR_4
07EA F184           2250             CALL    OPEN_L
07EC F1BD           2251             CALL    INSR_L
07EE C243           2252     INSR_4: CLR     RUNMOD
07F0 22             2253             RET
                    2254     ;
                    2255     ;===============
                    2256     ;
                    2257     %*DEFINE(COND(LBL))
                                     (CALL   COND
                                       JNC   %LBL)
                    2258     ;
07F1 311F           2259     COND:   CALL    POP_TOS
07F3 EE             2260             MOV     A,TOS_L
07F4 13             2261             RRC     A
07F5 22             2262             RET
                    2263     ;
                    2264     ;=======
                    2265     ;
                    2266     ;XFER
                    2267     ;       Pop the value from the top of the arithmetic expression stack (AES).
                    2268     ;       Position cursor at beginning of the BASIC source program line
                    2269     ;       with that label and begin source interpretation.
                    2270     ;       (Report error if corresponding source line not found.)
                    2271     ;
                    2272     %*DEFINE(XFER)
                                    (JMP     XFER)
                    2273     ;
07F6 F149           2274     XFER:   CALL    FNDLBL
07F8 4003           2275             JC      XFERNG
07FA 020883         2276             JMP     STMT            ;Begin execution of source line.
                    2277     ;
07FD 2100           2278     XFERNG: JMP     EXP_ER
                    2279     ;
                    2280     ;===============
                    2281     ;
                    2282     %*DEFINE(SAV)
                                    (CALL    SAV)
                    2283     ;
                    2284     SAV:
                    2285     ;       Push BASIC line number of current source line onto AES.
                    2286     ;
07FF AF55           2287             MOV     TOS_H,LABL_H
0801 AE54           2288             MOV     TOS_L,LABL_L
0803 020137         2289             JMP     PUSH_TOS
                    2290     ;
                    2291     ;===============
                    2292     %*DEFINE(RSTR)
                                    (JMP     RSTR)
                    2293     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   51


LOC  OBJ            LINE     SOURCE

                    2294     ;
                    2295     RSTR:
                    2296     ;       If AES is empty report a nesting error.
                    2297     ;       Otherwise, pop AES into current BASIC souce program line number.
                    2298     ;
0806 120749         2299             CALL    FNDLBL
0809 12050B         2300             CALL    SKPLIN          ;Pass over statement initiating transfer.
080C 020883         2301             JMP     STMT
                    2302     ;
                    2303     ;===============
                    2304     ;
                    2305     %*DEFINE(NEXT_LOOP(LBL))
                                     (CALL   LOOP
                                       JC      %LBL)
                    2306     ;
                    2307     LOOP:
                    2308     ;       LOOP is called with the AES holding:
                    2309     ;       (TOS:)  2 byte VALUE of variable after being incremented,
                    2310     ;               2 byte INDEX of variable being incremented,
                    2311     ;               1 byte TYPE of variable code,
                    2312     ;               2 byte LABEL of line initiating FOR loop,
                    2313     ;               2 byte LIMIT specified by FOR statement,
                    2314     ;               2 byte INDEX of variable used by FOR loop,
                    2315     ;               1 byte TYPE of variable code.
                    2316     ;       If indices disagree, then generate syntax error.
                    2317     ;       Otherwise, store incremented value in variable popping both from AES.
                    2318     ;       If the incremented value <= LIMIT then return with carry set.
                    2319     ;       If incr. val. > LIMIT looping is done, so return with carry not set.
                    2320     ;
                    2321     ;       Compare all three bytes of variable index.
080F E8             2322             MOV     A,R0
0810 C0E0           2323             PUSH    ACC
0812 E52A           2324             MOV     A,AESP
0814 24FE           2325             ADD     A,#-2
0816 F9             2326             MOV     R1,A
0817 24F9           2327             ADD     A,#-7
0819 F8             2328             MOV     R0,A
081A 7D03           2329             MOV     LP_CNT,#3       ;Set to test three bytes.
081C E7             2330     LOOP_0: MOV     A,@R1
081D 66             2331             XRL     A,@R0
081E 7020           2332             JNZ     LOOP_1
0820 18             2333             DEC     R0
0821 19             2334             DEC     R1
0822 DDF8           2335             DJNZ    LP_CNT,LOOP_0
                    2336     ;
                    2337     ;       All three bytes of variable code match.
0824 D0E0           2338             POP     ACC
0826 F8             2339             MOV     R0,A
0827 120223         2340             CALL    STORE
082A E52A           2341             MOV     A,AESP
082C 24FD           2342             ADD     A,#-3
082E F9             2343             MOV     R1,A
082F C3             2344             CLR     C
0830 E7             2345             MOV     A,@R1
0831 9508           2346             SUBB    A,TMP0
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   52


LOC  OBJ            LINE     SOURCE

0833 09             2347             INC     R1
0834 E7             2348             MOV     A,@R1
0835 204405         2349             JB      HEXMOD,LOOP_2   ;Branch forward if unsigned compare correct.
0838 6480           2350             XRL     A,#80H          ;Adjust sign bits so signed compare valid.
083A 630980         2351             XRL     TMP1,#80H
083D 9509           2352     LOOP_2: SUBB    A,TMP1
083F 22             2353             RET
                    2354     ;
                    2355     ;       Indices don't match.
                    2356     ;
0840 D0E0           2357     LOOP_1: POP     ACC
0842 F8             2358             MOV     R0,A
0843 020114         2359             JMP     SYN_ER
                    2360     ;
                    2361     ;=======
                    2362     ;
                    2363     ;FIN
                    2364     ;       Return to line collection routine.
                    2365     ;
                    2366     %*DEFINE(FIN)
                                    (JMP     FIN)
                    2367     ;
0846 C243           2368     FIN:    CLR     RUNMOD
0848 02086A         2369             JMP     CONT            ;Return to line collection mode.
                    2370     ;
                    2371     ;===============
                    2372     ;
                    2373     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   53


LOC  OBJ            LINE     SOURCE

                    2374     ;
                    2375     ;       IL SEQUENCE CONTROL INSTRUCTIONS:
                    2376     ;       == ======== ======= ============
                    2377     ;
                    2378     ;IJMP   (LBL)
                    2379     ;       Jump to the (potentially distant) IL instruction at location LBL.
                    2380     ;Note:  In this implementation IL addresses are equivalent to machine
                    2381     ;       language addresses, so IJMP performs a generic JMP.
                    2382     ;
                    2383     %*DEFINE(IJMP(LBL))
                                    (JMP     %LBL)
                    2384     ;
                    2385     ;===============
                    2386     ;
                    2387     ;HOP    (LBL)
                    2388     ;       Perform a branch to the IL instruction at (nearby) location LBL.
                    2389     ;Note:  In this implementation IL addresses are equivalent to machine
                    2390     ;       language addresses, so HOP performs a simple relative SJMP.
                    2391     ;
                    2392     %*DEFINE(HOP(LBL))
                                    (SJMP    %LBL)
                    2393     ;
                    2394     ;===============
                    2395     ;
                    2396     ;ICALL  (LBL)
                    2397     ;       Call the IL subroutine starting at instruction LBL.
                    2398     ;       Save the location of the next IL instruction on the control stack.
                    2399     ;Note:  In this implementation, IL addresses are identical with 
                    2400     ;       machine language addresses, and are saved on the MCS-51 hardware stack.
                    2401     ;
                    2402     %*DEFINE(ICALL(LBL))
                                    (CALL    %LBL)
                    2403     ;
                    2404     ;===============
                    2405     ;
                    2406     ;IRET
                    2407     ;       Return from IL subroutine to location on top of control stack.
                    2408     ;Note:  In this implementation, IL addresses are identical with machine 
                    2409     ;       language addresses, which are saved on the hardware stack.
                    2410     ;
                    2411     %*DEFINE(IRET)
                                    (RET)
                    2412     ;
                    2413     ;===============
                    2414     ;
                    2415     ;MLCALL
                    2416     ;       Call the ML subroutine starting at the address on top of AES.
                    2417     ;
                    2418     %*DEFINE(MLCALL)
                                    (CALL    MLCALL
                                       ANL     PSW,#11100111B)
                    2419     ;
084B A92A           2420     MLCALL: MOV     R1,AESP
084D 87F0           2421             MOV     B,@R1
084F 19             2422             DEC     R1
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   54


LOC  OBJ            LINE     SOURCE

0850 E7             2423             MOV     A,@R1
0851 19             2424             DEC     R1
0852 892A           2425             MOV     AESP,R1
0854 C0E0           2426             PUSH    ACC
0856 C0F0           2427             PUSH    B
0858 43D018         2428             ORL     PSW,#00011000B  ;Select RB3.
085B 22             2429             RET                     ;Branch to user routine.
                    2430     ;
                    2431     ;=======
                    2432     $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   55


LOC  OBJ            LINE     SOURCE

                    2433     $RESTORE
                    2434     ;
                    2435     ;       STATEMENT EXECUTOR WRITTEN IN IL (INTERPRETIVE LANGUAGE)
                    2436     ;       OPERATIONS IMPLEMENTED BY ASM51 MPL MACRO PROCESSING LANGUAGE
                    2437     ;                       (8/11/80)
                    2438     ;
085C 020114         2439     CMD_NG: JMP     SYN_ER
                    2440     ;
085F 120739         2441 +1  START:  CALL    INIT
0862 C243           2442     ERRENT: CLR     RUNMOD
0864 758155         2443             MOV     SP,#SP_BASE     ;Re-initialize hardware stack.
0867 752A2A         2444             MOV     AESP,#AES-1     ;Initialize AES pointer.
086A 1200EB         2445     CONT:   CALL    STROUT
086D 4F4B           2446             DB      'OK',CR OR 80H
086F 8D
0870 12061C         2447 +1  CONT_1: CALL    GETLN           ;Receive interactive command line.
0873 120501         2448             CALL    D_BLNK
0876 1205AA         2449 +1          CALL    TSTN
0879 500D           2450 +2            JNC     TOKEN
087B 1207D1         2451 +1          CALL    INSRT
087E 80F0           2452 +2          SJMP    CONT_1
                    2453     ;
                    2454     ;=======
                    2455     ;
0880 120741         2456 +1  XEC:    CALL    XINIT           ;Initialize for sequential execution.
0883 120608         2457 +1  STMT:   CALL    L_INIT
0886 40DA           2458 +1            JC      ERRENT                ;Initialize for line execution.
0888 1200B7         2459 +1  TOKEN:  CALL    CNTRL
088B 120501         2460             CALL    D_BLNK
088E 120545         2461 +1          CALL    TSTV
0891 5008           2462 +2            JNC     S0            ;Parse implied LET command.
0893 120515         2463 +1          CALL    TST
0896 BD             2464 +2            DB      '=' OR 80H
0897 502F           2465 +2            JNC     SE4
0899 8013           2466 +2          SJMP    SE3
                    2467     ;
089B 120515         2468 +1  S0:     CALL    TST
089E 4C45           2469 +3            DB      'LE','T' OR 80H
08A0 D4
08A1 5031           2470 +2            JNC     S1            ;Parse explicit LET command.
08A3 120545         2471 +1          CALL    TSTV
08A6 50B4           2472 +2            JNC     CMD_NG
08A8 120515         2473 +1          CALL    TST
08AB BD             2474 +2            DB      '=' OR 80H
08AC 50AE           2475 +2            JNC     CMD_NG
08AE 120AE0         2476 +2  SE3:    CALL    EXPR
08B1 120515         2477 +1          CALL    TST
08B4 AC             2478 +2            DB      ',' OR 80H
08B5 5008           2479 +2            JNC     SE3A
08B7 12021F         2480 +1          CALL    SEQ_STORE
08BA 120399         2481 +1          CALL    IINC
08BD 80EF           2482 +2          SJMP    SE3
                    2483     ;
08BF 1205DD         2484 +1  SE3A:   CALL    DONE
08C2 120223         2485 +1          CALL    STORE
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   56


LOC  OBJ            LINE     SOURCE

08C5 020611         2486 +1          JMP     NXT
                    2487     ;
08C8 1205DD         2488 +1  SE4:    CALL    DONE            ;Process implied PRINT command.
08CB 120287         2489 +1          CALL    FETCH
08CE 12066F         2490 +1          CALL    PRN
08D1 02060F         2491 +1          JMP     NL_NXT
                    2492     ;
                    2493     ;=======
                    2494     ;
08D4 120515         2495 +1  S1:     CALL    TST
08D7 474F54         2496 +3            DB      'GOT','O' OR 80H
08DA CF
08DB 5009           2497 +2            JNC     S2            ;Parse GOTO command.
08DD 120AE0         2498 +2          CALL    EXPR
08E0 1205E3         2499 +1          CALL    LNDONE
08E3 0207F6         2500 +1          JMP     XFER
                    2501     ;
                    2502     ;=======
                    2503     ;
08E6 120515         2504 +1  S2:     CALL    TST
08E9 474F5355       2505 +3            DB      'GOSU','B' OR 80H
08ED C2
08EE 500C           2506 +2            JNC     S3            ;Parse GOSUB command.
08F0 1207FF         2507 +1          CALL    SAV
08F3 120AE0         2508 +2          CALL    EXPR
08F6 1205E3         2509 +1          CALL    LNDONE
08F9 0207F6         2510 +1          JMP     XFER
                    2511     ;
                    2512     ;=======
                    2513     ;
08FC 120515         2514 +1  S3:     CALL    TST
08FF 5052494E       2515 +3            DB      'PRIN','T' OR 80H
0903 D4
0904 5044           2516 +2            JNC     S8            ;Parse PRINT command.
0906 1205ED         2517 +1          CALL    IFDONE
0909 5039           2518 +2            JNC     S6B
090B 120515         2519 +1  S3A:    CALL    TST
090E BB             2520 +2            DB      ';' OR 80H
090F 5002           2521 +2            JNC     S3B
0911 80F8           2522 +2          SJMP    S3A
                    2523     ;
0913 120515         2524 +1  S3B:    CALL    TST
0916 AC             2525 +2            DB      ',' OR 80H
0917 5005           2526 +2            JNC     S3C
0919 1200C5         2527 +1          CALL    SPC
091C 80ED           2528 +2          SJMP    S3A
                    2529     ;
091E 1205ED         2530 +1  S3C:    CALL    IFDONE
0921 5024           2531 +2            JNC     S6A
0923 1205BF         2532 +1          CALL    TSTS
0926 4006           2533 +2            JC      S5
0928 120AE0         2534 +2          CALL    EXPR
092B 12066F         2535 +1          CALL    PRN
092E 120515         2536 +1  S5:     CALL    TST
0931 AC             2537 +2            DB      ',' OR 80H
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   57


LOC  OBJ            LINE     SOURCE

0932 5005           2538 +2            JNC     S5A
0934 1200C5         2539 +1          CALL    SPC
0937 80D2           2540 +2          SJMP    S3A
                    2541     ;
0939 120515         2542 +1  S5A:    CALL    TST
093C BB             2543 +2            DB      ';' OR 80H
093D 5002           2544 +2            JNC     S6
093F 80CA           2545 +2          SJMP    S3A
                    2546     ;
0941 1205DD         2547 +1  S6:     CALL    DONE
0944 02060F         2548 +1  S6B:    JMP     NL_NXT
                    2549     ;
0947 020611         2550 +1  S6A:    JMP     NXT
                    2551     ;
                    2552     ;=======
                    2553     ;
094A 120515         2554 +1  S8:     CALL    TST
094D 49             2555 +3            DB      'I','F' OR 80H
094E C6
094F 5018           2556 +2            JNC     S9            ;Parse IF command.
0951 120AE0         2557 +2          CALL    EXPR
0954 120515         2558 +1          CALL    TST
0957 544845         2559 +3            DB      'THE','N' OR 80H
095A CE
095B 5000           2560 +2            JNC     S8A
095D 1207F1         2561 +1  S8A:    CALL    COND
0960 5002           2562 +2            JNC   S8B
0962 0188           2563 +2          JMP     TOKEN           ;Continue parsing command.
                    2564     ;
0964 12050F         2565 +1  S8B:    CALL    SKPTXT
0967 0183           2566 +2          JMP     STMT
                    2567     ;
                    2568     ;=======
                    2569     ;
0969 120515         2570 +1  S9:     CALL    TST
096C 494E5055       2571 +3            DB      'INPU','T' OR 80H
0970 D4
0971 502C           2572 +2            JNC     S12           ;Parse INPUT command.
0973 1205BF         2573 +1  S10:    CALL    TSTS
0976 400B           2574 +2            JC      S10B
0978 120545         2575 +1          CALL    TSTV
097B 5019           2576 +2            JNC     S10D
097D 1206E0         2577 +1          CALL    INNUM
0980 120223         2578 +1          CALL    STORE
0983 120515         2579 +1  S10B:   CALL    TST
0986 BB             2580 +2            DB      ';' OR 80H
0987 5002           2581 +2            JNC     S10C
0989 80E8           2582 +2          SJMP    S10
                    2583     ;
098B 120515         2584 +1  S10C:   CALL    TST
098E AC             2585 +2            DB      ',' OR 80H
098F 5008           2586 +2            JNC     S11
0991 1200C5         2587 +1          CALL    SPC
0994 80DD           2588 +2          SJMP    S10
                    2589     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   58


LOC  OBJ            LINE     SOURCE

0996 020BD0         2590 +2  S10D:   JMP     SYN_NG
                    2591     ;
0999 1205DD         2592 +1  S11:    CALL    DONE
099C 02060F         2593 +1          JMP     NL_NXT
                    2594     ;
                    2595     ;=======
                    2596     ;
099F 120515         2597 +1  S12:    CALL    TST
09A2 52455455       2598 +3            DB      'RETUR','N' OR 80H
09A6 52
09A7 CE
09A8 5005           2599 +2            JNC     S13           ;Parse RETURN command.
09AA 1205E3         2600 +1          CALL    LNDONE
09AD 0106           2601 +1          JMP     RSTR
                    2602     ;
                    2603     ;=======
                    2604     ;
09AF 120515         2605 +1  S13:    CALL    TST
09B2 43414C         2606 +3            DB      'CAL','L' OR 80H
09B5 CC
09B6 500E           2607 +2            JNC     S13A          ;Machine language CALL.
09B8 120AE0         2608 +2          CALL    EXPR
09BB 1205E3         2609 +1          CALL    LNDONE
09BE 114B           2610 +1          CALL    MLCALL
09C0 53D0E7         2611 +1            ANL     PSW,#11100111B
09C3 020611         2612 +1          JMP     NXT
                    2613     ;
                    2614     ;=======
                    2615     ;
09C6 120515         2616 +1  S13A:   CALL    TST
09C9 464F           2617 +3            DB      'FO','R' OR 80H
09CB D2
09CC 5024           2618 +2            JNC     S13B
09CE 120545         2619 +1          CALL    TSTV
09D1 504E           2620 +2            JNC     FOR_ER
09D3 120515         2621 +1          CALL    TST
09D6 BD             2622 +2            DB      '=' OR 80H
09D7 5048           2623 +2            JNC     FOR_ER
09D9 120AE0         2624 +2          CALL    EXPR
09DC 12021F         2625 +1          CALL    SEQ_STORE
09DF 120515         2626 +1          CALL    TST
09E2 54             2627 +3            DB      'T','O' OR 80H
09E3 CF
09E4 503B           2628 +2            JNC     FOR_ER
09E6 120AE0         2629 +2          CALL    EXPR
09E9 1205E3         2630 +1          CALL    LNDONE
09EC 1207FF         2631 +1          CALL    SAV
09EF 020611         2632 +1          JMP     NXT
                    2633     ;
                    2634     ;=======
                    2635     ;
09F2 120515         2636 +1  S13B:   CALL    TST
09F5 4E4558         2637 +3            DB      'NEX','T' OR 80H
09F8 D4
09F9 5028           2638 +2            JNC     S13C
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   59


LOC  OBJ            LINE     SOURCE

09FB 120545         2639 +1          CALL    TSTV
09FE 5021           2640 +2            JNC     FOR_ER
0A00 1205DD         2641 +1          CALL    DONE
0A03 120283         2642             CALL    SEQ_FETCH
0A06 120399         2643 +1          CALL    IINC
0A09 110F           2644 +1          CALL    LOOP
0A0B 4005           2645 +2            JC      FORDON
0A0D 12014A         2646 +1          CALL    DUPL
0A10 0106           2647 +1          JMP     RSTR
                    2648     ;
0A12 12011F         2649     FORDON: CALL    POP_TOS
0A15 12011F         2650             CALL    POP_TOS
0A18 12011F         2651             CALL    POP_TOS
0A1B 120131         2652             CALL    POP_ACC
0A1E 020611         2653 +1          JMP     NXT
                    2654     ;
                    2655     ;=======
                    2656     ;
0A21 015C           2657 +2  FOR_ER: JMP     CMD_NG
                    2658     ;
                    2659     ;=======
                    2660     ;
0A23 120515         2661 +1  S13C:   CALL    TST
0A26 454E           2662 +3            DB      'EN','D' OR 80H
0A28 C4
0A29 5005           2663 +2            JNC     S14           ;Parse END command.
0A2B 1205E3         2664 +1          CALL    LNDONE
0A2E 0146           2665 +1          JMP     FIN
                    2666     ;
                    2667     ;=======
                    2668     ;
0A30 120515         2669 +1  S14:    CALL    TST
0A33 4C4953         2670 +3            DB      'LIS','T' OR 80H
0A36 D4
0A37 5015           2671 +2            JNC     S15           ;Parse LIST command.
0A39 1205ED         2672 +1          CALL    IFDONE
0A3C 500B           2673 +2            JNC     S14B
0A3E 120AE0         2674 +2          CALL    EXPR
0A41 120749         2675             CALL    FNDLBL
0A44 1206D5         2676             CALL    LST_1
0A47 016A           2677 +2          JMP     CONT
                    2678     ;
0A49 1206D1         2679 +1  S14B:   CALL    LST
0A4C 016A           2680 +2          JMP     CONT
                    2681     ;
                    2682     ;=======
                    2683     ;
0A4E 120515         2684 +1  S15:    CALL    TST
0A51 5255           2685 +3            DB      'RU','N' OR 80H
0A53 CE
0A54 5005           2686 +2            JNC     S16           ;Parse LIST command.
0A56 1205E3         2687 +1          CALL    LNDONE
0A59 0180           2688 +2          JMP     XEC
                    2689     ;
                    2690     ;=======
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   60


LOC  OBJ            LINE     SOURCE

                    2691     ;
0A5B 120515         2692 +1  S16:    CALL    TST
0A5E 4E45           2693 +3            DB      'NE','W' OR 80H
0A60 D7
0A61 5005           2694 +2            JNC     S16A
0A63 1205DD         2695 +1          CALL    DONE
0A66 015F           2696 +2          JMP     START
                    2697     ;
                    2698     ;=======
0A68 120515         2699 +1  S16A:   CALL    TST
0A6B 52455345       2700 +3            DB      'RESE','T' OR 80H
0A6F D4
0A70 5006           2701 +2            JNC     S17
0A72 1205DD         2702 +1          CALL    DONE
0A75 020000         2703             JMP     0000H
                    2704     ;
                    2705     ;=======
                    2706     ;
0A78 120515         2707 +1  S17:    CALL    TST
0A7B 524F           2708 +3            DB      'RO','M' OR 80H
0A7D CD
0A7E 500A           2709 +2            JNC     S17A
0A80 1205DD         2710 +1          CALL    DONE
0A83 D241           2711             SETB    ROMMOD
0A85 C242           2712             CLR     EXTMOD
0A87 020611         2713 +1          JMP     NXT
                    2714     ;
0A8A 120515         2715 +1  S17A:   CALL    TST
0A8D 5241           2716 +3            DB      'RA','M' OR 80H
0A8F CD
0A90 5008           2717 +2            JNC     S17B
0A92 1205DD         2718 +1          CALL    DONE
0A95 C241           2719             CLR     ROMMOD
0A97 020611         2720 +1          JMP     NXT
                    2721     ;
0A9A 120515         2722 +1  S17B:   CALL    TST
0A9D 50524F         2723 +3            DB      'PRO','M' OR 80H
0AA0 CD
0AA1 500A           2724 +2            JNC     S17C
0AA3 1205DD         2725 +1          CALL    DONE
0AA6 D241           2726             SETB    ROMMOD
0AA8 D242           2727             SETB    EXTMOD
0AAA 020611         2728 +1          JMP     NXT
                    2729     ;
0AAD 120515         2730 +1  S17C:   CALL    TST
0AB0 4845           2731 +3            DB      'HE','X' OR 80H
0AB2 D8
0AB3 5008           2732 +2            JNC     S18
0AB5 1205DD         2733 +1          CALL    DONE
0AB8 D244           2734             SETB    HEXMOD
0ABA 020611         2735 +1          JMP     NXT
                    2736     ;
0ABD 120515         2737 +1  S18:    CALL    TST
0AC0 44454349       2738 +3            DB      'DECIMA','L' OR 80H
0AC4 4D41
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   61


LOC  OBJ            LINE     SOURCE

0AC6 CC
0AC7 5008           2739 +2            JNC     S19
0AC9 1205DD         2740 +1          CALL    DONE
0ACC C244           2741             CLR     HEXMOD
0ACE 020611         2742 +1          JMP     NXT
                    2743     ;
0AD1 120515         2744 +1  S19:    CALL    TST
0AD4 5245           2745 +3            DB      'RE','M' OR 80H
0AD6 CD
0AD7 5005           2746 +2            JNC     S20
0AD9 12050F         2747 +1          CALL    SKPTXT
0ADC 0183           2748 +2          JMP     STMT
                    2749     ;
0ADE 015C           2750 +2  S20:    JMP     CMD_NG
                    2751     ;
                    2752 +1  $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   62


LOC  OBJ            LINE     SOURCE

                    2753     ;
                    2754     ;       INTERPRETIVE LANGUAGE SUBROUTINES:
                    2755     ;       ============ ======== ===========
                    2756     ;
0AE0 120AF0         2757 +2  EXPR:   CALL    AR_EXP
0AE3 120BD2         2758 +2  E0:     CALL    RELOP
0AE6 5046           2759             JNC     E5
0AE8 120AF0         2760 +2          CALL    AR_EXP
0AEB 120473         2761 +1          CALL    CMPR
0AEE 80F3           2762 +2          SJMP    E0
                    2763     ;
0AF0 120B2F         2764 +2  AR_EXP: CALL    TERM
0AF3 120515         2765 +1  E1:     CALL    TST
0AF6 AB             2766 +2            DB      '+' OR 80H
0AF7 5008           2767 +2            JNC     E2
0AF9 120B2F         2768 +2          CALL    TERM
0AFC 120349         2769 +1          CALL    IADD
0AFF 80F2           2770 +2          SJMP    E1
                    2771     ;
0B01 120515         2772 +1  E2:     CALL    TST
0B04 AD             2773 +2            DB      '-' OR 80H
0B05 5008           2774 +2            JNC     E3
0B07 120B2F         2775 +2          CALL    TERM
0B0A 12034F         2776 +1          CALL    ISUB
0B0D 80E4           2777 +2          SJMP    E1
                    2778     ;
0B0F 120515         2779 +1  E3:     CALL    TST
0B12 4F             2780 +3            DB      'O','R' OR 80H
0B13 D2
0B14 5008           2781 +2            JNC     E4
0B16 120B2F         2782 +2          CALL    TERM
0B19 120365         2783 +1          CALL    IOR
0B1C 80D5           2784 +2          SJMP    E1
                    2785     ;
0B1E 120515         2786 +1  E4:     CALL    TST
0B21 584F           2787 +3            DB      'XO','R' OR 80H
0B23 D2
0B24 5008           2788 +2            JNC     E5
0B26 120B2F         2789 +2          CALL    TERM
0B29 12036F         2790 +1          CALL    IXOR
0B2C 80C5           2791 +2          SJMP    E1
                    2792     ;
0B2E 22             2793 +1  E5:     RET
                    2794     ;
                    2795     ;=======
                    2796     ;
0B2F 120B6F         2797 +2  TERM:   CALL    FACT
0B32 120515         2798 +1  TERM_0: CALL    TST
0B35 AA             2799 +2            DB      '*' OR 80H
0B36 5008           2800 +2            JNC     TERM_1
0B38 120B6F         2801 +2          CALL    FACT
0B3B 1203DB         2802 +1          CALL    IMUL
0B3E 80F2           2803 +2          SJMP    TERM_0
                    2804     ;
0B40 120515         2805 +1  TERM_1: CALL    TST
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   63


LOC  OBJ            LINE     SOURCE

0B43 AF             2806 +2            DB      '/' OR 80H
0B44 5008           2807 +2            JNC     TERM_2
0B46 120B6F         2808 +2          CALL    FACT
0B49 1203EE         2809 +1          CALL    IDIV
0B4C 80E4           2810 +2          SJMP    TERM_0
                    2811     ;
0B4E 120515         2812 +1  TERM_2: CALL    TST
0B51 414E           2813 +3            DB      'AN','D' OR 80H
0B53 C4
0B54 5008           2814 +2            JNC     TERM_3
0B56 120B6F         2815 +2          CALL    FACT
0B59 12035B         2816 +1          CALL    IAND
0B5C 80D4           2817 +2          SJMP    TERM_0
                    2818     ;
0B5E 120515         2819 +1  TERM_3: CALL    TST
0B61 4D4F           2820 +3            DB      'MO','D' OR 80H
0B63 C4
0B64 5008           2821 +2            JNC     TERM_4
0B66 120B6F         2822 +2          CALL    FACT
0B69 1203EA         2823 +1          CALL    IMOD
0B6C 80C4           2824 +2          SJMP    TERM_0
                    2825     ;
0B6E 22             2826 +1  TERM_4: RET
                    2827     ;
                    2828     ;=======
                    2829     ;
0B6F 120515         2830 +1  FACT:   CALL    TST
0B72 AD             2831 +2            DB      '-' OR 80H
0B73 5007           2832 +2            JNC     FACT_1
0B75 120B8B         2833 +2          CALL    VAR
0B78 120379         2834 +1          CALL    NEG
0B7B 22             2835 +1          RET
                    2836     ;
0B7C 120515         2837 +1  FACT_1: CALL    TST
0B7F 4E4F           2838 +3            DB      'NO','T' OR 80H
0B81 D4
0B82 5007           2839 +2            JNC     VAR
0B84 120B8B         2840 +2          CALL    VAR
0B87 120388         2841 +1          CALL    ICPL
0B8A 22             2842 +1          RET
                    2843     ;
                    2844     ;
                    2845     ;=======
                    2846     ;
0B8B 120545         2847 +1  VAR:    CALL    TSTV
0B8E 5004           2848 +2            JNC     VAR_0
0B90 120287         2849 +1          CALL    FETCH
0B93 22             2850 +1          RET
                    2851     ;
0B94 1205AA         2852 +1  VAR_0:  CALL    TSTN
0B97 5001           2853 +2            JNC     VAR_1
0B99 22             2854 +1          RET
                    2855     ;
0B9A 120515         2856 +1  VAR_1:  CALL    TST
0B9D 524E           2857 +3            DB      'RN','D' OR 80H
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   64


LOC  OBJ            LINE     SOURCE

0B9F C4
0BA0 5010           2858 +2            JNC     VAR_1A
0BA2 12044B         2859 +1          CALL    RND
0BA5 120BC1         2860 +2          CALL    VAR_2
0BA8 1203EA         2861 +1          CALL    IMOD
0BAB 12038B         2862 +1          CALL    IABS
0BAE 120399         2863 +1          CALL    IINC
0BB1 22             2864 +1          RET
                    2865     ;
0BB2 120515         2866 +1  VAR_1A: CALL    TST
0BB5 4142           2867 +3            DB      'AB','S' OR 80H
0BB7 D3
0BB8 5007           2868 +2            JNC     VAR_2
0BBA 120BC1         2869 +2          CALL    VAR_2
0BBD 12038B         2870 +1          CALL    IABS
0BC0 22             2871 +1          RET
                    2872     ;
0BC1 120515         2873 +1  VAR_2:  CALL    TST
0BC4 A8             2874 +2            DB      '(' OR 80H
0BC5 5009           2875 +2            JNC     SYN_NG
0BC7 51E0           2876 +2          CALL    EXPR
0BC9 120515         2877 +1          CALL    TST
0BCC A9             2878 +2            DB      ')' OR 80H
0BCD 5001           2879 +2            JNC     SYN_NG
0BCF 22             2880 +1          RET
                    2881     ;
                    2882     ;=======
                    2883     ;
0BD0 015C           2884 +2  SYN_NG: JMP     CMD_NG
                    2885     ;
                    2886 +1  $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   65


LOC  OBJ            LINE     SOURCE

                    2887     ;
                    2888     RELOP:
                    2889     ;       Search for relational operator in text string.
                    2890     ;       If found, push appropriate operator code on AES and return with
                    2891     ;       carry set.
                    2892     ;       Otherwise restore cursor and return with carry=0.
                    2893     ;
0BD2 120515         2894 +1          CALL    TST
0BD5 BD             2895 +2            DB      '=' OR 80H
0BD6 5005           2896 +2            JNC     REL_1
0BD8 12015E         2897 +1          CALL    LIT
0BDB 02             2898 +2            DB      010B          ;Test for _=_
0BDC 22             2899 +1          RET
                    2900     ;
0BDD 120515         2901 +1  REL_1:  CALL    TST
0BE0 3C             2902 +3            DB      '<','=' OR 80H
0BE1 BD
0BE2 5005           2903 +2            JNC     REL_2
0BE4 12015E         2904 +1          CALL    LIT
0BE7 06             2905 +2            DB      110B          ;Test for <=_
0BE8 22             2906 +1          RET
                    2907     ;
0BE9 120515         2908 +1  REL_2:  CALL    TST
0BEC 3C             2909 +3            DB      '<','>' OR 80H
0BED BE
0BEE 5005           2910 +2            JNC     REL_3
0BF0 12015E         2911 +1          CALL    LIT
0BF3 05             2912 +2            DB      101B          ;Test for <_>
0BF4 22             2913 +1          RET
                    2914     ;
0BF5 120515         2915 +1  REL_3:  CALL    TST
0BF8 BC             2916 +2            DB      '<' OR 80H
0BF9 5005           2917 +2            JNC     REL_4
0BFB 12015E         2918 +1          CALL    LIT
0BFE 04             2919 +2            DB      100B          ;Test for <__
0BFF 22             2920 +1          RET
                    2921     ;
0C00 120515         2922 +1  REL_4:  CALL    TST
0C03 3E             2923 +3            DB      '>','=' OR 80H
0C04 BD
0C05 5005           2924 +2            JNC     REL_5
0C07 12015E         2925 +1          CALL    LIT
0C0A 03             2926 +2            DB      011B          ;Test for _=>
0C0B 22             2927 +1          RET
                    2928     ;
0C0C 120515         2929 +1  REL_5:  CALL    TST
0C0F BE             2930 +2            DB      '>' OR 80H
0C10 5005           2931 +2            JNC     REL_6
0C12 12015E         2932 +1          CALL    LIT
0C15 01             2933 +2            DB      001B          ;Test for __>
0C16 22             2934 +1          RET
                    2935     ;
0C17 C3             2936     REL_6:  CLR     C
0C18 22             2937 +1          RET
                    2938     ;
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   66


LOC  OBJ            LINE     SOURCE

                    2939     ;=======
                    2940     ;
                    2941 +1  $EJECT
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   67


LOC  OBJ            LINE     SOURCE

                    2942 +1  $LIST
                    2943     ;
0C19 0F             2944             INC     R7              ;Dummy ML program.
0C1A 8F90           2945             MOV     P1,R7
0C1C 22             2946             RET
                    2947     ;
                    2948     INTROM:                         ;Start of ROM program buffer.
                    2949 +1  $INCLUDE(TBACEY.SRC)
                =1  2950     
                =1  2951     ;
0C1D 0835       =1  2952 +2          DW      2101
0C1F 50522E22   =1  2953 +2          DB      'PR."HERE''S HOW YOU PLAY ACEY-DEUCEY:"',0DH
0C23 48455245
0C27 27532048
0C2B 4F572059
0C2F 4F552050
0C33 4C415920
0C37 41434559
0C3B 2D444555
0C3F 4345593A
0C43 22
0C44 0D
0C45 0836       =1  2954 +2          DW      2102
0C47 50522E22   =1  2955 +2          DB      'PR."I''LL DEAL TWO CARDS FACE UP."',0DH
0C4B 49274C4C
0C4F 20444541
0C53 4C205457
0C57 4F204341
0C5B 52445320
0C5F 46414345
0C63 2055502E
0C67 22
0C68 0D
0C69 0837       =1  2956 +2          DW      2103
0C6B 50522E22   =1  2957 +2          DB      'PR."YOU BET ON WHETHER THE NEXT CARD WILL HAVE"',0DH
0C6F 594F5520
0C73 42455420
0C77 4F4E2057
0C7B 48455448
0C7F 45522054
0C83 4845204E
0C87 45585420
0C8B 43415244
0C8F 2057494C
0C93 4C204841
0C97 564522
0C9A 0D
0C9B 0839       =1  2958 +2          DW      2105
0C9D 50522E22   =1  2959 +2          DB      'PR."A VALUE BETWEEN THE FIRST TWO."',0DH
0CA1 41205641
0CA5 4C554520
0CA9 42455457
0CAD 45454E20
0CB1 54484520
0CB5 46495253
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   68


LOC  OBJ            LINE     SOURCE

0CB9 54205457
0CBD 4F2E22
0CC0 0D
0CC1 083E       =1  2960 +2          DW      2110
0CC3 453D3130   =1  2961 +2          DB      'E=100',0DH
0CC7 30
0CC8 0D
0CC9 088E       =1  2962 +2          DW      2190
0CCB 50522E3A   =1  2963 +2          DB      'PR.:PR."YOU NOW HAVE ";E;" DOLLARS."',0DH
0CCF 50522E22
0CD3 594F5520
0CD7 4E4F5720
0CDB 48415645
0CDF 20223B45
0CE3 3B222044
0CE7 4F4C4C41
0CEB 52532E22
0CEF 0D
0CF0 08D4       =1  2964 +2          DW      2260
0CF2 50522E3A   =1  2965 +2          DB      'PR.:PR."HERE ARE YOUR NEXT TWO CARDS...":PR.:GOS.4000',0DH
0CF6 50522E22
0CFA 48455245
0CFE 20415245
0D02 20594F55
0D06 52204E45
0D0A 58542054
0D0E 574F2043
0D12 41524453
0D16 2E2E2E22
0D1A 3A50522E
0D1E 3A474F53
0D22 2E343030
0D26 30
0D27 0D
0D28 08E8       =1  2966 +2          DW      2280
0D2A 413D443A   =1  2967 +2          DB      'A=D:GOS.4000',0DH
0D2E 474F532E
0D32 34303030
0D36 0D
0D37 08F2       =1  2968 +2          DW      2290
0D39 423D443A   =1  2969 +2          DB      'B=D:IF A>B B=A:A=D',0DH
0D3D 49462041
0D41 3E422042
0D45 3D413A41
0D49 3D44
0D4B 0D
0D4C 08FC       =1  2970 +2          DW      2300
0D4E 49462042   =1  2971 +2          DB      'IF B-A<2 PR."MISDEAL":GO.2260',0DH
0D52 2D413C32
0D56 2050522E
0D5A 224D4953
0D5E 4445414C
0D62 223A474F
0D66 2E323236
0D6A 30
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   69


LOC  OBJ            LINE     SOURCE

0D6B 0D
0D6C 0906       =1  2972 +2          DW      2310
0D6E 49462042   =1  2973 +2          DB      'IF B-A=12 PR.:PR."ACEY-DEUCEY - GOOD ODDS!!"',0DH
0D72 2D413D31
0D76 32205052
0D7A 2E3A5052
0D7E 2E224143
0D82 45592D44
0D86 45554345
0D8A 59202D20
0D8E 474F4F44
0D92 204F4444
0D96 53212122
0D9A 0D
0D9B 0A5A       =1  2974 +2          DW      2650
0D9D 50522E3A   =1  2975 +2          DB      'PR.:IN."PLACE YOUR BET";F',0DH
0DA1 494E2E22
0DA5 504C4143
0DA9 4520594F
0DAD 55522042
0DB1 4554223B
0DB5 46
0DB6 0D
0DB7 0A64       =1  2976 +2          DW      2660
0DB9 49462046   =1  2977 +2          DB      'IF F>E PR."YOU''VE ONLY GOT ";E;" BUCKS LEFT, TURKEY":GO.2650',0DH
0DBD 3E452050
0DC1 522E2259
0DC5 4F552756
0DC9 45204F4E
0DCD 4C592047
0DD1 4F542022
0DD5 3B453B22
0DD9 20425543
0DDD 4B53204C
0DE1 4546542C
0DE5 20545552
0DE9 4B455922
0DED 3A474F2E
0DF1 32363530
0DF5 0D
0DF6 0A6E       =1  2978 +2          DW      2670
0DF8 49462046   =1  2979 +2          DB      'IF F=0 PR."CHICKEN SHIT!!":PR.',0DH
0DFC 3D302050
0E00 522E2243
0E04 4849434B
0E08 454E2053
0E0C 48495421
0E10 21223A50
0E14 522E
0E16 0D
0E17 0A78       =1  2980 +2          DW      2680
0E19 49462046   =1  2981 +2          DB      'IF F<0 F=-F:PR."I''LL ASSUME YOU MEANT $";F;".00"',0DH
0E1D 3C302046
0E21 3D2D463A
0E25 50522E22
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   70


LOC  OBJ            LINE     SOURCE

0E29 49274C4C
0E2D 20415353
0E31 554D4520
0E35 594F5520
0E39 4D45414E
0E3D 54202422
0E41 3B463B22
0E45 2E303022
0E49 0D
0E4A 0AAA       =1  2982 +2          DW      2730
0E4C 50522E22   =1  2983 +2          DB      'PR."AND YOUR LAST CARD IS A ... ";:GOS.4000',0DH
0E50 414E4420
0E54 594F5552
0E58 204C4153
0E5C 54204341
0E60 52442049
0E64 53204120
0E68 2E2E2E20
0E6C 223B3A47
0E70 4F532E34
0E74 303030
0E77 0D
0E78 0B5E       =1  2984 +2          DW      2910
0E7A 49462044   =1  2985 +2          DB      'IF D>A IF D<B E=E+F:PR."YOU WIN!!!":GO.2190',0DH
0E7E 3E412049
0E82 4620443C
0E86 4220453D
0E8A 452B463A
0E8E 50522E22
0E92 594F5520
0E96 57494E21
0E9A 2121223A
0E9E 474F2E32
0EA2 313930
0EA5 0D
0EA6 0B9A       =1  2986 +2          DW      2970
0EA8 453D452D   =1  2987 +2          DB      'E=E-F:PR."SORRY, YOU LOSE.":IF E>0 GO.2190',0DH
0EAC 463A5052
0EB0 2E22534F
0EB4 5252592C
0EB8 20594F55
0EBC 204C4F53
0EC0 452E223A
0EC4 49462045
0EC8 3E302047
0ECC 4F2E3231
0ED0 3930
0ED2 0D
0ED3 0BC2       =1  2988 +2          DW      3010
0ED5 50522E22   =1  2989 +2          DB      'PR."FRIEND, YOU BLEW YOUR WAD."',0DH
0ED9 46524945
0EDD 4E442C20
0EE1 594F5520
0EE5 424C4557
0EE9 20594F55
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   71


LOC  OBJ            LINE     SOURCE

0EED 52205741
0EF1 442E22
0EF4 0D
0EF5 0BE0       =1  2990 +2          DW      3040
0EF7 50522E3A   =1  2991 +2          DB      'PR.:IN."TYPE 1 TO PLAY AGAIN",D:IF D=1 GO.2110',0DH
0EFB 494E2E22
0EFF 54595045
0F03 20312054
0F07 4F20504C
0F0B 41592041
0F0F 4741494E
0F13 222C443A
0F17 49462044
0F1B 3D312047
0F1F 4F2E3231
0F23 3130
0F25 0D
0F26 0BF4       =1  2992 +2          DW      3060
0F28 454E44     =1  2993 +2          DB      'END',0DH
0F2B 0D
0F2C 0FA0       =1  2994 +2          DW      4000
0F2E 443D524E   =1  2995 +2          DB      'D=RND(13)+1:IF D<11 PR.D',0DH
0F32 44283133
0F36 292B313A
0F3A 49462044
0F3E 3C313120
0F42 50522E44
0F46 0D
0F47 0FC8       =1  2996 +2          DW      4040
0F49 49462044   =1  2997 +2          DB      'IF D=11 PR."JACK"',0DH
0F4D 3D313120
0F51 50522E22
0F55 4A41434B
0F59 22
0F5A 0D
0F5B 0FD2       =1  2998 +2          DW      4050
0F5D 49462044   =1  2999 +2          DB      'IF D=12 PR."QUEEN"',0DH
0F61 3D313220
0F65 50522E22
0F69 51554545
0F6D 4E22
0F6F 0D
0F70 0FDC       =1  3000 +2          DW      4060
0F72 49462044   =1  3001 +2          DB      'IF D=13 PR."KING"',0DH
0F76 3D313320
0F7A 50522E22
0F7E 4B494E47
0F82 22
0F83 0D
0F84 0FE6       =1  3002 +2          DW      4070
0F86 49462044   =1  3003 +2          DB      'IF D=14 PR."ACE"',0DH
0F8A 3D313420
0F8E 50522E22
0F92 41434522
0F96 0D
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   72


LOC  OBJ            LINE     SOURCE

0F97 0FF0       =1  3004 +2          DW      4080
0F99 5245542E   =1  3005 +2          DB      'RET.',0DH
0F9D 0D
                =1  3006     ;
0F9E 80             3007             DB      80H             ;Marks end of program.
                    3008     ;
                    3009             END
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   73


SYMBOL TABLE LISTING
------ ----- -------


N A M E      T Y P E   V A L U E       A T T R I B U T E S

ACC . . . .  D ADDR    00E0H   A       
ADD_16. . .  C ADDR    0341H   A       
ADR_ER. . .  C ADDR    01E7H   A       
AES_ER. . .  C ADDR    0109H   A       
AES . . . .  D ADDR    002BH   A       
AESLEN. . .    NUMB    0024H   A       
AESP. . . .  D ADDR    002AH   A       
ALPHAB. . .  C ADDR    0552H   A       
APN_ER. . .  C ADDR    0334H   A       
APND_1. . .  C ADDR    030EH   A       
APND_2. . .  C ADDR    0332H   A       
APND_4. . .  C ADDR    030CH   A       
APPEND. . .  C ADDR    02F1H   A       
AR_EXP. . .  C ADDR    0AF0H   A       
ASCTBL. . .  C ADDR    00DBH   A       
B . . . . .  D ADDR    00F0H   A       
BAUDID. . .  C ADDR    0046H   A       
BEL . . . .    NUMB    0007H   A       
BIG_PROBLEM  C ADDR    0468H   A       
C_IN_1. . .  C ADDR    0097H   A       
C_IN_2. . .  C ADDR    008BH   A       
C_IN. . . .  C ADDR    007CH   A       
C_OUT . . .  C ADDR    009AH   A       
C_SAVE. . .  D ADDR    0053H   A       
CHAR_FLG. .  B ADDR    0029H.1 A       
CHAR. . . .    REG     R4              
CMD_NG. . .  C ADDR    085CH   A       
CMPR_1. . .  C ADDR    0492H   A       
CMPR_2. . .  C ADDR    0498H   A       
CMPR_4. . .  C ADDR    048AH   A       
CMPR. . . .  C ADDR    0473H   A       
CNTR_2. . .  C ADDR    00BFH   A       
CNTRET. . .  C ADDR    00C4H   A       
CNTRL . . .  C ADDR    00B7H   A       
COND. . . .  C ADDR    07F1H   A       
CONT_1. . .  C ADDR    0870H   A       
CONT. . . .  C ADDR    086AH   A       
COUT_1. . .  C ADDR    00B6H   A       
COUT_2. . .  C ADDR    00AEH   A       
COUT_3. . .  C ADDR    00B2H   A       
CR. . . . .    NUMB    000DH   A       
CREA_1. . .  C ADDR    02F0H   A       
CREATE. . .  C ADDR    02E4H   A       
CURS_H. . .  D ADDR    0052H   A       
CURS_L. . .  D ADDR    0051H   A       
D_BLNK. . .  C ADDR    0501H   A       
DEST_H. . .    REG     R3              
DEST_L. . .    REG     R1              
DIV_1 . . .  C ADDR    0441H   A       
DIV_2 . . .  C ADDR    0446H   A       
DIV_LP. . .  C ADDR    0414H   A       
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   74


N A M E      T Y P E   V A L U E       A T T R I B U T E S

DIV_NG. . .  C ADDR    0449H   A       
DIV_RP. . .  C ADDR    042BH   A       
DONE_1. . .  C ADDR    05E5H   A       
DONE_2. . .  C ADDR    05E9H   A       
DONE. . . .  C ADDR    05DDH   A       
DPH . . . .  D ADDR    0083H   A       
DPL . . . .  D ADDR    0082H   A       
DUPL. . . .  C ADDR    014AH   A       
E0. . . . .  C ADDR    0AE3H   A       
E1. . . . .  C ADDR    0AF3H   A       
E2. . . . .  C ADDR    0B01H   A       
E3. . . . .  C ADDR    0B0FH   A       
E4. . . . .  C ADDR    0B1EH   A       
E5. . . . .  C ADDR    0B2EH   A       
ERRENT. . .  C ADDR    0862H   A       
ERROUT. . .  C ADDR    00FDH   A       
EXP_ER. . .  C ADDR    0100H   A       
EXP_OV. . .  C ADDR    033EH   A       
EXPR. . . .  C ADDR    0AE0H   A       
EXTINI. . .  C ADDR    072FH   A       
EXTMOD. . .  B ADDR    0028H.2 A       
EXTRAM. . .    NUMB    2034H   A       
EXTROM. . .    NUMB    1080H   A       
EXTVAR. . .  B ADDR    0028H.0 A       
F0. . . . .  B ADDR    00D0H.5 A       
FACT_1. . .  C ADDR    0B7CH   A       
FACT. . . .  C ADDR    0B6FH   A       
FET_0 . . .  C ADDR    0289H   A       
FET_1 . . .  C ADDR    0296H   A       
FETBDN. . .  C ADDR    02DFH   A       
FETCBY. . .  C ADDR    02D9H   A       
FETCH . . .  C ADDR    0287H   A       
FETDBY. . .  C ADDR    02C0H   A       
FETDIR. . .  C ADDR    01F7H   A       
FETERR. . .  C ADDR    02BEH   A       
FETEXT. . .  C ADDR    02B3H   A       
FETJTB. . .  C ADDR    029BH   A       
FETRBI. . .  C ADDR    02C6H   A       
FETSFR. . .  C ADDR    01FDH   A       
FETVAR. . .  C ADDR    02A0H   A       
FETXBY. . .  C ADDR    02D2H   A       
FIN . . . .  C ADDR    0846H   A       
FLAGS . . .  D ADDR    0029H   A       
FND_1 . . .  C ADDR    074FH   A       
FNDDON. . .  C ADDR    0767H   A       
FNDLBL. . .  C ADDR    0749H   A       
FOR_ER. . .  C ADDR    0A21H   A       
FORDON. . .  C ADDR    0A12H   A       
GET_BUF . .  C ADDR    04CAH   A       
GET_C . . .  C ADDR    04C5H   A       
GETL_0. . .  C ADDR    0622H   A       
GETL_1. . .  C ADDR    0627H   A       
GETL_2. . .  C ADDR    0663H   A       
GETL_3. . .  C ADDR    065BH   A       
GETL_4. . .  C ADDR    0653H   A       
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   75


N A M E      T Y P E   V A L U E       A T T R I B U T E S

GETL_5. . .  C ADDR    063EH   A       
GETL_6. . .  C ADDR    0633H   A       
GETL_7. . .  C ADDR    0647H   A       
GETLN . . .  C ADDR    061CH   A       
GETROM. . .  C ADDR    04D1H   A       
H_FLG . . .  B ADDR    0029H.5 A       
HEXMOD. . .  B ADDR    0028H.4 A       
IABS. . . .  C ADDR    038BH   A       
IADD. . . .  C ADDR    0349H   A       
IAND. . . .  C ADDR    035BH   A       
ICPL. . . .  C ADDR    0388H   A       
IDIV_0. . .  C ADDR    03F0H   A       
IDIV. . . .  C ADDR    03EEH   A       
IFDN_1. . .  C ADDR    05F3H   A       
IFDN_2. . .  C ADDR    05F7H   A       
IFDONE. . .  C ADDR    05EDH   A       
IINC_1. . .  C ADDR    03A2H   A       
IINC. . . .  C ADDR    0399H   A       
IMOD. . . .  C ADDR    03EAH   A       
IMUL_1. . .  C ADDR    03AFH   A       
IMUL_2. . .  C ADDR    03B9H   A       
IMUL_3. . .  C ADDR    03C3H   A       
IMUL. . . .  C ADDR    03DBH   A       
INDEX . . .  C ADDR    0598H   A       
INDTBL. . .  C ADDR    01AAH   A       
INIT_1. . .  C ADDR    0728H   A       
INIT_2. . .  C ADDR    0733H   A       
INIT_3. . .  C ADDR    0738H   A       
INIT. . . .  C ADDR    0739H   A       
INNUM . . .  C ADDR    06E0H   A       
INSL_1. . .  C ADDR    07C9H   A       
INSR_1. . .  C ADDR    07DAH   A       
INSR_2. . .  C ADDR    07DDH   A       
INSR_4. . .  C ADDR    07EEH   A       
INSR_L. . .  C ADDR    07BDH   A       
INSRT . . .  C ADDR    07D1H   A       
INTROM. . .  C ADDR    0C1DH   A       
INUM_0. . .  C ADDR    06E6H   A       
INUM_1. . .  C ADDR    06FFH   A       
INUM_2. . .  C ADDR    0706H   A       
INUM_3. . .  C ADDR    06EFH   A       
INUM_4. . .  C ADDR    06F4H   A       
INUM_5. . .  C ADDR    06FBH   A       
INUM_6. . .  C ADDR    070CH   A       
IOR . . . .  C ADDR    0365H   A       
ISUB. . . .  C ADDR    034FH   A       
IXOR. . . .  C ADDR    036FH   A       
KILL_2. . .  C ADDR    076FH   A       
KILL_3. . .  C ADDR    077AH   A       
KILL_9. . .  C ADDR    0783H   A       
KILL_L. . .  C ADDR    0769H   A       
L_CURS. . .  D ADDR    004FH   A       
L_INIT. . .  C ADDR    0608H   A       
LABL_H. . .  D ADDR    0055H   A       
LABL_L. . .  D ADDR    0054H   A       
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   76


N A M E      T Y P E   V A L U E       A T T R I B U T E S

LF. . . . .    NUMB    000AH   A       
LINI_1. . .  C ADDR    060DH   A       
LIT_1 . . .  C ADDR    016DH   A       
LIT . . . .  C ADDR    015EH   A       
LNDONE. . .  C ADDR    05E3H   A       
LOAD_PNTR .  C ADDR    04BEH   A       
LOOP_0. . .  C ADDR    081CH   A       
LOOP_1. . .  C ADDR    0840H   A       
LOOP_2. . .  C ADDR    083DH   A       
LOOP. . . .  C ADDR    080FH   A       
LP_CNT. . .    REG     R5              
LST_1 . . .  C ADDR    06D5H   A       
LST . . . .  C ADDR    06D1H   A       
LSTL_1. . .  C ADDR    06D0H   A       
LSTL_2. . .  C ADDR    06C9H   A       
LSTLIN. . .  C ADDR    06BAH   A       
LSTRET. . .  C ADDR    06DDH   A       
MLCALL. . .  C ADDR    084BH   A       
MOD_FLG . .  B ADDR    0029H.4 A       
MODE. . . .  D ADDR    0028H   A       
MSK_PC. . .  C ADDR    0214H   A       
MSKTBL. . .  C ADDR    0217H   A       
MUL_16. . .  C ADDR    03A3H   A       
NEG_0 . . .  C ADDR    037CH   A       
NEG_IF_NEG.  C ADDR    0395H   A       
NEG . . . .  C ADDR    0379H   A       
NIBO_1. . .  C ADDR    00D7H   A       
NIBO_2. . .  C ADDR    00D3H   A       
NIBO_3. . .  C ADDR    00DAH   A       
NIBOUT. . .  C ADDR    00CCH   A       
NL_NXT. . .  C ADDR    060FH   A       
NLINE . . .  C ADDR    0098H   A       
NO_PROBLEM.  C ADDR    046CH   A       
NO_SFR. . .    NUMB    000EH   A       
NO_VAR. . .    NUMB    000CH   A       
NOTSYM. . .  C ADDR    059DH   A       
NOTVAR. . .  C ADDR    055FH   A       
NXT_1 . . .  C ADDR    0619H   A       
NXT . . . .  C ADDR    0611H   A       
OPEN_1. . .  C ADDR    07A4H   A       
OPEN_2. . .  C ADDR    07B1H   A       
OPEN_3. . .  C ADDR    0788H   A       
OPEN_4. . .  C ADDR    0796H   A       
OPEN_5. . .  C ADDR    078FH   A       
OPEN_6. . .  C ADDR    07B6H   A       
OPEN_L. . .  C ADDR    0784H   A       
OV_TST. . .  C ADDR    0337H   A       
OV. . . . .  B ADDR    00D0H.2 A       
P1. . . . .  D ADDR    0090H   A       
P2. . . . .  D ADDR    00A0H   A       
PNTR_H. . .    REG     R2              
PNTR_L. . .    REG     R0              
POP_ACC . .  C ADDR    0131H   A       
POP_TOS . .  C ADDR    011FH   A       
PRN_1 . . .  C ADDR    0685H   A       
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   77


N A M E      T Y P E   V A L U E       A T T R I B U T E S

PRN . . . .  C ADDR    066FH   A       
PRNH_1. . .  C ADDR    06AAH   A       
PRNHEX. . .  C ADDR    069CH   A       
PRNRET. . .  C ADDR    06B9H   A       
PRNTOS. . .  C ADDR    0675H   A       
PSW . . . .  D ADDR    00D0H   A       
PUSH_C. . .  C ADDR    049AH   A       
PUSH_TOS. .  C ADDR    0137H   A       
PUT_BUF . .  C ADDR    04F0H   A       
PUTROM. . .  C ADDR    04F7H   A       
RAM_INIT. .  C ADDR    0714H   A       
RAMLIM. . .    NUMB    3000H   A       
RDCHDN. . .  C ADDR    04EDH   A       
READ_CHAR .  C ADDR    04E2H   A       
READ_LABEL.  C ADDR    05FBH   A       
REL_1 . . .  C ADDR    0BDDH   A       
REL_2 . . .  C ADDR    0BE9H   A       
REL_3 . . .  C ADDR    0BF5H   A       
REL_4 . . .  C ADDR    0C00H   A       
REL_5 . . .  C ADDR    0C0CH   A       
REL_6 . . .  C ADDR    0C17H   A       
RELOP . . .  C ADDR    0BD2H   A       
REREAD. . .  C ADDR    04EEH   A       
REWIND. . .  C ADDR    04A0H   A       
REWROM. . .  C ADDR    04AAH   A       
RI. . . . .  B ADDR    0098H.0 A       
RND . . . .  C ADDR    044BH   A       
ROMMOD. . .  B ADDR    0028H.1 A       
RSTR. . . .  C ADDR    0806H   A       
RUNMOD. . .  B ADDR    0028H.3 A       
RUNROM. . .  C ADDR    0075H   A       
RWXROM. . .  C ADDR    04B2H   A       
RXD . . . .  B ADDR    00B0H.0 A       
S_INIT. . .  C ADDR    0026H   A       
S0. . . . .  C ADDR    089BH   A       
S1. . . . .  C ADDR    08D4H   A       
S10 . . . .  C ADDR    0973H   A       
S10B. . . .  C ADDR    0983H   A       
S10C. . . .  C ADDR    098BH   A       
S10D. . . .  C ADDR    0996H   A       
S11 . . . .  C ADDR    0999H   A       
S12 . . . .  C ADDR    099FH   A       
S13 . . . .  C ADDR    09AFH   A       
S13A. . . .  C ADDR    09C6H   A       
S13B. . . .  C ADDR    09F2H   A       
S13C. . . .  C ADDR    0A23H   A       
S14 . . . .  C ADDR    0A30H   A       
S14B. . . .  C ADDR    0A49H   A       
S15 . . . .  C ADDR    0A4EH   A       
S16 . . . .  C ADDR    0A5BH   A       
S16A. . . .  C ADDR    0A68H   A       
S17 . . . .  C ADDR    0A78H   A       
S17A. . . .  C ADDR    0A8AH   A       
S17B. . . .  C ADDR    0A9AH   A       
S17C. . . .  C ADDR    0AADH   A       
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   78


N A M E      T Y P E   V A L U E       A T T R I B U T E S

S18 . . . .  C ADDR    0ABDH   A       
S19 . . . .  C ADDR    0AD1H   A       
S2. . . . .  C ADDR    08E6H   A       
S20 . . . .  C ADDR    0ADEH   A       
S3. . . . .  C ADDR    08FCH   A       
S3A . . . .  C ADDR    090BH   A       
S3B . . . .  C ADDR    0913H   A       
S3C . . . .  C ADDR    091EH   A       
S5. . . . .  C ADDR    092EH   A       
S5A . . . .  C ADDR    0939H   A       
S6. . . . .  C ADDR    0941H   A       
S6A . . . .  C ADDR    0947H   A       
S6B . . . .  C ADDR    0944H   A       
S8. . . . .  C ADDR    094AH   A       
S8A . . . .  C ADDR    095DH   A       
S8B . . . .  C ADDR    0964H   A       
S9. . . . .  C ADDR    0969H   A       
SAV . . . .  C ADDR    07FFH   A       
SAVE_PNTR .  C ADDR    04B7H   A       
SBUF. . . .  D ADDR    0099H   A       
SCON. . . .  D ADDR    0098H   A       
SE3 . . . .  C ADDR    08AEH   A       
SE3A. . . .  C ADDR    08BFH   A       
SE4 . . . .  C ADDR    08C8H   A       
SEED_H. . .  D ADDR    000EH   A       
SEED_L. . .  D ADDR    000DH   A       
SEQ_FETCH .  C ADDR    0283H   A       
SEQ_FLG . .  B ADDR    0029H.3 A       
SEQ_STORE .  C ADDR    021FH   A       
SETRBI. . .  C ADDR    0276H   A       
SFID_1. . .  C ADDR    01D9H   A       
SFID_2. . .  C ADDR    01E2H   A       
SFR_ID. . .  C ADDR    01D4H   A       
SFRTBL. . .  C ADDR    0172H   A       
SGN_FLG . .  B ADDR    0029H.2 A       
SKPLIN. . .  C ADDR    050BH   A       
SKPTXT. . .  C ADDR    050FH   A       
SP_BASE . .  D ADDR    0055H   A       
SP_INI. . .  C ADDR    0033H   A       
SP. . . . .  D ADDR    0081H   A       
SPC . . . .  C ADDR    00C5H   A       
SPLIT_DBA .  C ADDR    0203H   A       
SPLSFR. . .  C ADDR    020DH   A       
START . . .  C ADDR    085FH   A       
STK_ER. . .  C ADDR    0147H   A       
STMT. . . .  C ADDR    0883H   A       
STOR_0. . .  C ADDR    0225H   A       
STOR_1. . .  C ADDR    0238H   A       
STORE . . .  C ADDR    0223H   A       
STRCBY. . .  C ADDR    027BH   A       
STRDBY. . .  C ADDR    0260H   A       
STRDIR. . .  C ADDR    01E9H   A       
STREXT. . .  C ADDR    0254H   A       
STRJTB. . .  C ADDR    023DH   A       
STRLEN. . .  D ADDR    000FH   A       
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   79


N A M E      T Y P E   V A L U E       A T T R I B U T E S

STRO_1. . .  C ADDR    00EFH   A       
STRO_2. . .  C ADDR    00F9H   A       
STROUT. . .  C ADDR    00EBH   A       
STRRBI. . .  C ADDR    0266H   A       
STRSFR. . .  C ADDR    01F1H   A       
STRTBL. . .  C ADDR    0180H   A       
STRVAR. . .  C ADDR    0242H   A       
STRXBY. . .  C ADDR    027BH   A       
SYN_ER. . .  C ADDR    0114H   A       
SYN_NG. . .  C ADDR    0BD0H   A       
T_BAD . . .  C ADDR    0538H   A       
T_GOOD. . .  C ADDR    0534H   A       
TABCNT. . .  D ADDR    0050H   A       
TABSIZ. . .    NUMB    0008H   A       
TERM_0. . .  C ADDR    0B32H   A       
TERM_1. . .  C ADDR    0B40H   A       
TERM_2. . .  C ADDR    0B4EH   A       
TERM_3. . .  C ADDR    0B5EH   A       
TERM_4. . .  C ADDR    0B6EH   A       
TERM. . . .  C ADDR    0B2FH   A       
TH1 . . . .  D ADDR    008DH   A       
TI. . . . .  B ADDR    0098H.1 A       
TMOD. . . .  D ADDR    0089H   A       
TMP0. . . .  D ADDR    0008H   A       
TMP1. . . .  D ADDR    0009H   A       
TMP2. . . .  D ADDR    000AH   A       
TMP3. . . .  D ADDR    000BH   A       
TMP4. . . .  D ADDR    000CH   A       
TOKEN . . .  C ADDR    0888H   A       
TOS_H . . .    REG     R7              
TOS_L . . .    REG     R6              
TR1 . . . .  B ADDR    0088H.6 A       
TST_1 . . .  C ADDR    051DH   A       
TST_2 . . .  C ADDR    052EH   A       
TST . . . .  C ADDR    0515H   A       
TSTCBY. . .  C ADDR    058CH   A       
TSTN_1. . .  C ADDR    05B3H   A       
TSTN. . . .  C ADDR    05AAH   A       
TSTRBI. . .  C ADDR    0571H   A       
TSTS_1. . .  C ADDR    05CFH   A       
TSTS_2. . .  C ADDR    05D6H   A       
TSTS. . . .  C ADDR    05BFH   A       
TSTV_1. . .  C ADDR    059FH   A       
TSTV. . . .  C ADDR    0545H   A       
TSTXBY. . .  C ADDR    057EH   A       
US_VAR. . .  D ADDR    0010H   A       
VAR_0 . . .  C ADDR    0B94H   A       
VAR_1 . . .  C ADDR    0B9AH   A       
VAR_1A. . .  C ADDR    0BB2H   A       
VAR_2 . . .  C ADDR    0BC1H   A       
VAR . . . .  C ADDR    0B8BH   A       
VERS. . . .    NUMB    0022H   A       
WRCH_1. . .  C ADDR    0500H   A       
WRITE_CHAR.  C ADDR    04F9H   A       
XEC . . . .  C ADDR    0880H   A       
MCS-51 MACRO ASSEMBLER    MCS-51(TM) TINY BASIC INTERPRETER 8/26/80                                            PAGE   80


N A M E      T Y P E   V A L U E       A T T R I B U T E S

XFER. . . .  C ADDR    07F6H   A       
XFERNG. . .  C ADDR    07FDH   A       
XINIT . . .  C ADDR    0741H   A       
XRAD_1. . .  C ADDR    0318H   A       
ZERSUP. . .  B ADDR    0029H.0 A       


REGISTER BANK(S) USED: 0, TARGET MACHINE(S): 8051 

ASSEMBLY COMPLETE, NO ERRORS FOUND
