       MCS-51 Family Cross Assembler   A S E M - 5 1   V 1.2
       =====================================================



	Source File:	BASIC2.ASM
	Object File:	BASIC2.HEX
	List File:	BASIC2.LST



 Line  I  Addr  Code            Source

    1:				;*****************************************************************************
    2:				;*                                                                           *
    3:				;*                    MCS-BASIC-52 V1.31 Source Listing                      *
    4:				;*                           12/1986 till 11/2001                            *
    5:				;*       The original source code of V1.1 (BASIC.SRC and FP52.SRC) by        *
    6:				;*            Intel Corporation, Embedded Controller Operations              *
    7:				;*                             is public domain                              *
    8:				;*                                                                           *
    9:				;*****************************************************************************
   10:				;
   11:				; Modified for 8051 kit by W.Sirichote, October 2016
   12:				;
   13:				;*****************************************************************************
   14:				;* General alterations made by D. Wulf, 12/1999.                             *
   15:				;* e-mail: Detlef.Wulf@onlinehome.de                                         *
   16:				;*****************************************************************************
   17:				;
   18:				;  The following general alterations are made to the original source code:
   19:				;
   20:				;  - The original source code had 2 files BASIC.SRC and FP52.SRC those have
   21:				;    been incorporated into this file for easy of assembly.
   22:				;
   23:				;  - All absolute and relativ jumps and calls without labels were provided
   24:				;    with labels.
   25:				;
   26:				;  - All machine code in the original source, coded in databytes are replaced
   27:				;    by the menomics.
   28:				;
   29:				;  - One routine in the source was different to the ROM code and is replaced
   30:				;    by the ROM code.
   31:				;
   32:				;  - Some "ORG" statements between BASIC and floating point code are remarked
   33:				;    out.
   34:				;
   35:				;  - To get room for new code the "ego message" had to be disabled.
   36:				;    (Remarked with "Sorry")
   37:				;
   38:				;  - To get more room for new code the "FPROG" command had to be disabled.
   39:				;    (Remarked with "get room")
   40:				;
   41:				;*****************************************************************************
   42:				;* Bugfixes for MCS-52-BASIC from D. Karmann, 8/1993.                        *
   43:				;* e-mail: dankarmann@lucent.com                                             *
   44:				;*****************************************************************************
   45:				;
   46:				;  - Corrected Intel bug to allow BASIC autoboot EPROM at 8000H with user
   47:				;    command extensions to work.
   48:				;    (Remarked as Karmann 1)
   49:				;
   50:				;  - Corrected Intel bug to that discarded the 'F' in any variable ending in
   51:				;    F, FP, FPR and FPRO and followed by a space.
   52:				;    (Remarked as Karmann 2)
   53:				;
   54:				;*****************************************************************************
   55:				;* Bugfix and performance for MCS-52-BASIC from                              *
   56:				;* D. Mudric and Z. Stojsavljevic descipt in                                 *
   57:				;* Elektor Electronics magazine german issue 3/1992.                         *
   58:				;*****************************************************************************
   59:				;
   60:				;  - Modifications to the unprocess a BASIC line routine.
   61:				;    (Remarked as Elektor 1)
   62:				;
   63:				;  - Modifications to the floating point subtraction routine.
   64:				;    (Remarked as Elektor 2)
   65:				;
   66:				;  - HEX to BIN performance improvements.
   67:				;    (Remarked as Elektor 3)
   68:				;
   69:				; The same article describes a fix for the multiplication underflow bug, but
   70:				; the fixes did not work.
   71:				;
   72:				; The multiplicaton underflow bug is now (V1.31) really fixed by D. Wulf!
   73:				;    (Remarked as Wulf 1)
   74:				;
   75:				;*****************************************************************************
   76:				;* Change UV-EPROM to EEPROM programming from R. Skowronek, 4/1996           *
   77:				;* e-mail: r.skowronek@kfa-juelich.de                                        *
   78:				;*****************************************************************************
   79:				;
   80:				; This altered section of code writes the ram resident Basic program to
   81:				; EEPROM just like the ROM resident Basic interpreter writes to UV-EPROMs.
   82:				; The EEPROM is connected just like a RAM, i.e. it uses /wr on pin 27
   83:				; and gets it's adresses from the real address lines, i.e. the only
   84:				; difference from the normal setup is the use of the /wr line instead of
   85:				; P1.4, which supplies the program pulse for UV-EPROMs. Now MCS-BASIC-52
   86:				; can be located in externally ROM and is non the less able to programm
   87:				; EEPROMs!
   88:				; (Remarked as Skowronek)
   89:				;
   90:				; The original code from R. Skowronek didn't support the "PGM" statement
   91:				; this feature is added by D. Wulf.
   92:				; Memory is now limited to 32K bytes RAM, because memory tests above it
   93:				; would change the EEPROM.
   94:				;
   95:				;*****************************************************************************
   96:				;* Change timer 0 from 13 bit to 16 bit counter mode to use XTAL up to 78MHz *
   97:				;* from D. Wulf 1/2000                                                       *
   98:				;*****************************************************************************
   99:				;
  100:				; The max. value for XTAL is now 78627473 Hz, for use BASIC-52 with
  101:				; Dallas 80C320 high speed / low power microcontroller (33 MHz).
  102:				; The defaut crystal value is still 11059200 Hz. You can set it with
  103:				; XTAL or patch the souce code at
  104:				;
  105:				;	17F1H = 11
  106:				;	17F0H = 05
  107:				;	17EFH = 92
  108:				;	17EEH = 00
  109:				;
  110:				; with a new crystal value.
  111:				; (Remarket as Wulf 2)
  112:				;
  113:				;*****************************************************************************
  114:				;* New baudrate detection from D. Wulf 1/2000                                *
  115:				;*****************************************************************************
  116:				;
  117:				; The new baudrate detection uses timer 2 for time measurement in state of
  118:				; the code loop timing. So the Dallas 80C320 and other controllers can be
  119:				; used. Also at higher clock speeds the baudrate will detect automaticly.
  120:				; (Remarked as Wulf 3)
  121:				;
  122:				;*****************************************************************************
  123:				;* New processor type detection from D. Wulf 2/2000                          *
  124:				;*****************************************************************************
  125:				;
  126:				; A new reset routine detects the processor type. So BASIC-52 V1.3 can be
  127:				; used with the following controllers:
  128:				;
  129:				; 8032, 87C52#, Dallas 80C320, 80515*#, 80517*#, 80517A#, 80528, 80535*,
  130:				; 80537*, 80575 or similars.
  131:				;
  132:				; - On processor types marked with the "*" only two different autodetect
  133:				;   baudrates, depending on the crystal are possible.
  134:				; - The processor types marked with the "#" have internal ROM, so BASIC-52
  135:				;   V1.3 can be located there, because it is still only 8K bytes long!
  136:				;
  137:				; (Remarked as Wulf 4)
  138:				;
  139:				;*****************************************************************************
  140:				;* OPBYTE 43H for POP from H.-J. Boehling 1/2000                             *
  141:				;* e-mail: H-Boehling@gmx.de                                                 *
  142:				;*****************************************************************************
  143:				;
  144:				; A feature of BASIC-52 is the ability to add up to 16 custom keywords
  145:				; representing commands or instructions that you define with assembler
  146:				; routines. For using system routines in your assembler code there are
  147:				; operation bytes (for more information see Intels "MCS BASIC-52 MANUAL").
  148:				; In the original souce code is no OPCODE to put a value from argument
  149:				; stack and store in a variable.
  150:				; With BASIC-52 V1.3 you can use OPBYTE 43H which does the same than the
  151:				; "POP" statement.
  152:				; (Remarked as Boehling 1)
  153:				;
  154:				;*****************************************************************************
  155:				;* Reset millisecond counter on "TIME=" from H.-J. Boehling 2/2000           *
  156:				;*****************************************************************************
  157:				;
  158:				; The command "TIME=0" now zeros the millisecond register so that TIME
  159:				; returns with zero.
  160:				; (Remarked as Boehling 2)
  161:				;
  162:				;*****************************************************************************
  163:				;* New command "ERASE" by H.-J. Boehling 2/2000                              *
  164:				;*****************************************************************************
  165:				;
  166:				; To erase an EEPROM (fill 16K byte up to 8000H with 0FFH) the new command
  167:				; "ERASE" is implemented. It takes 2 min. and 45 sec. to erase the 16K bytes!
  168:				; (Remarked as Boehling 3)
  169:				;
  170:				;*****************************************************************************
  171:				;* Correct "ASC(x)" bug by D. Wulf 2/2000                                    *
  172:				;*****************************************************************************
  173:				;
  174:				; BASIC-51 V1.1 gives erroneous results for the "ASC(x)" funktion if "x" is
  175:				; one of the following signs : *, +, -, /, <, =, > or ?.
  176:				; BASIC-51 V1.3 returns the correct values.
  177:				; (Remarked as Wulf 5)
  178:				;
  179:				;*****************************************************************************
  180:				;*****************************************************************************
  181:				; To indicate the new version the start message is changed from
  182:				; *MCS-51(tm) BASIC V1.1* to
  183:				; *MCS-BASIC-52 V1.31*
  184:				;
  185:				; H.-J. Boehling, D. Wulf 11/26/2001
  186:				;*****************************************************************************
  187:				;
  188:		N      00C8	T2CON	EQU	0C8H ; This three lines are necessary for MS-DOS freeware
  189:		N      00CC	TL2	EQU	0CCH ; MCS-51 Family Cross Assembler  ASEM-51 V1.2
  190:		N      00CD	TH2	EQU	0CDH ; from W.W. Heinz (e-mail: ww@andiunx.m.isar.de)
  191:				;
  192:					;**************************************************************
  193:					;
  194:					; TRAP VECTORS TO MONITOR
  195:					;
  196:					; RESET TAG (0AAH) ---------2001H
  197:					;
  198:					; TAG LOCATION (5AH) ------ 2002H
  199:					;
  200:					; EXTERNAL INTERRUPT 0 ---- 2040H
  201:					;
  202:					; COMMAND MODE ENTRY ------ 2048H
  203:					;
  204:					; SERIAL PORT ------------- 2050H
  205:					;
  206:					; MONITOR (BUBBLE) OUTPUT - 2058H
  207:					;
  208:					; MONITOR (BUBBLE) INPUT -- 2060H
  209:					;
  210:					; MONITOR (BUBBLE) CSTS --- 2068H
  211:					;
  212:					; GET USER JUMP VECTOR ---- 2070H
  213:					;
  214:					; GET USER LOOKUP VECTOR -- 2078H
  215:					;
  216:					; PRINT AT VECTOR --------- 2080H
  217:					;
  218:					; INTERRUPT PWM ----------- 2088H
  219:					;
  220:					; EXTERNAL RESET ---------- 2090H
  221:					;
  222:					; USER OUTPUT-------------- 4030H
  223:					;
  224:					; USER INPUT -------------- 4033H
  225:					;
  226:					; USER CSTS --------------- 4036H
  227:					;
  228:					; USER RESET -------------- 4039H
  229:					;
  230:					; USER DEFINED PRINT @ ---  403CH
  231:					;
  232:					;***************************************************************
  233:					;
  234:					;***************************************************************
  235:					;
  236:					; MCS - 52  -  8K BASIC VERSION 1.3
  237:					;
  238:					;***************************************************************
  239:					;
  240:	  0000	61 8B			AJMP	CRST		;START THE PROGRAM
  241:	  0002	37			ADDC	A,@R1
  242:					;
  243:		N      0003		ORG	3H
  244:					;
  245:					;***************************************************************
  246:					;
  247:					;EXTERNAL INTERRUPT 0
  248:					;
  249:					;***************************************************************
  250:					;
  251:	  0003	20 31 2D		JB	DRQ,STQ 	;SEE IF DMA IS SET
  252:	  0006	C0 D0			PUSH	PSW		;SAVE THE STATUS
  253:	  0008	02 40 03		LJMP	4003H		;JUMP TO USER IF NOT SET
  254:					;
  255:		N      000B		ORG	0BH
  256:					;
  257:					;***************************************************************
  258:					;
  259:					;TIMER 0 OVERFLOW INTERRUPT
  260:					;
  261:					;***************************************************************
  262:					;
  263:	  000B	C0 D0			PUSH	PSW		;SAVE THE STATUS
  264:	  000D	20 2E 10		JB	C_BIT,STJ	;SEE IF USER WANTS INTERRUPT
  265:	  0010	02 40 0B		LJMP	400BH		;EXIT IF USER WANTS INTERRUPTS
  266:					;
  267:		N      0013		ORG	13H
  268:					;
  269:					;***************************************************************
  270:					;
  271:					;EXTERNAL INTERRUPT 1
  272:					;
  273:					;***************************************************************
  274:					;
  275:	  0013	20 12 2B		JB	INTBIT,STK
  276:	  0016	C0 D0			PUSH	PSW
  277:	  0018	02 40 13		LJMP	4013H
  278:					;
  279:					;
  280:		N      001B		ORG	1BH
  281:					;
  282:					;***************************************************************
  283:					;
  284:					;TIMER 1 OVERFLOW INTERRUPT
  285:					;
  286:					;***************************************************************
  287:					;
  288:	  001B	C0 D0			PUSH	PSW
  289:	  001D	02 1F 78		LJMP	CKS_I
  290:					;
  291:	  0020	02 19 0F	STJ:	LJMP	I_DR		;DO THE INTERRUPT
  292:					;
  293:					;***************************************************************
  294:					;
  295:					;SERIAL PORT INTERRUPT
  296:					;
  297:					;***************************************************************
  298:					;
  299:		N      0023		ORG	23H
  300:					;
  301:	  0023	C0 D0			PUSH	PSW
  302:	  0025	20 1F 1C		JB	SPINT,STU	;SEE IF MONITOR EANTS INTERRUPT
  303:	  0028	02 40 23		LJMP	4023H
  304:					;
  305:		N      002B		ORG	2BH
  306:					;
  307:					;**************************************************************
  308:					;
  309:					;TIMER 2 OVERFLOW INTERRUPT
  310:					;
  311:					;**************************************************************
  312:					;
  313:	  002B	C0 D0			PUSH	PSW
  314:	  002D	02 40 2B		LJMP	402BH
  315:					;
  316:					;**************************************************************
  317:					;
  318:					;USER ENTRY
  319:					;
  320:					;**************************************************************
  321:					;
  322:		N      0030		ORG	30H
  323:					;
  324:	  0030	02 19 4C		LJMP	IBLK		;LINK TO USER BLOCK
  325:					;
  326:	  0033	20 26 08	STQ:	JB	I_T0,STS	;SEE IF MONITOR WANTS IT
  327:	  0036	C2 96			CLR	DACK
  328:	  0038	30 B2 FD		JNB	P3.2,$		;WAIT FOR DMA TO END
  329:	  003B	D2 96			SETB	DACK
  330:	  003D	32			RETI
  331:					;
  332:	  003E	02 20 40	STS:	LJMP	2040H		;GO TO THE MONITOR
  333:					;
  334:	  0041	D2 16		STK:	SETB	INTPEN		;TELL BASIC AN INTERRUPT WAS RECEIVED
  335:	  0043	32			RETI
  336:					;
  337:	  0044	02 20 50	STU:	LJMP	2050H		;SERIAL PORT INTERRUPT
  338:					;
  339:					;
  340:					;**************************************************************
  341:					;
  342:					; This is the equate table for 8052 basic.
  343:					;
  344:					;**************************************************************
  345:					;
  346:					; The register to direct equates for CJNE instructions.
  347:					;
  348:		N      0000	R0B0	EQU	0
  349:		N      0001	R1B0	EQU	1
  350:		N      0002	R2B0	EQU	2
  351:		N      0003	R3B0	EQU	3
  352:		N      0004	R4B0	EQU	4
  353:		N      0005	R5B0	EQU	5
  354:		N      0006	R6B0	EQU	6
  355:		N      0007	R7B0	EQU	7
  356:					;
  357:					; Register bank 1 contains the text pointer
  358:					; and the arg stack pointer.
  359:					;
  360:		N      0008	TXAL	EQU	8		;R0 BANK 1 = TEXT POINTER LOW
  361:		N      0009	ASTKA	EQU	9		;R1 BANK 1 = ARG STACK
  362:		N      000A	TXAH	EQU	10		;R2 BANK 1 = TEXT POINTER HIGH
  363:					;
  364:					; Now five temporary locations that are used by basic.
  365:					;
  366:		N      000B	TEMP1	EQU	11
  367:		N      000C	TEMP2	EQU	12
  368:		N      000D	TEMP3	EQU	13
  369:		N      000E	TEMP4	EQU	14
  370:		N      000F	TEMP5	EQU	15
  371:					;
  372:					; Register bank 2 contains the read text pointer
  373:					; and the control stack pointer.
  374:					;
  375:		N      0010	RTXAL	EQU	16		;R0 BANK 2 = READ TEXT POINTER LOW
  376:		N      0011	CSTKA	EQU	17		;R1 BANK 2 = CONTROL STACK POINTER
  377:		N      0012	RTXAH	EQU	18		;R2 BANK 2 = READ TEXT POINTER HIGH
  378:					;
  379:					; Now some internal system equates.
  380:					;
  381:		N      0013	BOFAH	EQU	19		;START OF THE BASIC PROGRAM, HIGH BYTE
  382:		N      0014	BOFAL	EQU	20		;START OF THE BASIC PROGRAM, LOW BYTE
  383:		N      0015	NULLCT	EQU	21		;NULL COUNT
  384:		N      0016	PHEAD	EQU	22		;PRINT HEAD POSITION
  385:		N      0017	FORMAT	EQU	23
  386:					;
  387:					; Register bank 3 is for the user and can be loaded
  388:					; by basic
  389:					;
  390:					;
  391:					;
  392:					; Now everything else is used by basic.
  393:					; First the bit locations, these use bytes 34, 35, 36, 37 and 38
  394:					;
  395:		N	 10	OTS		BIT	16	;34.0-ON TIME INSTRUCTION EXECUTED
  396:		N	 11	INPROG		BIT	17	;34.1-INTERRUPT IN PROCESS
  397:		N	 12	INTBIT		BIT	18	;34.2-INTERRUPT SET BIT
  398:		N	 13	ON_ERR		BIT	19	;34.3-ON ERROR EXECUTED
  399:		N	 14	OTI		BIT	20	;34.4-ON TIME INTERRUPT IN PROGRESS
  400:		N	 15	LINEB		BIT	21	;34.5-LINE CHANGE OCCURED
  401:		N	 16	INTPEN		BIT	22	;34.6-INTERRUPT PENDING BIT
  402:		N	 17	CONB		BIT	23	;34.7-CAN CONTINUE IF SET
  403:		N	 18	GTRD		BIT	24	;35.0-READ GET LOCATION
  404:		N	 19	LPB		BIT	25	;35.1-PRINT TO LINE PRINTER PORT
  405:		N	 1A	CKS_B		BIT	26	;35.2-FOR PWM INTERRUPT
  406:		N	 1B	COB		BIT	27	;35.3-CONSOLE OUT BIT
  407:								;     0 = SERIAL PORT
  408:								;     1 = LINE PRINTER
  409:		N	 1C	COUB		BIT	28	;35.4-USER CONSOLE OUT BIT
  410:								;     0 = SERIAL PORT
  411:								;     1 = USER DRIVER
  412:		N	 1D	INBIT		BIT	29	;35.5-INITIALIZATION BIT
  413:		N	 1E	CIUB		BIT	30	;35.6-USER CONSOLE IN BIT
  414:								;     0 = SERIAL PORT
  415:								;     1 = USER ROUTINE
  416:		N	 1F	SPINT		BIT	31	;35.7-SERIAL PORT INTERRUPT
  417:		N	 20	STOPBIT 	BIT	32	;36.0-PROGRAM STOP ENCOUNTERED
  418:		N	 21	U_IDL		BIT	33	;36.1-USER IDLE BREAK
  419:		N	 22	INP_B		BIT	34	;36.2-SET DURING INPUT INSTRUCTION
  420:				;DCMPXZ 	BIT	35	;36.3-DCMPX ZERO FLAG
  421:		N	 24	ARGF		BIT	36	;36.4-ARG STACK HAS A VALUE
  422:		N	 25	RETBIT		BIT	37	;36.5-RET FROM INTERRUPT EXECUTED
  423:		N	 26	I_T0		BIT	38	;36.6-TRAP INTERRUPT ZERO TO MON
  424:		N	 27	UPB		BIT	39	;36.7-SET WHEN @ IS VALID
  425:
  426:				;
  427:				;*****************************************************************************
  428:				;****** Sorry - but the ego message had to be disabled ***********************
  429:				;
  430:				;JKBIT		BIT	40	;37.0-WB TRIGGER We use the bit for detect
  431:				;
  432:		N	 28	mul_underflow	BIT	40	;37.0-mul_limit_case
  433:				;
  434:				;*****************************************************************************
  435:				;
  436:		N	 29	ENDBIT		BIT	41	;37.1-GET END OF PROGRAM
  437:		N	 2A	UBIT		BIT	42	;37.2-FOR DIM STATEMENT
  438:		N	 2B	ISAV		BIT	43	;37.3-SAVE INTERRUPT STATUS
  439:		N	 2C	BO		BIT	44	;37.4-BUBBLE OUTPUT
  440:		N	 2D	XBIT		BIT	45	;37.5-EXTERNAL PROGRAM PRESENT
  441:		N	 2E	C_BIT		BIT	46	;37.6-SET WHEN CLOCK RUNNING
  442:		N	 2F	DIRF		BIT	47	;37.7-DIRECT INPUT MODE
  443:		N	 30	NO_C		BIT	48	;38.0-NO CONTROL C
  444:		N	 31	DRQ		BIT	49	;38.1-DMA ENABLED
  445:		N	 32	BI		BIT	50	;38.2-BUBBLE INPUT
  446:				;
  447:				;*****************************************************************************
  448:				;****** Disable Intel programming for to get room ****************************
  449:				;
  450:				;INTELB 	BIT	51	;38.3-INTELLIGENT PROM PROGRAMMING
  451:				;
  452:				;*****************************************************************************
  453:				;
  454:		N	 34	C0ORX1		BIT	52	;38.4-PRINT FROM ROM OR RAM
  455:		N	 35	CNT_S		BIT	53	;38.5-CONTROL S ENCOUNTERED
  456:		N	 36	ZSURP		BIT	54	;38.6-ZERO SUPRESS
  457:		N	 37	HMODE		BIT	55	;38.7-HEX MODE PRINT
  458:		B	 97	LP		BIT	P1.7	;SOFTWARE LINE PRINTER
  459:		B	 96	DACK		BIT	P1.6	;DMA ACK
  460:				;*****************************************************************************
  461:				;
  462:				;PROMV		BIT	P1.5	;TURN ON PROM VOLTAGE
  463:				;PROMP		BIT	P1.4	;PROM PULSE
  464:				;ALED		BIT	P1.3	;ALE DISABLE
  465:				;
  466:				;*****************************************************************************
  467:		B	 92	T_BIT		BIT	P1.2	;I/O TOGGLE BIT
  468:		N	 DF	BD		BIT	0DFH	;Baudrategenerator 805x7,x5
  469:					;
  470:					;
  471:					; The next location is a bit addressable byte counter
  472:					;
  473:		N      0027	BABC	EQU	39
  474:					;
  475:					; Now floating point and the other temps
  476:					;
  477:					; FP Uses to locations 03CH
  478:					;
  479:					; Now the stack designators.
  480:					;
  481:		N      003E	SPSAV	EQU	3EH
  482:		N      003F	S_LEN	EQU	3FH
  483:		N      0040	T_HH	EQU	40H
  484:		N      0041	T_LL	EQU	41H
  485:		N      0042	INTXAH	EQU	42H
  486:		N      0043	INTXAL	EQU	43H
  487:		N      0045	MT1	EQU	45H
  488:		N      0046	MT2	EQU	46H
  489:		N      0047	MILLIV	EQU	47H		;Real Time Clock 5 millisec.
  490:		N      0048	TVH	EQU	48H		;Real Time Clock high byte
  491:		N      0049	TVL	EQU	49H		;Real Time Clock low byte
  492:		N      004A	SAVE_T	EQU	4AH
  493:		N      004B	SP_H	EQU	4BH		;SERIAL PORT TIME OUT
  494:		N      004C	SP_L	EQU	4CH
  495:		N      004D	CMNDSP	EQU	4DH		;SYSTEM STACK POINTER
  496:		N      0087	PCON0	EQU	87H		;PCON SFR
  497:		N      00AA	S0RELL	EQU	0AAH		;S0RELL 805x7A SFR
  498:		N      00BA	S0RELH	EQU	0BAH		;S0RELH 805x7A SFR
  499:		N      00CB	RCAPH2	EQU	0CBH		;RCAPH2 8052 SFR
  500:		N      00CA	RCAPL2	EQU	0CAH		;RCAPL2 8052 SFR
  501:		N      00D8	ADCON	EQU	0D8H		;ADCON 805xx SFR
  502:		N      00DA	DAPR	EQU	0DAH		;DAPR 805xx SFR
  503:		N      00FF	IRAMTOP EQU	0FFH		;TOP OF RAM
  504:		N      00FE	STACKTP EQU	0FEH		;ARG AND CONTROL STACK TOPS
  505:					;
  506:					; The character equates
  507:					;
  508:		N      000D	CR	EQU	0DH		;CARRIAGE RETURN
  509:		N      000A	LF	EQU	0AH		;LINE FEED
  510:		N      0007	BELL	EQU	07H		;BELL CHARACTER
  511:		N      0008	BS	EQU	08H		;BACK SPACE
  512:		N      0003	CNTRLC	EQU	03H		;CONTROL C
  513:		N      0004	CNTRLD	EQU	04H		;CONTROL D
  514:		N      0000	NULL	EQU	00H		;NULL
  515:					;
  516:					; The new baud rate constants
  517:					;
  518:		N      00B2	B4800	EQU	0B2H		;Timervalue for 4800 baud
  519:		N      00DC	B9600	EQU	0DCH		;Timervalue for 9600 baud
  520:					;
  521:					;
  522:					; The internal system equates
  523:					;
  524:		N      0049	LINLEN	EQU	73		;THE LENGTH OF AN INPUT LINE
  525:		N      0001	EOF	EQU	01		;END OF FILE CHARACTER
  526:		N      0001	ASTKAH	EQU	01		;ASTKA IS IN PAGE 1 OF RAM
  527:		N      0000	CSTKAH	EQU	00		;CSTKA IS IN PAGE 0 OF RAM
  528:		N      0001	FTYPE	EQU	01		;CONTROL STACK "FOR"
  529:		N      0002	GTYPE	EQU	02		;CONTROL STACK "GOSUB"
  530:		N      0003	DTYPE	EQU	03		;DO-WHILE/UNTIL TYPE
  531:
  532:				;ROMADR	EQU	8000H		;LOCATION OF ROM
  533:
  534:		N      5000	ROMADR	EQU	5000H		;LOCATION OF ROM
  535:
  536:					;
  537:					; The floating point equates
  538:					;
  539:		N      0006	FPSIZ	EQU	6		;NO. OF BYTES IN A FLOATING NUM
  540:		N      0004	DIGIT	EQU	FPSIZ-2 	;THE MANTISSA OF A FLOATING NUM
  541:		N      0009	STESIZ	EQU	FPSIZ+3 	;SIZE OF SYMBOL ADJUSTED TABLE ELEMENT
  542:				;FP_BASE EQU	 1993H		 ;BASE OF FLOATING POINT ROUTINES
  543:		N      0200	PSTART	EQU	512		;START OF A PROGRAM IN RAM
  544:		N      0011	FSIZE	EQU	FPSIZ+FPSIZ+2+2+1
  545:					;
  546:					;**************************************************************
  547:					;
  548:	  0047			USENT:	; User entry jump table
  549:					;
  550:					;**************************************************************
  551:					;
  552:	  0047	17 94			DW	CMND1		;(00, 00H)COMMAND MODE JUMP
  553:	  0049	12 30			DW	IFIX		;(01, 01H)CONVERT FP TO INT
  554:	  004B	0F E8			DW	PUSHAS		;(02, 02H)PUSH VALUE ONTO ARG STACK
  555:	  004D	0F DE			DW	POPAS		;(03, 03H)POP VALUE OFF ARG STACK
  556:	  004F	04 C7			DW	PG1		;(04, 04H)PROGRAM A PROM
  557:	  0051	06 E2			DW	INLINE		;(05, 05H)INPUT A LINE
  558:	  0053	06 C9			DW	UPRNT		;(06, 06H)PRINT A LINR
  559:	  0055	06 AF			DW	CRLF		;(07, 07H)OUTPUT A CRLF
  560:					;
  561:					;**************************************************************
  562:					;
  563:					; This is the operation jump table for arithmetics
  564:					;
  565:					;**************************************************************
  566:					;
  567:	  0057	13 B9		OPTAB:	DW	ALPAR		;(08, 08H)LEFT PAREN
  568:	  0059	13 38			DW	AEXP		;(09, 09H)EXPONENTAION
  569:	  005B	11 BD			DW	AMUL		;(10, 0AH)FP MUL
  570:	  005D	17 4E			DW	AADD		;(11, 0BH)FLOATING POINT ADD
  571:	  005F	14 17			DW	ADIV		;(12, 0CH)FLOATING POINT DIVIDE
  572:	  0061	17 29			DW	ASUB		;(13, 0DH)FLOATING POINT SUBTRACTION
  573:	  0063	14 A5			DW	AXRL		;(14, 0EH)XOR
  574:	  0065	14 91			DW	AANL		;(15, 0FH)AND
  575:	  0067	14 9A			DW	AORL		;(16, 10H)OR
  576:	  0069	13 AE			DW	ANEG		;(17, 11H)NEGATE
  577:	  006B	13 E8			DW	AEQ		;(18, 12H)EQUAL
  578:	  006D	13 F4			DW	AGE		;(19, 13H)GREATER THAN OR EQUAL
  579:	  006F	13 F8			DW	ALE		;(20, 14H)LESS THAN OR EQUAL
  580:	  0071	13 EE			DW	ANE		;(21, 15H)NOT EQUAL
  581:	  0073	13 E3			DW	ALT		;(22, 16H)LESS THAN
  582:	  0075	13 D2			DW	AGT		;(23, 17H)GREATER THAN
  583:					;
  584:					;***************************************************************
  585:					;
  586:					; This is the jump table for unary operators
  587:					;
  588:					;***************************************************************
  589:					;
  590:	  0077	13 9C			DW	AABS		;(24, 18H)ABSOLUTE VALUE
  591:	  0079	13 7A			DW	AINT		;(25, 19H)INTEGER OPERATOR
  592:	  007B	13 A2			DW	ASGN		;(26, 1AH)SIGN OPERATOR
  593:	  007D	14 A3			DW	ANOT		;(27, 1BH)ONE'S COMPLEMENT
  594:	  007F	11 7A			DW	ACOS		;(28, 1CH)COSINE
  595:	  0081	11 DD			DW	ATAN		;(29, 1DH)TANGENT
  596:	  0083	11 7E			DW	ASIN		;(30, 1EH)SINE
  597:	  0085	12 9A			DW	ASQR		;(31, 1FH)SQUARE ROOT
  598:	  0087	13 BA			DW	ACBYTE		;(32, 20H)READ CODE
  599:	  0089	13 34			DW	AETOX		;(33, 21H)E TO THE X
  600:	  008B	11 ED			DW	AATAN		;(34, 22H)ARC TANGENT
  601:	  008D	12 CD			DW	ALN		;(35, 23H)NATURAL LOG
  602:	  008F	13 C3			DW	ADBYTE		;(36, 24H)READ DATA MEMORY
  603:	  0091	13 CB			DW	AXBYTE		;(37, 25H)READ EXTERNAL MEMORY
  604:	  0093	14 8C			DW	PIPI		;(38, 26H)PI
  605:	  0095	13 FE			DW	ARND		;(39, 27H)RANDOM NUMBER
  606:	  0097	14 B6			DW	AGET		;(40, 28H)GET INPUT CHARACTER
  607:	  0099	17 1E			DW	AFREE		;(41, 29H)COMPUTE #BYTES FREE
  608:	  009B	17 2E			DW	ALEN		;(42, 2AH) COMPUTE LEN OF PORGRAM
  609:	  009D	0F E4			DW	AXTAL		;(43, 2BH) CRYSTAL
  610:	  009F	16 5C			DW	PMTOP		;(44, 2CH)TOP OF MEMORY
  611:	  00A1	17 36			DW	ATIME		;(45, 2DH) TIME
  612:	  00A3	14 C6			DW	A_IE		;(46, 2EH) IE
  613:	  00A5	14 CA			DW	A_IP		;(47, 2FH) IP
  614:	  00A7	14 CE			DW	ATIM0		;(48, 30H) TIMER 0
  615:	  00A9	14 D4			DW	ATIM1		;(49, 31H) TIMER 1
  616:	  00AB	14 DA			DW	ATIM2		;(50, 32H) TIMER 2
  617:	  00AD	14 E0			DW	AT2CON		;(51, 33H) T2CON
  618:	  00AF	14 E4			DW	ATCON		;(52, 34H) TCON
  619:	  00B1	14 E8			DW	ATMOD		;(53, 35H) ATMOD
  620:	  00B3	14 EC			DW	ARCAP2		;(54, 36H) RCAP2
  621:	  00B5	14 F2			DW	AP1		;(55, 37H) P1
  622:	  00B7	14 F6			DW	APCON		;(56, 38H) PCON
  623:	  00B9	0F 4E			DW	EXPRB		;(57, 39H) EVALUATE AN EXPRESSION
  624:	  00BB	16 69			DW	AXTAL1		;(58, 3AH) CALCULATE CRYSTAL
  625:	  00BD	14 FD			DW	LINE		;(59, 3BH) EDIT A LINE
  626:	  00BF	15 C7			DW	PP		;(60, 3CH) PROCESS A LINE
  627:	  00C1	10 AD			DW	UPPL0		;(61, 3DH) UNPROCESS A LINE
  628:	  00C3	0D 70			DW	VAR		;(62, 3EH) FIND A VARIABLE
  629:	  00C5	0E D8			DW	GC		;(63, 3FH) GET A CHARACTER
  630:	  00C7	0E E0			DW	GCI		;(64, 40H) GET CHARACTER AND INCREMENT
  631:	  00C9	07 9B			DW	INCHAR		;(65, 41H) INPUT A CHARACTER
  632:	  00CB	08 0C			DW	CRUN		;(66, 42H) RUN A PROGRAM
  633:				;
  634:				;*****************************************************************************
  635:				;****** OPBYTE 43H for POP ***************************************************
  636:				;****** Boehling 1 ***********************************************************
  637:				;
  638:	  00CD	0A 87			dw	SPOP		;(67, 43H) POP a value to a variable
  639:				;
  640:				;*****************************************************************************
  641:				;
  642:
  643:	  00CF	01		OPBOL:	DB	1		;
  644:					;
  645:	  00D0	0F			DB	15		;LEFT PAREN
  646:	  00D1	0E			DB	14		;EXPONENTIAN **
  647:	  00D2	0A			DB	10		;MUL
  648:	  00D3	08			DB	8		;ADD
  649:	  00D4	0A			DB	10		;DIVIDE
  650:	  00D5	08			DB	8		;SUB
  651:	  00D6	03			DB	3		;XOR
  652:	  00D7	05			DB	5		;AND
  653:	  00D8	04			DB	4		;OR
  654:	  00D9	0C			DB	12		;NEGATE
  655:	  00DA	06			DB	6		;EQ
  656:	  00DB	06			DB	6		;GT
  657:	  00DC	06			DB	6		;LT
  658:	  00DD	06			DB	6		;NE
  659:	  00DE	06			DB	6		;LE
  660:	  00DF	06			DB	6		;GE
  661:					;
  662:	  00E0	0F		UOPBOL: DB	15		;AABS
  663:	  00E1	0F			DB	15		;AAINT
  664:	  00E2	0F			DB	15		;ASGN
  665:	  00E3	0F			DB	15		;ANOT
  666:	  00E4	0F			DB	15		;ACOS
  667:	  00E5	0F			DB	15		;ATAN
  668:	  00E6	0F			DB	15		;ASIN
  669:	  00E7	0F			DB	15		;ASQR
  670:	  00E8	0F			DB	15		;ACBYTE
  671:	  00E9	0F			DB	15		;E TO THE X
  672:	  00EA	0F			DB	15		;AATAN
  673:	  00EB	0F			DB	15		;NATURAL LOG
  674:	  00EC	0F			DB	15		;DBYTE
  675:	  00ED	0F			DB	15		;XBYTE
  676:					;
  677:					;***************************************************************
  678:					;
  679:					; The ASCII printed messages.
  680:					;
  681:					;***************************************************************
  682:					;
  683:	  00EE	53 54 4F 50	STP:	DB	'STOP"'
	  00F2	22
  684:					;
  685:	  00F3	54 52 59 20	IAN:	DB	'TRY AGAIN"'
	  00F7	41 47 41 49
	  00FB	4E 22
  686:					;
  687:	  00FD	52 45 41 44	RDYS:	DB	'READY"'
	  0101	59 22
  688:					;
  689:	  0103	20 2D 20 49	INS:	DB	' - IN LINE "'
	  0107	4E 20 4C 49
	  010B	4E 45 20 22
  690:					;
  691:					;**************************************************************
  692:					;
  693:					; This is the command jump table
  694:					;
  695:					;**************************************************************
  696:					;
  697:	  010F	08 0C		CMNDD:	DW	CRUN		;RUN
  698:	  0111	10 5B			DW	CLIST		;LIST
  699:	  0113	0B 12			DW	CNULL		;NULL
  700:	  0115	06 66			DW	CNEW		;NEW
  701:	  0117	18 4B			DW	CCONT		;CONTINUE
  702:	  0119	04 94			DW	CPROG		;PROGRAM A PROM
  703:	  011B	17 80			DW	CXFER		;TRANSFER FROM ROM TO RAM
  704:	  011D	17 8C			DW	CRAM		;RAM MODE
  705:	  011F	05 46			DW	CROM		;ROM MODE
  706:				;
  707:				;*****************************************************************************
  708:				;****** Disable Intel programming for to get room ****************************
  709:				;
  710:				;	DW	CIPROG		;INTELLIGENT PROM PROGRAMMING
  711:				;
  712:				;*****************************************************************************
  713:				;
  714:	  0121	05 0A			dw	CERASE		;Erase an EEPROM
  715:				;
  716:					;***************************************************************
  717:					;
  718:					; This is the statement jump table.
  719:					;
  720:					;**************************************************************
  721:					;
  722:	  0123			STATD:	;
  723:	  0123	09 78			DW	SLET		;LET		80H
  724:	  0125	06 99			DW	SCLR		;CLEAR		81H
  725:	  0127	0A 80			DW	SPUSH		;PUSH VAR	82H
  726:	  0129	0A B4			DW	SGOTO		;GO TO		83H
  727:	  012B	16 93			DW	STONE		;TONE		84H
  728:	  012D	0C 33			DW	SPH0		;PRINT MODE 0	85H
  729:	  012F	19 3B			DW	SUI		;USER INPUT	86H
  730:	  0131	19 40			DW	SUO		;USER OUTPUT	87H
  731:	  0133	0A 87			DW	SPOP		;POP VAR	88H
  732:	  0135	0C 37			DW	SPRINT		;PRINT		89H
  733:	  0137	0E 6E			DW	SCALL		;CALL		8AH
  734:	  0139	0D 6C			DW	SDIMX		;DIMENSION	8BH
  735:	  013B	06 16			DW	STRING		;STRING ALLO	8CH
  736:	  013D	17 06			DW	SBAUD		;SET BAUD	8DH
  737:	  013F	19 25			DW	SCLOCK		;CLOCK		8EH
  738:	  0141	0C 35			DW	SPH1		;PRINT MODE 1	8FH
  739:					;
  740:					; No direct mode from here on
  741:					;
  742:	  0143	08 62			DW	SSTOP		;STOP		90H
  743:	  0145	0E 61			DW	SOT		;ON TIME	91H
  744:	  0147	14 26			DW	SONEXT		;ON EXT INT	92H
  745:	  0149	0B 18			DW	SRETI		;RET FROM INT	93H
  746:	  014B	0F 10			DW	S_DO		;DO		94H
  747:	  014D	0B D8			DW	SRESTR		;RESTOR 	95H
  748:	  014F	0F 07			DW	WCR		;REM		96H
  749:	  0151	0B 69			DW	SNEXT		;NEXT		97H
  750:	  0153	14 1C			DW	SONERR		;ON ERROR	98H
  751:	  0155	0C F6			DW	S_ON		;ON		99H
  752:	  0157	0E 00			DW	SINPUT		;INPUT		9AH
  753:	  0159	0B ED			DW	SREAD		;READ		9BH
  754:	  015B	0E F7			DW	FINDCR		;DATA		9CH
  755:	  015D	0B 1A			DW	SRETRN		;RETURN 	9DH
  756:	  015F	0A 90			DW	SIF		;IF		9EH
  757:	  0161	0B 37			DW	SGOSUB		;GOSUB		9FH
  758:	  0163	0A 46			DW	SFOR		;FOR		A0H
  759:	  0165	0B 06			DW	SWHILE		;WHILE		A1H
  760:	  0167	0B 0B			DW	SUNTIL		;UNTIL		A2H
  761:	  0169	17 94			DW	CMND1		;END		A3H
  762:	  016B	18 68			DW	I_DL		;IDLE		A4H
  763:	  016D	0F F0			DW	ST_A		;STORE AT	A5H
  764:	  016F	0F F4			DW	LD_A		;LOAD AT	A6H
  765:	  0171	05 02			DW	PGU		;PGM		A7H
  766:	  0173	07 CA			DW	RROM		;RUN A ROM	A9H
  767:					;
  768:					;**************************************************************
  769:					;
  770:	  0175			TOKTAB: ; This is the basic token table
  771:					;
  772:					;**************************************************************
  773:					;
  774:					; First the tokens for statements
  775:					;
  776:	  0175	80			DB	80H		;LET TOKEN
  777:	  0176	4C 45 54		DB	'LET'
  778:					;
  779:	  0179	81			DB	81H		;CLEAR TOKEN
  780:	  017A	43 4C 45 41		DB	'CLEAR'
	  017E	52
  781:					;
  782:	  017F	82			DB	82H		;PUSH TOKEN
  783:	  0180	50 55 53 48		DB	'PUSH'
  784:					;
  785:		N      0083	T_GOTO	EQU	83H
  786:					;
  787:	  0184	83			DB	83H		;GO TO TOKEN
  788:	  0185	47 4F 54 4F		DB	'GOTO'
  789:					;
  790:	  0189	84			DB	84H		;TOGGLE TOKEN
  791:	  018A	50 57 4D		DB	'PWM'
  792:					;
  793:	  018D	85			DB	85H		;PRINT HEX MODE 0
  794:	  018E	50 48 30 2E		DB	'PH0.'
  795:					;
  796:	  0192	86			DB	86H		;USER IN TOKEN
  797:	  0193	55 49			DB	'UI'
  798:					;
  799:	  0195	87			DB	87H		;USER OUT TOKEN
  800:	  0196	55 4F			DB	'UO'
  801:					;
  802:	  0198	88			DB	88H		;POP TOKEN
  803:	  0199	50 4F 50		DB	'POP'
  804:					;
  805:	  019C	89			DB	89H		;PRINT TOKEN
  806:	  019D	50 52 49 4E		DB	'PRINT'
	  01A1	54
  807:	  01A2	89			DB	89H
  808:	  01A3	50 2E			DB	'P.'            ;P. ALSO MEANS PRINT
  809:	  01A5	89			DB	89H		;? ALSO
  810:	  01A6	3F			DB	'?'
  811:					;
  812:	  01A7	8A			DB	8AH		;CALL TOKEN
  813:	  01A8	43 41 4C 4C		DB	'CALL'
  814:					;
  815:	  01AC	8B			DB	8BH		;DIMENSION TOKEN
  816:	  01AD	44 49 4D		DB	'DIM'
  817:					;
  818:	  01B0	8C			DB	8CH		;STRING TOKEN
  819:	  01B1	53 54 52 49		DB	'STRING'
	  01B5	4E 47
  820:					;
  821:	  01B7	8D			DB	8DH		;SET BAUD RATE
  822:	  01B8	42 41 55 44		DB	'BAUD'
  823:					;
  824:	  01BC	8E			DB	8EH		;CLOCK
  825:	  01BD	43 4C 4F 43		DB	'CLOCK'
	  01C1	4B
  826:					;
  827:	  01C2	8F			DB	8FH		;PRINT HEX MODE 1
  828:	  01C3	50 48 31 2E		DB	'PH1.'
  829:					;
  830:		N      0090	T_STOP	EQU	90H		;STOP TOKEN
  831:	  01C7	90			DB	T_STOP
  832:	  01C8	53 54 4F 50		DB	'STOP'
  833:					;
  834:		N      0090	T_DIR	EQU	T_STOP		;NO DIRECT FROM HERE ON
  835:					;
  836:	  01CC	91			DB	T_STOP+1	;ON TIMER INTERRUPT
  837:	  01CD	4F 4E 54 49		DB	'ONTIME'
	  01D1	4D 45
  838:					;
  839:	  01D3	92			DB	T_STOP+2	;ON EXTERNAL INTERRUPT
  840:	  01D4	4F 4E 45 58		DB	'ONEX1'
	  01D8	31
  841:					;
  842:	  01D9	93			DB	T_STOP+3	;RETURN FROM INTERRUPT
  843:	  01DA	52 45 54 49		DB	'RETI'
  844:					;
  845:	  01DE	94			DB	T_STOP+4	;DO TOKEN
  846:	  01DF	44 4F			DB	'DO'
  847:					;
  848:	  01E1	95			DB	T_STOP+5	;RESTORE TOKEN
  849:	  01E2	52 45 53 54		DB	'RESTORE'
	  01E6	4F 52 45
  850:					;
  851:		N      0096	T_REM	EQU	T_STOP+6	;REMARK TOKEN
  852:	  01E9	96			DB	T_REM
  853:	  01EA	52 45 4D		DB	'REM'
  854:					;
  855:	  01ED	97			DB	T_REM+1 	;NEXT TOKEN
  856:	  01EE	4E 45 58 54		DB	'NEXT'
  857:					;
  858:	  01F2	98			DB	T_REM+2 	;ON ERROR TOKEN
  859:	  01F3	4F 4E 45 52		DB	'ONERR'
	  01F7	52
  860:					;
  861:	  01F8	99			DB	T_REM+3 	;ON TOKEN
  862:	  01F9	4F 4E			DB	'ON'
  863:					;
  864:	  01FB	9A			DB	T_REM+4 	;INPUT
  865:	  01FC	49 4E 50 55		DB	'INPUT'
	  0200	54
  866:					;
  867:	  0201	9B			DB	T_REM+5 	;READ
  868:	  0202	52 45 41 44		DB	'READ'
  869:					;
  870:		N      009C	T_DATA	EQU	T_REM+6 	;DATA
  871:	  0206	9C			DB	T_DATA
  872:	  0207	44 41 54 41		DB	'DATA'
  873:					;
  874:	  020B	9D			DB	T_DATA+1	;RETURN
  875:	  020C	52 45 54 55		DB	'RETURN'
	  0210	52 4E
  876:					;
  877:	  0212	9E			DB	T_DATA+2	;IF
  878:	  0213	49 46			DB	'IF'
  879:					;
  880:		N      009F	T_GOSB	EQU	T_DATA+3	;GOSUB
  881:	  0215	9F			DB	T_GOSB
  882:	  0216	47 4F 53 55		DB	'GOSUB'
	  021A	42
  883:					;
  884:	  021B	A0			DB	T_GOSB+1	;FOR
  885:	  021C	46 4F 52		DB	'FOR'
  886:					;
  887:	  021F	A1			DB	T_GOSB+2	;WHILE
  888:	  0220	57 48 49 4C		DB	'WHILE'
	  0224	45
  889:					;
  890:	  0225	A2			DB	T_GOSB+3	;UNTIL
  891:	  0226	55 4E 54 49		DB	'UNTIL'
	  022A	4C
  892:					;
  893:	  022B	A3			DB	T_GOSB+4	;END
  894:	  022C	45 4E 44		DB	'END'
  895:					;
  896:		N      00A4	T_LAST	EQU	T_GOSB+5	;LAST INITIAL TOKEN
  897:					;
  898:		N      00A4	T_TAB	EQU	T_LAST		;TAB TOKEN
  899:	  022F	A4			DB	T_TAB
  900:	  0230	54 41 42		DB	'TAB'
  901:					;
  902:		N      00A5	T_THEN	EQU	T_LAST+1	;THEN TOKEN
  903:	  0233	A5			DB	T_THEN
  904:	  0234	54 48 45 4E		DB	'THEN'
  905:					;
  906:		N      00A6	T_TO	EQU	T_LAST+2	;TO TOKEN
  907:	  0238	A6			DB	T_TO
  908:	  0239	54 4F			DB	'TO'
  909:					;
  910:		N      00A7	T_STEP	EQU	T_LAST+3	;STEP TOKEN
  911:	  023B	A7			DB	T_STEP
  912:	  023C	53 54 45 50		DB	'STEP'
  913:					;
  914:		N      00A8	T_ELSE	EQU	T_LAST+4	;ELSE TOKEN
  915:	  0240	A8			DB	T_ELSE
  916:	  0241	45 4C 53 45		DB	'ELSE'
  917:					;
  918:		N      00A9	T_SPC	EQU	T_LAST+5	;SPACE TOKEN
  919:	  0245	A9			DB	T_SPC
  920:	  0246	53 50 43		DB	'SPC'
  921:					;
  922:		N      00AA	T_CR	EQU	T_LAST+6
  923:	  0249	AA			DB	T_CR
  924:	  024A	43 52			DB	'CR'
  925:					;
  926:	  024C	AB			DB	T_CR+1
  927:	  024D	49 44 4C 45		DB	'IDLE'
  928:					;
  929:	  0251	AC			DB	T_CR+2
  930:	  0252	53 54 40		DB	'ST@'
  931:					;
  932:	  0255	AD			DB	T_CR+3
  933:	  0256	4C 44 40		DB	'LD@'
  934:					;
  935:	  0259	AE			DB	T_CR+4
  936:	  025A	50 47 4D		DB	'PGM'
  937:					;
  938:	  025D	AF			DB	T_CR+5
  939:	  025E	52 52 4F 4D		DB	'RROM'
  940:					;
  941:					; Operator tokens
  942:					;
  943:		N      00E0	T_LPAR	EQU	0E0H		;LEFT PAREN
  944:	  0262	E0			DB	T_LPAR
  945:	  0263	28			DB	'('
  946:					;
  947:	  0264	E1			DB	T_LPAR+1	;EXPONENTIAN
  948:	  0265	2A 2A			DB	'**'
  949:					;
  950:	  0267	E2			DB	T_LPAR+2	;FP MULTIPLY
  951:	  0268	2A			DB	'*'
  952:					;
  953:		N      00E3	T_ADD	EQU	T_LPAR+3
  954:	  0269	E3			DB	T_LPAR+3	;ADD TOKEN
  955:	  026A	2B			DB	'+'
  956:					;
  957:	  026B	E4			DB	T_LPAR+4	;DIVIDE TOKEN
  958:	  026C	2F			DB	'/'
  959:					;
  960:		N      00E5	T_SUB	EQU	T_LPAR+5	;SUBTRACT TOKEN
  961:	  026D	E5			DB	T_SUB
  962:	  026E	2D			DB	'-'
  963:					;
  964:	  026F	E6			DB	T_LPAR+6	;LOGICAL EXCLUSIVE OR
  965:	  0270	2E 58 4F 52		DB	'.XOR.'
	  0274	2E
  966:					;
  967:	  0275	E7			DB	T_LPAR+7	;LOGICAL AND
  968:	  0276	2E 41 4E 44		DB	'.AND.'
	  027A	2E
  969:					;
  970:	  027B	E8			DB	T_LPAR+8	;LOGICAL OR
  971:	  027C	2E 4F 52 2E		DB	'.OR.'
  972:					;
  973:		N      00E9	T_NEG	EQU	T_LPAR+9
  974:					;
  975:		N      00EA	T_EQU	EQU	T_LPAR+10	;EQUAL
  976:	  0280	EA			DB	T_EQU
  977:	  0281	3D			DB	'='
  978:					;
  979:	  0282	EB			DB	T_LPAR+11	;GREATER THAN OR EQUAL
  980:	  0283	3E 3D			DB	'>='
  981:					;
  982:	  0285	EC			DB	T_LPAR+12	;LESS THAN OR EQUAL
  983:	  0286	3C 3D			DB	'<='
  984:					;
  985:	  0288	ED			DB	T_LPAR+13	;NOT EQUAL
  986:	  0289	3C 3E			DB	'<>'
  987:					;
  988:	  028B	EE			DB	T_LPAR+14	;LESS THAN
  989:	  028C	3C			DB	'<'
  990:					;
  991:	  028D	EF			DB	T_LPAR+15	;GREATER THAN
  992:	  028E	3E			DB	'>'
  993:					;
  994:					;
  995:		N      00B0	T_UOP	EQU	0B0H		;UNARY OP BASE TOKEN
  996:					;
  997:	  028F	B0			DB	T_UOP		;ABS TOKEN
  998:	  0290	41 42 53		DB	'ABS'
  999:					;
 1000:	  0293	B1			DB	T_UOP+1 	;INTEGER TOKEN
 1001:	  0294	49 4E 54		DB	'INT'
 1002:					;
 1003:	  0297	B2			DB	T_UOP+2 	;SIGN TOKEN
 1004:	  0298	53 47 4E		DB	'SGN'
 1005:					;
 1006:	  029B	B3			DB	T_UOP+3 	;GET TOKEN
 1007:	  029C	4E 4F 54		DB	'NOT'
 1008:					;
 1009:	  029F	B4			DB	T_UOP+4 	;COSINE TOKEN
 1010:	  02A0	43 4F 53		DB	'COS'
 1011:					;
 1012:	  02A3	B5			DB	T_UOP+5 	;TANGENT TOKEN
 1013:	  02A4	54 41 4E		DB	'TAN'
 1014:					;
 1015:	  02A7	B6			DB	T_UOP+6 	;SINE TOKEN
 1016:	  02A8	53 49 4E		DB	'SIN'
 1017:					;
 1018:	  02AB	B7			DB	T_UOP+7 	;SQUARE ROOT TOKEN
 1019:	  02AC	53 51 52		DB	'SQR'
 1020:					;
 1021:	  02AF	B8			DB	T_UOP+8 	;CBYTE TOKEN
 1022:	  02B0	43 42 59		DB	'CBY'
 1023:					;
 1024:	  02B3	B9			DB	T_UOP+9 	;EXP (E TO THE X) TOKEN
 1025:	  02B4	45 58 50		DB	'EXP'
 1026:					;
 1027:	  02B7	BA			DB	T_UOP+10
 1028:	  02B8	41 54 4E		DB	'ATN'
 1029:					;
 1030:	  02BB	BB			DB	T_UOP+11
 1031:	  02BC	4C 4F 47		DB	'LOG'
 1032:					;
 1033:	  02BF	BC			DB	T_UOP+12	;DBYTE TOKEN
 1034:	  02C0	44 42 59		DB	'DBY'
 1035:					;
 1036:	  02C3	BD			DB	T_UOP+13	;XBYTE TOKEN
 1037:	  02C4	58 42 59		DB	'XBY'
 1038:					;
 1039:		N      00BE	T_ULAST EQU	T_UOP+14	;LAST OPERATOR NEEDING PARENS
 1040:					;
 1041:	  02C7	BE			DB	T_ULAST
 1042:	  02C8	50 49			DB	'PI'
 1043:					;
 1044:	  02CA	BF			DB	T_ULAST+1	;RND TOKEN
 1045:	  02CB	52 4E 44		DB	'RND'
 1046:					;
 1047:	  02CE	C0			DB	T_ULAST+2	;GET TOKEN
 1048:	  02CF	47 45 54		DB	'GET'
 1049:					;
 1050:	  02D2	C1			DB	T_ULAST+3	;FREE TOKEN
 1051:	  02D3	46 52 45 45		DB	'FREE'
 1052:					;
 1053:	  02D7	C2			DB	T_ULAST+4	;LEN TOKEN
 1054:	  02D8	4C 45 4E		DB	'LEN'
 1055:					;
 1056:		N      00C3	T_XTAL	EQU	T_ULAST+5	;CRYSTAL TOKEN
 1057:	  02DB	C3			DB	T_XTAL
 1058:	  02DC	58 54 41 4C		DB	'XTAL'
 1059:					;
 1060:		N      00C4	T_MTOP	EQU	T_ULAST+6	;MTOP
 1061:	  02E0	C4			DB	T_MTOP
 1062:	  02E1	4D 54 4F 50		DB	'MTOP'
 1063:					;
 1064:		N      00C6	T_IE	EQU	T_ULAST+8	;IE REGISTER
 1065:	  02E5	C6			DB	T_IE
 1066:	  02E6	49 45			DB	'IE'
 1067:					;
 1068:		N      00C7	T_IP	EQU	T_ULAST+9	;IP REGISTER
 1069:	  02E8	C7			DB	T_IP
 1070:	  02E9	49 50			DB	'IP'
 1071:					;
 1072:		N      00C8	TMR0	EQU	T_ULAST+10	;TIMER 0
 1073:	  02EB	C8			DB	TMR0
 1074:	  02EC	54 49 4D 45		DB	'TIMER0'
	  02F0	52 30
 1075:					;
 1076:		N      00C9	TMR1	EQU	T_ULAST+11	;TIMER 1
 1077:	  02F2	C9			DB	TMR1
 1078:	  02F3	54 49 4D 45		DB	'TIMER1'
	  02F7	52 31
 1079:					;
 1080:		N      00CA	TMR2	EQU	T_ULAST+12	;TIMER 2
 1081:	  02F9	CA			DB	TMR2
 1082:	  02FA	54 49 4D 45		DB	'TIMER2'
	  02FE	52 32
 1083:					;
 1084:		N      00C5	T_TIME	EQU	T_ULAST+7	;TIME
 1085:	  0300	C5			DB	T_TIME
 1086:	  0301	54 49 4D 45		DB	'TIME'
 1087:					;
 1088:		N      00CB	TT2C	EQU	T_ULAST+13	;T2CON
 1089:	  0305	CB			DB	TT2C
 1090:	  0306	54 32 43 4F		DB	'T2CON'
	  030A	4E
 1091:					;
 1092:		N      00CC	TTC	EQU	T_ULAST+14	;TCON
 1093:	  030B	CC			DB	TTC
 1094:	  030C	54 43 4F 4E		DB	'TCON'
 1095:					;
 1096:		N      00CD	TTM	EQU	T_ULAST+15	;TMOD
 1097:	  0310	CD			DB	TTM
 1098:	  0311	54 4D 4F 44		DB	'TMOD'
 1099:					;
 1100:		N      00CE	TRC2	EQU	T_ULAST+16	;RCAP2
 1101:	  0315	CE			DB	TRC2
 1102:	  0316	52 43 41 50		DB	'RCAP2'
	  031A	32
 1103:					;
 1104:		N      00CF	T_P1	EQU	T_ULAST+17	;P1
 1105:	  031B	CF			DB	T_P1
 1106:	  031C	50 4F 52 54		DB	'PORT1'
	  0320	31
 1107:					;
 1108:		N      00D0	T_PC	EQU	T_ULAST+18	;PCON
 1109:	  0321	D0			DB	T_PC
 1110:	  0322	50 43 4F 4E		DB	'PCON'
 1111:					;
 1112:		N      00D1	T_ASC	EQU	T_ULAST+19	;ASC TOKEN
 1113:	  0326	D1			DB	T_ASC
 1114:	  0327	41 53 43 28		DB	'ASC('
 1115:					;
 1116:		N      00D2	T_USE	EQU	T_ULAST+20	;USING TOKEN
 1117:	  032B	D2			DB	T_USE
 1118:	  032C	55 53 49 4E		DB	'USING('
	  0330	47 28
 1119:	  0332	D2			DB	T_USE
 1120:	  0333	55 2E 28		DB	'U.('
 1121:					;
 1122:		N      00D3	T_CHR	EQU	T_ULAST+21	;CHR TOKEN
 1123:	  0336	D3			DB	T_CHR
 1124:	  0337	43 48 52 28		DB	'CHR('
 1125:					;
 1126:		N      00F0	T_CMND	EQU	0F0H		;COMMAND BASE
 1127:					;
 1128:	  033B	F0			DB	0F0H		;RUN TOKEN
 1129:	  033C	52 55 4E		DB	'RUN'
 1130:					;
 1131:	  033F	F1			DB	0F1H		;LIST TOKEN
 1132:	  0340	4C 49 53 54		DB	'LIST'
 1133:					;
 1134:	  0344	F2			DB	0F2H		;NULL TOKEN
 1135:	  0345	4E 55 4C 4C		DB	'NULL'
 1136:					;
 1137:	  0349	F3			DB	0F3H		;NEW TOKEN
 1138:	  034A	4E 45 57		DB	'NEW'
 1139:					;
 1140:	  034D	F4			DB	0F4H		;CONTINUE TOKEN
 1141:	  034E	43 4F 4E 54		DB	'CONT'
 1142:					;
 1143:	  0352	F5			DB	0F5H		;PROGRAM TOKEN
 1144:	  0353	50 52 4F 47		DB	'PROG'
 1145:					;
 1146:	  0357	F6			DB	0F6H		;TRANSFER TOKEN
 1147:	  0358	58 46 45 52		DB	'XFER'
 1148:					;
 1149:	  035C	F7			DB	0F7H		;RAM MODE
 1150:	  035D	52 41 4D		DB	'RAM'
 1151:					;
 1152:	  0360	F8			DB	0F8H		;ROM MODE
 1153:	  0361	52 4F 4D		DB	'ROM'
 1154:				;
 1155:				;
 1156:				;*****************************************************************************
 1157:				;****** Disable Intel programming for to get room ****************************
 1158:				;
 1159:				;	DB	0F9H		;INTELLIGENT PROM PROGRAMMING
 1160:				;	DB	'FPROG'
 1161:				;
 1162:				;*****************************************************************************
 1163:				;****** New command "ERASE" to fill an EEPROM with 0FFH  *********************
 1164:				;****** Boehling 3 ***********************************************************
 1165:				;
 1166:	  0364	F9			db	0F9H		;Erase an EEPROM
 1167:	  0365	45 52 41 53		db	'ERASE'
	  0369	45
 1168:				;
 1169:				;*****************************************************************************
 1170:				;****** Karmann 2 Bugfix *****************************************************
 1171:				;
 1172:	  036A	FE			db	0feh		;dummy token and
 1173:	  036B	7F			db	07fh		;unused dummy char
 1174:				;
 1175:				;****** continue with original code: *****************************************
 1176:				;
 1177:	  036C	FF			DB	0FFH		;END OF TABLE
 1178:					;
 1179:	  036D	45 58 54 52	EIG:	DB	'EXTRA IGNORED"'
	  0371	41 20 49 47
	  0375	4E 4F 52 45
	  0379	44 22
 1180:					;
 1181:	  037B	41 2D 53 54	EXA:	DB	'A-STACK"'
	  037F	41 43 4B 22
 1182:					;
 1183:	  0383	43 2D 53 54	EXC:	DB	'C-STACK"'
	  0387	41 43 4B 22
 1184:					;
 1185:					;**************************************************************
 1186:					;
 1187:	  038B			CRST:	; This performs system initialzation, it was moved here so the
 1188:					; new power on reset functions could be tested in an 8751.
 1189:					;
 1190:					;**************************************************************
 1191:					;
 1192:					; First, initialize SFR's
 1193:					;
 1194:
 1195:					; turn display off
 1196:	  038B	E4			clr a
 1197:	  038C	90 82 02		mov dptr,#8202h
 1198:	  038F	F0			movx @dptr,a
 1199:	  0390	90 81 00		mov dptr,#8100h
 1200:	  0393	F0			movx @dptr,a
 1201:
 1202:
 1203:	  0394	75 98 5A	NCRST:	MOV	SCON,#5AH	;INITIALIZE SFR'S
 1204:				;
 1205:				;*****************************************************************************
 1206:				;****** Use XTAL up to 47 MHz ************************************************
 1207:				;****** Wulf 2 ***************************************************************
 1208:				;
 1209:				;	MOV	TMOD,#10H
 1210:				;
 1211:	  0397	75 89 11		mov	TMOD,#11H	;Use 16 bit mode of timer 0
 1212:				;
 1213:				;*****************************************************************************
 1214:				;
 1215:	  039A	75 88 54		MOV	TCON,#54H
 1216:	  039D	75 C8 34		MOV	T2CON,#34H
 1217:				;	DB	75H		;MOV DIRECT, # OP CODE
 1218:				;	DB	0C8H		;T2CON LOCATION
 1219:				;	DB	34H		;CONFIGURATION BYTE
 1220:					;
 1221:	  03A0	90 20 01		MOV	DPTR,#2001H	;READ CODE AT 2001H
 1222:	  03A3	E4			CLR	A
 1223:	  03A4	93			MOVC	A,@A+DPTR
 1224:	  03A5	B4 AA 03		CJNE	A,#0AAH,CRST1	;IF IT IS AN AAH, DO USER RESET
 1225:	  03A8	12 20 90		LCALL	2090H
 1226:					;
 1227:	  03AB	78 FF		CRST1:	MOV	R0,#IRAMTOP	;PUT THE TOP OF RAM IN R0
 1228:	  03AD	E4			CLR	A		;ZERO THE ACC
 1229:					;
 1230:	  03AE	F6		CRST2:	MOV	@R0,A		;CLEAR INTERNAL MEMORY
 1231:	  03AF	D8 FD			DJNZ	R0,CRST2	;LOOP TIL DONE
 1232:					;
 1233:					; Now, test the external memory
 1234:					;
 1235:	  03B1	75 3E 4D		MOV	SPSAV,#CMNDSP	;SET UP THE STACK
 1236:	  03B4	85 3E 81		MOV	SP,SPSAV
 1237:				;
 1238:				;*****************************************************************************
 1239:				;****** Karmann 1 Bugfix *****************************************************
 1240:				;
 1241:				;	lcall	TEST_USER	;chek for user command extensions
 1242:	  03B7	00		        nop
 1243:	  03B8	00			nop
 1244:	  03B9	00			nop
 1245:
 1246:				;
 1247:				;****** continue with original code: *****************************************
 1248:				;
 1249:	  03BA	75 13 50		MOV	BOFAH,#HIGH ROMADR
 1250:	  03BD	75 14 11		MOV	BOFAL,#LOW ROMADR+17
 1251:	  03C0	90 50 00		MOV	DPTR,#ROMADR	;GET THE BYTE AT 8000H
 1252:	  03C3	E0			MOVX	A,@DPTR
 1253:	  03C4	C3			CLR	C
 1254:	  03C5	94 31			SUBB	A,#31H		;FOR BIAS
 1255:	  03C7	F5 45			MOV	MT1,A		;SAVE IN DIRECT MATH LOC
 1256:	  03C9	C2 E2			CLR	ACC.2		;SAVE FOR RESET
 1257:	  03CB	FF			MOV	R7,A		;SAVE IT IN R7
 1258:	  03CC	A3			INC	DPTR
 1259:	  03CD	B1 C4			ACALL	L31DPI		;SAVE BAUD RATE
 1260:	  03CF	12 08 8F		LCALL	RCL
 1261:	  03D2	A3			INC	DPTR		;GET MEMTOP
 1262:	  03D3	B1 C4			ACALL	L31DPI
 1263:	  03D5	90 00 5F		MOV	DPTR,#5FH	;READ THE EXTERNAL BYTE
 1264:	  03D8	E0			MOVX	A,@DPTR
 1265:	  03D9	90 00 00		MOV	DPTR,#0 	;ESTABLISH BASE FOR CLEAR
 1266:	  03DC	B4 A5 08		CJNE	A,#0A5H,CRS	;Erase the memory
 1267:	  03DF	E5 45			MOV	A,MT1
 1268:	  03E1	C2 E0			CLR	ACC.0		;CLEAR BIT ONE
 1269:	  03E3	64 04			XRL	A,#4H
 1270:	  03E5	60 2C			JZ	CR2
 1271:					;
 1272:	  03E7	BF 02 02	CRS:	CJNE	R7,#2,CRS1
 1273:	  03EA	80 03			SJMP	CRS2
 1274:	  03EC	BF 03 04	CRS1:	CJNE	R7,#3,CR0
 1275:	  03EF	D1 87		CRS2:	ACALL	CL_1
 1276:	  03F1	80 14			SJMP	CR1
 1277:					;
 1278:	  03F3	AB 83		CR0:	MOV	R3,DPH		;SAVE THE DPTR
 1279:	  03F5	A9 82			MOV	R1,DPL
 1280:	  03F7	A3			INC	DPTR
 1281:	  03F8	74 5A			MOV	A,#5AH
 1282:	  03FA	F0			MOVX	@DPTR,A 	;Test external memory
 1283:	  03FB	E0			MOVX	A,@DPTR
 1284:	  03FC	B4 5A 08		CJNE	A,#5AH,CR1
 1285:	  03FF	E4			CLR	A
 1286:	  0400	F0			MOVX	@DPTR,A
 1287:				;
 1288:				;*****************************************************************************
 1289:				;******* Skowronek alterations to programm EEPROM's in state of UV-EPROM's ***
 1290:				;
 1291:				;	CJNE	R3,#0E0H,CR0
 1292:				;
 1293:	  0401	BB 4F EF		CJNE	R3,#HIGH ROMADR-1,CR0	;Stop the test at 8000H because
 1294:	  0404	B9 FE EC		CJNE	R1,#LOW ROMADR-2,CR0	;EEPROM starts here
 1295:				;
 1296:				;*****************************************************************************
 1297:				;
 1298:	  0407	BB 03 00	CR1:	CJNE	R3,#03H,CR11	;NEED THIS MUCH RAM
 1299:	  040A	40 88		CR11:	JC	NCRST
 1300:	  040C	90 01 0A		MOV	DPTR,#MEMTOP	;SAVE MEMTOP
 1301:	  040F	D1 0D			ACALL	S31DP2		;SAVE MEMTOP AND SEED RCELL
 1302:	  0411	D1 66			ACALL	CNEW		;CLEAR THE MEMORY AND SET UP POINTERS
 1303:					;
 1304:	  0413	D1 79		CR2:	ACALL	RC1		;SET UP STACKS IF NOT DONE
 1305:					;
 1306:	  0415	12 16 64		LCALL	AXTAL0		;DO THE CRYSTAL
 1307:	  0418	E5 45			MOV	A,MT1		;GET THE RESET BYTE
 1308:	  041A	B4 05 03		CJNE	A,#5,CR20
 1309:	  041D	12 40 39		LCALL	4039H
 1310:
 1311:	  0420	50 0D		CR20:	JNC	BG1		;CHECK FOR 0,1,2,3, OR 4
 1312:	  0422	30 E0 4C		JNB	ACC.0,BG3	;NO RUN IF WRONG TYPE
 1313:
 1314:	  0425	90 50 10		MOV	DPTR,#ROMADR+16
 1315:	  0428	E0			MOVX	A,@DPTR 	;READ THE BYTE
 1316:	  0429	B4 55 45		CJNE	A,#55H,BG3
 1317:
 1318:	  042C	02 08 0C		LJMP	CRUN
 1319:				;
 1320:				;*****************************************************************************
 1321:				;******* New baudrate detection **********************************************
 1322:				;******* Wulf 3 alteration 1 *************************************************
 1323:				;
 1324:				;BG1:	 CLR	 A		 ;DO BAUD RATE
 1325:				;	 MOV	 R3,A
 1326:				;	 MOV	 R1,A
 1327:				;	 MOV	 R0,#4
 1328:				;	 JB	 RXD,$		 ;LOOP UNTIL A CHARACTER IS RECEIVED
 1329:				;	;
 1330:				;BG2:	 DJNZ	 R0,$		 ;FOUR CLOCKS, IN LOOP
 1331:				;	 CALL	 DEC3211	 ;NINE CLOCKS
 1332:				;	 MOV	 R0,#2		 ;ONE CLOCK
 1333:				;	 JNB	 RXD,BG2	 ;TWO CLOCKS, LOOP UNTIL DONE
 1334:				;	 JB	 RXD,$		 ;WAIT FOR STOP CHARACTER TO END
 1335:				;	 JNB	 RXD,$
 1336:				;
 1337:				;*****************************************************************************
 1338:				;******* New processor type detection ****************************************
 1339:				;******* Wulf 4 **************************************************************
 1340:				;
 1341:	  042F	E4		BG1:	clr	a
 1342:	  0430	F5 C8			mov	t2con,a
 1343:	  0432	75 CD FF		mov	TH2,#0FFh
 1344:	  0435	75 CC F8		mov	TL2,#0F8h
 1345:	  0438	20 B0 08		jb	rxd,BG16
 1346:	  043B	75 C8 05		mov	t2con,#5	;Timer2 start
 1347:	  043E	30 B0 02		jnb	rxd,BG16
 1348:	  0441	F5 C8			mov	t2con,a 	;Timer2 stop
 1349:					;jb	rxd,BG10
 1350:					;jnb	rxd,BG10
 1351:					;call	sercalc 	;r3=timer2 MSB default
 1352:					;
 1353:
 1354:	  0443			BG16:
 1355:	  0443	90 82 02		mov dptr,#8202h
 1356:	  0446	E4			clr a
 1357:	  0447	F0			movx @dptr,a          ; turn off segment LED
 1358:
 1359:	  0448	90 81 00		mov dptr,#8100h
 1360:	  044B	F0			movx @dptr,a          ; turn off GPIO1 LED
 1361:
 1362:	  044C	90 82 01		mov dptr,#8201h
 1363:	  044F	F4			cpl a
 1364:	  0450	F0			movx @dptr,a	      ;	turn off digit
 1365:
 1366:	  0451	00			nop
 1367:	  0452	00			nop
 1368:	  0453	00			nop
 1369:	  0454	00			nop
 1370:	  0455	00		        nop
 1371:	  0456	00			nop
 1372:	  0457	00			nop
 1373:
 1374:
 1375:					;cjne	a,ADCON,BG10	;jump if A/D processor like 805x5
 1376:	  0458			BG14:	;mov	a,S0RELL
 1377:					;cjne	a,#B9600,BG2	;jump if not 805x7A
 1378:
 1379:					;mov	a,r3
 1380:					;anl	S0RELH,a
 1381:					;mov	S0RELL,r1	;start Baudratetimer 805X7A
 1382:					;sjmp	BG11
 1383:					;
 1384:
 1385:	  0458	79 DC		BG10:	mov r1,#B9600
 1386:	  045A	7B FF			mov r3,#0ffh
 1387:					;nop
 1388:					;nop
 1389:					;nop
 1390:
 1391:	  045C	B9 DC 05		cjne	r1,#B9600,BG12	;jump if wrong fast baud rate
 1392:	  045F	43 87 80	BG11:	orl	PCON0,#080h	;setb smod for fast mode
 1393:	  0462	80 03			sjmp	BG13
 1394:					;
 1395:	  0464	B9 B2 F1	BG12:	cjne	r1,#B4800,BG14	;jump if wrong slow baudrate
 1396:	  0467	D2 DF		BG13:	setb	BD		;enable baudrategenerator
 1397:	  0469	80 00			sjmp	BG2
 1398:
 1399:
 1400:
 1401:					;
 1402:	  046B	75 C8 34	BG2:	mov	t2con,#34h	;configure Timer2 as baudrate generator
 1403:	  046E	12 08 8F	BG15:	CALL	RCL		;LOAD THE TIMER
 1404:				;
 1405:				;****** Original code from here **********************************************
 1406:				;
 1407:	  0471	90 1F D3	BG3:	MOV	DPTR,#S_N	;GET THE MESSAGE
 1408:	  0474	D1 B7			ACALL	CRP		;PRINT IT
 1409:	  0476	02 17 8C		LJMP	CRAM
 1410:					;
 1411:					;***************************************************************
 1412:					;
 1413:					; CIPROG AND CPROG - Program a prom
 1414:					;
 1415:					;***************************************************************
 1416:					;
 1417:	  0479	7F 00		PG8:	MOV	R7,#00H 	;PROGRAM ONE BYTE AT A TIME
 1418:	  047B	7E 01			MOV	R6,#01H
 1419:	  047D	7A 4F			MOV	R2,#HIGH ROMADR-1
 1420:	  047F	78 FF			MOV	R0,#LOW ROMADR-1;LOAD PROM ADDRESS
 1421:	  0481	91 BF			ACALL	PG101
 1422:	  0483	0E			INC	R6
 1423:	  0484	E5 CB			MOV	A,RCAPH2
 1424:				;	DB	0E5H		;MOV A DIRECT OP CODE
 1425:				;	DB	0CBH		;ADDRESS OF R2CAP HIGH
 1426:	  0486	91 BF			ACALL	PG101
 1427:	  0488	E5 CA			MOV	A,RCAPL2
 1428:				;	DB	0E5H		;MOV A, DIRECT OP CODE
 1429:				;	DB	0CAH		;R2CAP LOW
 1430:	  048A	7E 03			MOV	R6,#3
 1431:	  048C	79 09			MOV	R1,#LOW MEMTOP-1
 1432:	  048E	7B 01			MOV	R3,#HIGH MEMTOP
 1433:	  0490	91 BF			ACALL	PG101		;SAVE MEMTOP
 1434:	  0492	80 29			SJMP	PGR
 1435:				;
 1436:				;
 1437:				;*****************************************************************************
 1438:				;****** Skowronek alterations to programm EEPROM's in state of UV-EPROM's ****
 1439:				;****** Support the "PGM" statement was added by D. Wulf *********************
 1440:				;****** Disable Intel programming and code optimize by H.-J. Boehling ********
 1441:				;
 1442:				;CIPROG: MOV	DPTR,#IPROGS	;LOAD IPROG LOCATION
 1443:				;	SETB	INTELB
 1444:				;	SJMP	CPROG1		;GO DO PROG
 1445:				;	;
 1446:				;CPROG: MOV	DPTR,#PROGS	;LOAD PROG LOCATION
 1447:				;	CLR	INTELB
 1448:				;	;
 1449:				;CPROG1: ACALL	LD_T		;LOAD THE TIMER
 1450:				;	CLR	PROMV		;TURN ON THE PROM VOLTAGE
 1451:				;	CALL	DELTST		;SEE IF A CR
 1452:				;	JNZ	PG8		;SAVE TIMER IF SO
 1453:				;	MOV	R4,#0FEH
 1454:				;	SETB	INBIT
 1455:				;	ACALL	ROMFD		;GET THE ROM ADDRESS OF THE LAST LOCATION
 1456:				;	CALL	TEMPD		;SAVE THE ADDRESS
 1457:				;	MOV	A,R4		;GET COUNT
 1458:				;	CPL	A
 1459:				;	CALL	TWO_R2		;PUT IT ON THE STACK
 1460:				;	CALL	FP_BASE7	;OUTPUT IT
 1461:				;	ACALL	CCAL		;GET THE PROGRAM
 1462:				;	ACALL	CRLF		;DO CRLF
 1463:				;	MOV	R0,TEMP4	;GET ADDRESS
 1464:				;	MOV	R2,TEMP5
 1465:				;	MOV	A,#55H		;LOAD SIGNIFIER
 1466:				;	INC	R6		;LOAD LEN + 1
 1467:				;	CJNE	R6,#00,CPROG2
 1468:				;	INC	R7
 1469:				;CPROG2: ACALL	 PG102
 1470:				;
 1471:				;PGR:	SETB	PROMV
 1472:				;	AJMP	C_K
 1473:				;
 1474:				;PG1:	MOV	P2,R3		;GET THE BYTE TO PROGRAM
 1475:				;	MOVX	A,@R1
 1476:				;PG101:  LCALL	 INC3210	 ;BUMP POINTERS
 1477:				;PG102:  MOV	 R5,#1		 ;SET UP INTELLIGENT COUMTER
 1478:				;
 1479:				;PG2:	MOV	R4,A		;SAVE THE BYTE IN R4
 1480:				;	ACALL	PG7		;PROGRAM THE BYTE
 1481:				;	ACALL	PG9
 1482:				;	JB	INTELB,PG4	;SEE IF INTELLIGENT PROGRAMMING
 1483:				;
 1484:				;PG3:	XRL	A,R4
 1485:				;	JNZ	PG6		;ERROR IF NOT THE SAME
 1486:				;	CALL	DEC76		;BUMP THE COUNTERS
 1487:				;	JNZ	PG1		;LOOP IF NOT DONE
 1488:				;	ANL	PSW,#11100111B	;INSURE RB0
 1489:				;PG31:	 RET
 1490:				;
 1491:				;PG4:	XRL	A,R4		;SEE IF PROGRAMMED
 1492:				;	JNZ	PG5		;JUMP IF NOT
 1493:				;	MOV	A,R4		;GET THE DATA BACK
 1494:				;	ACALL	PG7		;PROGRAM THE LOCATION
 1495:				;PG41:	 ACALL	 ZRO		 ;AGAIN
 1496:				;	ACALL	ZRO		;AND AGAIN
 1497:				;	ACALL	ZRO		;AND AGAIN
 1498:				;	DJNZ	R5,PG41 	;KEEP DOING IT
 1499:				;	ACALL	PG9		;RESET PROG
 1500:				;	SJMP	PG3		;FINISH THE LOOP
 1501:				;
 1502:				;PG5:	INC	R5		;BUMP THE COUNTER
 1503:				;	MOV	A,R4		;GET THE BYTE
 1504:				;	CJNE	R5,#25,PG2	;SEE IF TRIED 25 TIMES
 1505:				;
 1506:				;PG6:	SETB	PROMV		;TURN OFF PROM VOLTAGE
 1507:				;	MOV	PSW,#0		;INSURE RB0
 1508:				;	JNB	DIRF,PG31	;EXIT IF IN RUN MODE
 1509:				;	MOV	DPTR,#E16X	;PROGRAMMING ERROR
 1510:				;
 1511:				;ERRLK: LJMP	ERROR		;PROCESS THE ERROR
 1512:				;
 1513:				;PG7:	MOV	P0,R0		;SET UP THE PORTS
 1514:				;	MOV	P2,R2		;LATCH LOW ORDER ADDRESS
 1515:				;	ACALL	PG11		;DELAY FOR 8748/9
 1516:				;	CLR	ALED
 1517:				;	MOV	P0,A		;PUT DATA ON THE PORT
 1518:				;	;
 1519:				;ZRO:	NOP			;SETTLEING TIME + FP ZERO
 1520:				;	NOP
 1521:				;	NOP
 1522:				;	NOP
 1523:				;	NOP
 1524:				;	NOP
 1525:				;	ACALL	PG11		;DELAY A WHILE
 1526:				;	CLR	PROMP		;START PROGRAMMING
 1527:				;	ACALL	TIMER_LOAD	;START THE TIMER
 1528:				;	JNB	TF1,$		;WAIT FOR PART TO PROGRAM
 1529:				;	RET			;EXIT
 1530:				;
 1531:				;PG9:	SETB	PROMP
 1532:				;	ACALL	PG11		;DELAY FOR A WHILE
 1533:				;	JNB	P3.2,$		;LOOP FOR EEPROMS
 1534:				;	MOV	P0,#0FFH
 1535:				;	CLR	P3.7		;LOWER READ
 1536:				;	ACALL	PG11
 1537:				;	MOV	A,P0		;READ THE PORT
 1538:				;	SETB	P3.7
 1539:				;	SETB	ALED
 1540:				;	RET
 1541:				;
 1542:				;PG11:	MOV	TEMP5,#12	;DELAY 30uS AT 12 MHZ
 1543:				;	DJNZ	TEMP5,$
 1544:				;	RET
 1545:				;
 1546:				;	;**************************************************************
 1547:				;	;
 1548:				;PGU:	;PROGRAM A PROM FOR THE USER
 1549:				;	;
 1550:				;	;**************************************************************
 1551:				;
 1552:				;	CLR	PROMV		;TURN ON THE VOLTAGE
 1553:				;	MOV	PSW,#00011000B	;SELECT RB3
 1554:				;	ACALL	PG1		;DO IT
 1555:				;	SETB	PROMV		;TURN IT OFF
 1556:				;	RET
 1557:				;
 1558:				;****** alteredet code starts here: ******************************************
 1559:				;
 1560:	  0494	90 01 28	CPROG:	MOV	DPTR,#PROGS	;LOAD PROG LOCATION
 1561:					;
 1562:	  0497	B1 8C		CPROG1: ACALL	LD_T		;LOAD THE TIMER
 1563:	  0499	12 0E EC		CALL	DELTST		;SEE IF A CR
 1564:	  049C	70 DB			JNZ	PG8		;SAVE TIMER IF SO
 1565:	  049E	7C FE			MOV	R4,#0FEH
 1566:	  04A0	D2 1D			SETB	INBIT
 1567:	  04A2	B1 65			ACALL	ROMFD		;GET THE ROM ADDRESS OF THE LAST LOCATION
 1568:	  04A4	12 18 61		CALL	TEMPD		;SAVE THE ADDRESS
 1569:	  04A7	EC			MOV	A,R4		;GET COUNT
 1570:	  04A8	F4			CPL	A
 1571:	  04A9	12 14 BE		CALL	TWO_R2		;PUT IT ON THE STACK
 1572:	  04AC	12 19 8A		CALL	FP_BASE7	;OUTPUT IT
 1573:	  04AF	B1 26			ACALL	CCAL		;GET THE PROGRAM
 1574:	  04B1	D1 AF			ACALL	CRLF		;DO CRLF
 1575:	  04B3	A8 0E			MOV	R0,TEMP4	;GET ADDRESS
 1576:	  04B5	AA 0F			MOV	R2,TEMP5
 1577:	  04B7	74 55			MOV	A,#55H		;LOAD SIGNIFIER
 1578:	  04B9	0E			INC	R6		;LOAD LEN + 1
 1579:	  04BA	0F			INC	R7
 1580:	  04BB	91 CD		CPROG2: ACALL	PG2
 1581:					;
 1582:	  04BD	A1 4A		PGR:	AJMP	C_K		;Exit to command mode
 1583:					;
 1584:	  04BF	0F		PG101:	INC	R7
 1585:	  04C0	BE 00 07		CJNE	R6,#0,PG4
 1586:	  04C3	1F			DEC	R7
 1587:	  04C4	80 04			SJMP	PG4
 1588:					;
 1589:	  04C6	0F		PG10:	INC	R7
 1590:					;
 1591:	  04C7	8B A0		PG1:	MOV	P2,R3		;GET THE BYTE TO PROGRAM
 1592:	  04C9	E3			MOVX	A,@R1
 1593:	  04CA	12 15 83	PG4:	LCALL	INC3210 	;BUMP POINTERS
 1594:					;
 1595:	  04CD	91 E3		PG2:	ACALL	PG7		;Write the byte
 1596:	  04CF	70 04			JNZ	PG5		;exit if error
 1597:	  04D1	DE F4			DJNZ	R6,PG1
 1598:	  04D3	DF F2			DJNZ	R7,PG1		;LOOP IF NOT DONE
 1599:					;
 1600:	  04D5	53 D0 E7	PG5:	ANL	PSW,#11100111B	;INSURE RB0
 1601:	  04D8	60 27			JZ	PG31		;Jump if none error
 1602:					;
 1603:	  04DA	30 2F 24	PG6:	JNB	DIRF,PG31	;EXIT IF IN RUN MODE
 1604:	  04DD	90 1F 9A		MOV	DPTR,#E16X	;PROGRAMMING ERROR
 1605:	  04E0	02 18 9C	ERRLK:	LJMP	ERROR		;PROCESS THE ERROR
 1606:					;
 1607:					;
 1608:	  04E3	FC		PG7:	MOV	R4,A		;SAVE THE BYTE IN R4 for error detect
 1609:	  04E4	8A 83			mov	dph,r2		;load data pointer with eeprom address
 1610:	  04E6	88 82			mov	dpl,r0
 1611:	  04E8	F0			movx	@dptr,a 	;write the byte
 1612:	  04E9	7D			DB	07DH		;mov	 r5,#0
 1613:					;
 1614:
 1615:
 1616:	  04EA	00		ZRO:	NOP
 1617:	  04EB	00			NOP			;SETTLEING TIME + FP ZERO
 1618:	  04EC	00			NOP			;Atenttion. This 6 NOP's a not only
 1619:	  04ED	00			NOP			;for settleing time, it is also the
 1620:	  04EE	00			NOP			;floating point zero!
 1621:	  04EF	00			NOP
 1622:	  04F0	75 0F 01		MOV	TEMP5,#1	;DELAY 30uS AT 12 MHZ
 1623:	  04F3	D5 0F FD		DJNZ	TEMP5,$
 1624:
 1625:	  04F6	B1 37			ACALL	TIMER_LOAD	;START THE TIMER
 1626:					;JNB	TF1,$		;WAIT FOR PART TO PROGRAM
 1627:	  04F8	00		        nop
 1628:	  04F9	00			nop
 1629:	  04FA	00			nop
 1630:
 1631:	  04FB			PG32:
 1632:	  04FB	E0			movx	A,@DPTR 	;Read back for error detect
 1633:	  04FC	6C			xrl	A,R4		;Test for error
 1634:	  04FD	60 02			jz	PG31
 1635:	  04FF	DD E9			djnz	r5,ZRO
 1636:	  0501	22		PG31:	RET
 1637:					;
 1638:					;**************************************************************
 1639:					;
 1640:	  0502			PGU:	;PROGRAM A PROM FOR THE USER (statement 'PGM')
 1641:					;
 1642:					;**************************************************************
 1643:					;
 1644:	  0502	75 D0 18		MOV	PSW,#00011000B	;SELECT RB3
 1645:	  0505	BE 00 BE		CJNE	R6,#0,PG10
 1646:	  0508	80 BD			SJMP	PG1
 1647:				;
 1648:				;*****************************************************************************
 1649:				;****** The new command "ERASE" to fill a EEPROM with 0FFH *******************
 1650:				;****** Boehling 3 ***********************************************************
 1651:				;
 1652:	  050A	7F 30		CERASE: mov	R7,#30H 		;Erase 12K byte W.sirichote from 5000h to 7fffh
 1653:	  050C	7E 00			mov	R6,#00H
 1654:	  050E	7A 4F			mov	R2,#HIGH ROMADR-1	;Startaddress EEPROM
 1655:	  0510	78 FF			mov	R0,#LOW ROMADR-1
 1656:	  0512	90 01 28		mov	DPTR,#PROGS		;Point to EEPROM timeing
 1657:	  0515	B1 8C			acall	LD_T			;Load the timer
 1658:					;
 1659:	  0517	12 15 83	ERA1:	lcall	INC3210 		;Bump pointers
 1660:	  051A	74 FF			mov	A,#0FFH 		;Fill the EEPROM with 0FFH
 1661:	  051C	91 E3			acall	PG7			;Write the byte
 1662:	  051E	70 BA			jnz	PG6			;Exit if error
 1663:	  0520	DE F5			DJNZ	R6,ERA1
 1664:	  0522	DF F3			DJNZ	R7,ERA1 		;Do the loop
 1665:	  0524	A1 4A			ajmp	C_K			;Exit to command mode
 1666:				;
 1667:				;*****************************************************************************
 1668:				;
 1669:				;****** continue with original code: *****************************************
 1670:					;
 1671:					;*************************************************************
 1672:					;
 1673:	  0526			CCAL:	; Set up for prom moves
 1674:					; R3:R1 gets source
 1675:					; R7:R6 gets # of bytes
 1676:					;
 1677:					;*************************************************************
 1678:					;
 1679:	  0526	B1 94			ACALL	GETEND		;GET THE LAST LOCATION
 1680:	  0528	A3			INC	DPTR		;BUMP TO LOAD EOF
 1681:	  0529	AB 13			MOV	R3,BOFAH
 1682:	  052B	A9 14			MOV	R1,BOFAL	;RESTORE START
 1683:	  052D	C3			CLR	C		;PREPARE FOR SUBB
 1684:	  052E	E5 82			MOV	A,DPL		;SUB DPTR - BOFA > R7:R6
 1685:	  0530	99			SUBB	A,R1
 1686:	  0531	FE			MOV	R6,A
 1687:	  0532	E5 83			MOV	A,DPH
 1688:	  0534	9B			SUBB	A,R3
 1689:	  0535	FF			MOV	R7,A
 1690:	  0536	22		CCAL1:	RET
 1691:					;
 1692:					;**************************************************************
 1693:					;
 1694:	  0537			TIMER_LOAD:; Load the timer
 1695:					;
 1696:					;*************************************************************
 1697:					;
 1698:	  0537	B1 36			ACALL	CCAL1		;DELAY FOUR CLOCKS
 1699:	  0539			TIMER_LOAD1:
 1700:	  0539	C2 8E			CLR	TR1		;STOP IT WHILE IT'S LOADED
 1701:	  053B	85 40 8D		MOV	TH1,T_HH
 1702:	  053E	85 41 8B		MOV	TL1,T_LL
 1703:	  0541	C2 8F			CLR	TF1		;CLEAR THE OVERFLOW FLAG
 1704:	  0543	D2 8E			SETB	TR1		;START IT NOW
 1705:	  0545	22			RET
 1706:					;
 1707:					;***************************************************************
 1708:					;
 1709:	  0546			CROM:	; The command action routine - ROM - Run out of rom
 1710:					;
 1711:					;***************************************************************
 1712:					;
 1713:	  0546	C2 17			CLR	CONB		;CAN'T CONTINUE IF MODE CHANGE
 1714:	  0548	B1 4D			ACALL	RO1		;DO IT
 1715:					;
 1716:	  054A	02 10 9F	C_K:	LJMP	CL3		;EXIT
 1717:					;
 1718:				;RO1:	 CALL	 INTGER 	;SEE IF INTGER PRESENT
 1719:				;	 MOV	 R4,R0B0	;SAVE THE NUMBER
 1720:				;	 JNC	 $+4
 1721:				;	 MOV	 R4,#01H	;ONE IF NO INTEGER PRESENT
 1722:				;	ACALL	ROMFD		;FIND THE PROGRAM
 1723:				;
 1724:	  054D	12 0E EC	RO1:	CALL	DELTST
 1725:	  0550	7C 01			MOV	R4,#1
 1726:	  0552	50 04			JNC	RO11
 1727:	  0554	12 0E 99		CALL	ONE
 1728:	  0557	FC			MOV	R4,A
 1729:				;
 1730:	  0558	B1 65		RO11:	ACALL	ROMFD
 1731:	  055A	BC 00 11		CJNE	R4,#0,RFX	;EXIT IF R4 <> 0
 1732:	  055D	A3			INC	DPTR		;BUMP PAST TAG
 1733:	  055E	85 83 13		MOV	BOFAH,DPH	;SAVE THE ADDRESS
 1734:	  0561	85 82 14		MOV	BOFAL,DPL
 1735:	  0564	22			RET
 1736:					;
 1737:	  0565	90 50 10	ROMFD:	MOV	DPTR,#ROMADR+16 ;START OF USER PROGRAM
 1738:					;
 1739:	  0568	E0		RF1:	MOVX	A,@DPTR 	;GET THE BYTE
 1740:	  0569	B4 55 09		CJNE	A,#55H,RF3	;SEE IF PROPER TAG
 1741:	  056C	DC 01			DJNZ	R4,RF2		;BUMP COUNTER
 1742:					;
 1743:	  056E	22		RFX:	RET			;DPTR HAS THE START ADDRESS
 1744:					;
 1745:	  056F	A3		RF2:	INC	DPTR		;BUMP PAST TAG
 1746:	  0570	B1 B6			ACALL	G5
 1747:	  0572	A3			INC	DPTR		;BUMP TO NEXT PROGRAM
 1748:	  0573	80 F3			SJMP	RF1		;DO IT AGAIN
 1749:					;
 1750:	  0575	10 1D F6	RF3:	JBC	INBIT,RFX	;EXIT IF SET
 1751:					;
 1752:	  0578	90 1F C9	NOGO:	MOV	DPTR,#NOROM
 1753:	  057B	81 E0			AJMP	ERRLK
 1754:					;
 1755:					;***************************************************************
 1756:					;
 1757:	  057D			L20DPI: ; load R2:R0 with the location the DPTR is pointing to
 1758:					;
 1759:					;***************************************************************
 1760:					;
 1761:	  057D	E0			MOVX	A,@DPTR
 1762:	  057E	FA			MOV	R2,A
 1763:	  057F	A3			INC	DPTR
 1764:	  0580	E0			MOVX	A,@DPTR
 1765:	  0581	F8			MOV	R0,A
 1766:	  0582	22			RET			;DON'T BUMP DPTR
 1767:					;
 1768:					;***************************************************************
 1769:					;
 1770:	  0583			X31DP:	; swap R3:R1 with DPTR
 1771:					;
 1772:					;***************************************************************
 1773:					;
 1774:	  0583	CB			XCH	A,R3
 1775:	  0584	C5 83			XCH	A,DPH
 1776:	  0586	CB			XCH	A,R3
 1777:	  0587	C9			XCH	A,R1
 1778:	  0588	C5 82			XCH	A,DPL
 1779:	  058A	C9			XCH	A,R1
 1780:	  058B	22			RET
 1781:					;
 1782:					;***************************************************************
 1783:					;
 1784:	  058C			LD_T:	; Load the timer save location with the value the DPTR is
 1785:					; pointing to.
 1786:					;
 1787:					;****************************************************************
 1788:					;
 1789:	  058C	E0			MOVX	A,@DPTR
 1790:	  058D	F5 40			MOV	T_HH,A
 1791:	  058F	A3			INC	DPTR
 1792:	  0590	E0			MOVX	A,@DPTR
 1793:	  0591	F5 41			MOV	T_LL,A
 1794:	  0593	22			RET
 1795:					;
 1796:					;
 1797:					;***************************************************************
 1798:					;
 1799:					;GETLIN - FIND THE LOCATION OF THE LINE NUMBER IN R3:R1
 1800:					;	  IF ACC = 0 THE LINE WAS NOT FOUND I.E. R3:R1
 1801:					;	  WAS TOO BIG, ELSE ACC <> 0 AND THE DPTR POINTS
 1802:					;	  AT THE LINE THAT IS GREATER THAN OR EQUAL TO THE
 1803:					;	  VALUE IN R3:R1.
 1804:					;
 1805:					;***************************************************************
 1806:					;
 1807:	  0594	D2 29		GETEND: SETB	ENDBIT		;GET THE END OF THE PROGRAM
 1808:					;
 1809:	  0596	12 0E A6	GETLIN: CALL	DP_B		;GET BEGINNING ADDRESS
 1810:					;
 1811:	  0599	12 0A AE	G1:	CALL	B_C
 1812:	  059C	60 12			JZ	G3		;EXIT WITH A ZERO IN A IF AT END
 1813:	  059E	A3			INC	DPTR		;POINT AT THE LINE NUMBER
 1814:	  059F	20 29 0A		JB	ENDBIT,G2	;SEE IF WE WANT TO FIND THE END
 1815:	  05A2	B1 D6			ACALL	DCMPX		;SEE IF (DPTR) = R3:R1
 1816:	  05A4	B1 CC			ACALL	DECDP		;POINT AT LINE COUNT
 1817:	  05A6	E0			MOVX	A,@DPTR 	;PUT LINE LENGTH INTO ACC
 1818:	  05A7	20 2A 06		JB	UBIT,G3 	;EXIT IF EQUAL
 1819:	  05AA	40 04			JC	G3		;SEE IF LESS THAN OR ZERO
 1820:					;
 1821:	  05AC	B1 E8		G2:	ACALL	ADDPTR		;ADD IT TO DPTR
 1822:	  05AE	80 E9			SJMP	G1		;LOOP
 1823:					;
 1824:	  05B0	C2 29		G3:	CLR	ENDBIT		;RESET ENDBIT
 1825:	  05B2	22			RET			;EXIT
 1826:					;
 1827:	  05B3	90 02 00	G4:	MOV	DPTR,#PSTART	;DO RAM
 1828:					;
 1829:	  05B6	D2 29		G5:	SETB	ENDBIT
 1830:	  05B8	80 DF			SJMP	G1		;NOW DO TEST
 1831:					;
 1832:					;***************************************************************
 1833:					;
 1834:					; LDPTRI - Load the DATA POINTER with the value it is pointing
 1835:					;	   to - DPH = (DPTR) , DPL = (DPTR+1)
 1836:					;
 1837:					; acc gets wasted
 1838:					;
 1839:					;***************************************************************
 1840:					;
 1841:	  05BA	E0		LDPTRI: MOVX	A,@DPTR 	;GET THE HIGH BYTE
 1842:	  05BB	C0 E0			PUSH	ACC		;SAVE IT
 1843:	  05BD	A3			INC	DPTR		;BUMP THE POINTER
 1844:	  05BE	E0			MOVX	A,@DPTR 	;GET THE LOW BYTE
 1845:	  05BF	F5 82			MOV	DPL,A		;PUT IT IN DPL
 1846:	  05C1	D0 83			POP	DPH		;GET THE HIGH BYTE
 1847:	  05C3	22			RET			;GO BACK
 1848:					;
 1849:					;***************************************************************
 1850:					;
 1851:					;L31DPI - LOAD R3 WITH (DPTR) AND R1 WITH (DPTR+1)
 1852:					;
 1853:					;ACC GETS CLOBBERED
 1854:					;
 1855:					;***************************************************************
 1856:					;
 1857:	  05C4	E0		L31DPI: MOVX	A,@DPTR 	;GET THE HIGH BYTE
 1858:	  05C5	FB			MOV	R3,A		;PUT IT IN THE REG
 1859:	  05C6	A3			INC	DPTR		;BUMP THE POINTER
 1860:	  05C7	E0			MOVX	A,@DPTR 	;GET THE NEXT BYTE
 1861:	  05C8	F9			MOV	R1,A		;SAVE IT
 1862:	  05C9	22			RET
 1863:					;
 1864:					;***************************************************************
 1865:					;
 1866:					;DECDP - DECREMENT THE DATA POINTER - USED TO SAVE SPACE
 1867:					;
 1868:					;***************************************************************
 1869:					;
 1870:	  05CA	B1 CC		DECDP2: ACALL	DECDP
 1871:					;
 1872:	  05CC	C5 82		DECDP:	XCH	A,DPL		;GET DPL
 1873:	  05CE	70 02			JNZ	DECDP1		;BUMP IF ZERO
 1874:	  05D0	15 83			DEC	DPH
 1875:	  05D2	14		DECDP1: DEC	A		;DECREMENT IT
 1876:	  05D3	C5 82			XCH	A,DPL		;GET A BACK
 1877:	  05D5	22			RET			;EXIT
 1878:					;
 1879:					;***************************************************************
 1880:					;
 1881:					;DCMPX - DOUBLE COMPARE - COMPARE (DPTR) TO R3:R1
 1882:					;R3:R1 - (DPTR) = SET CARRY FLAG
 1883:					;
 1884:					;IF R3:R1 > (DPTR) THEN C = 0
 1885:					;IF R3:R1 < (DPTR) THEN C = 1
 1886:					;IF R3:R1 = (DPTR) THEN C = 0
 1887:					;
 1888:					;***************************************************************
 1889:					;
 1890:	  05D6	C2 2A		DCMPX:	CLR	UBIT		;ASSUME NOT EQUAL
 1891:	  05D8	E0			MOVX	A,@DPTR 	;GET THE BYTE
 1892:	  05D9	B5 03 0A		CJNE	A,R3B0,D1	;IF A IS GREATER THAN R3 THEN NO CARRY
 1893:								;WHICH IS R3<@DPTR = NO CARRY AND
 1894:								;R3>@DPTR CARRY IS SET
 1895:	  05DC	A3			INC	DPTR		;BUMP THE DATA POINTER
 1896:	  05DD	E0			MOVX	A,@DPTR 	;GET THE BYTE
 1897:	  05DE	B1 CC			ACALL	DECDP		;PUT DPTR BACK
 1898:	  05E0	B5 01 03		CJNE	A,R1B0,D1	;DO THE COMPARE
 1899:	  05E3	B3			CPL	C		;FLIP CARRY
 1900:					;
 1901:	  05E4	B2 2A			CPL	UBIT		;SET IT
 1902:	  05E6	B3		D1:	CPL	C		;GET THE CARRY RIGHT
 1903:	  05E7	22			RET			;EXIT
 1904:					;
 1905:					;***************************************************************
 1906:					;
 1907:					; ADDPTR - Add acc to the dptr
 1908:					;
 1909:					; acc gets wasted
 1910:					;
 1911:					;***************************************************************
 1912:					;
 1913:	  05E8	25 82		ADDPTR: ADD	A,DPL		;ADD THE ACC TO DPL
 1914:	  05EA	F5 82			MOV	DPL,A		;PUT IT IN DPL
 1915:	  05EC	50 02			JNC	ADDPTR1 	;JUMP IF NO CARRY
 1916:	  05EE	05 83			INC	DPH		;BUMP DPH
 1917:	  05F0	22		ADDPTR1:RET			;EXIT
 1918:					;
 1919:					;*************************************************************
 1920:					;
 1921:	  05F1			LCLR:	; Set up the storage allocation
 1922:					;
 1923:					;*************************************************************
 1924:					;
 1925:	  05F1	D1 A4			ACALL	ICLR		;CLEAR THE INTERRUPTS
 1926:	  05F3	B1 B3			ACALL	G4		;PUT END ADDRESS INTO DPTR
 1927:	  05F5	74 06			MOV	A,#6		;ADJUST MATRIX SPACE
 1928:	  05F7	B1 E8			ACALL	ADDPTR		;ADD FOR PROPER BOUNDS
 1929:	  05F9	B1 83			ACALL	X31DP		;PUT MATRIX BOUNDS IN R3:R1
 1930:	  05FB	90 01 08		MOV	DPTR,#MT_ALL	;SAVE R3:R1 IN MATRIX FREE SPACE
 1931:	  05FE	D1 0F			ACALL	S31DP		;DPTR POINTS TO MEMTOP
 1932:	  0600	B1 C4			ACALL	L31DPI		;LOAD MEMTOP INTO R3:R1
 1933:	  0602	90 01 22		MOV	DPTR,#STR_AL	;GET MEMORY ALLOCATED FOR STRINGS
 1934:	  0605	B1 BA			ACALL	LDPTRI
 1935:	  0607	12 0A 0C		CALL	DUBSUB		;R3:R1 = MEMTOP - STRING ALLOCATION
 1936:	  060A	90 01 04		MOV	DPTR,#VARTOP	;SAVE R3:R1 IN VARTOP
 1937:					;
 1938:					; FALL THRU TO S31DP2
 1939:					;
 1940:					;***************************************************************
 1941:					;
 1942:					;S31DP - STORE R3 INTO (DPTR) AND R1 INTO (DPTR+1)
 1943:					;
 1944:					;ACC GETS CLOBBERED
 1945:					;
 1946:					;***************************************************************
 1947:					;
 1948:	  060D	D1 0F		S31DP2: ACALL	S31DP		;DO IT TWICE
 1949:					;
 1950:	  060F	EB		S31DP:	MOV	A,R3		;GET R3 INTO ACC
 1951:	  0610	F0			MOVX	@DPTR,A 	;STORE IT
 1952:	  0611	A3			INC	DPTR		;BUMP DPTR
 1953:	  0612	E9			MOV	A,R1		;GET R1
 1954:	  0613	F0			MOVX	@DPTR,A 	;STORE IT
 1955:	  0614	A3			INC	DPTR		;BUMP IT AGAIN TO SAVE PROGRAM SPACE
 1956:	  0615	22			RET			;GO BACK
 1957:					;
 1958:					;
 1959:					;***************************************************************
 1960:					;
 1961:	  0616			STRING: ; Allocate memory for strings
 1962:					;
 1963:					;***************************************************************
 1964:					;
 1965:	  0616	12 0E 90		LCALL	TWO		;R3:R1 = NUMBER, R2:R0 = LEN
 1966:	  0619	90 01 22		MOV	DPTR,#STR_AL	;SAVE STRING ALLOCATION
 1967:	  061C	D1 0F			ACALL	S31DP
 1968:	  061E	0E			INC	R6		;BUMP
 1969:	  061F	8E 3F			MOV	S_LEN,R6	;SAVE STRING LENGTH
 1970:	  0621	C1 6E			AJMP	RCLEAR		;CLEAR AND SET IT UP
 1971:					;
 1972:					;***************************************************************
 1973:					;
 1974:					; F_VAR - Find	the variable in symbol table
 1975:					;	  R7:R6 contain the variable name
 1976:					;	  If not found create a zero entry and set the carry
 1977:					;	  R2:R0 has the address of variable on return
 1978:					;
 1979:					;***************************************************************
 1980:					;
 1981:	  0623	90 01 04	F_VAR:	MOV	DPTR,#VARTOP	;PUT VARTOP IN DPTR
 1982:	  0626	B1 BA			ACALL	LDPTRI
 1983:	  0628	B1 CA			ACALL	DECDP2		;ADJUST DPTR FOR LOOKUP
 1984:					;
 1985:	  062A	E0		F_VAR0: MOVX	A,@DPTR 	;LOAD THE VARIABLE
 1986:	  062B	60 20			JZ	F_VAR2		;TEST IF AT THE END OF THE TABLE
 1987:	  062D	A3			INC	DPTR		;BUMP FOR NEXT BYTE
 1988:	  062E	B5 07 0F		CJNE	A,R7B0,F_VAR1	;SEE IF MATCH
 1989:	  0631	E0			MOVX	A,@DPTR 	;LOAD THE NAME
 1990:	  0632	B5 06 0B		CJNE	A,R6B0,F_VAR1
 1991:					;
 1992:					; Found the variable now adjust and put in R2:R0
 1993:					;
 1994:	  0635	E5 82		DLD:	MOV	A,DPL		;R2:R0 = DPTR-2
 1995:	  0637	94 02			SUBB	A,#2
 1996:	  0639	F8			MOV	R0,A
 1997:	  063A	E5 83			MOV	A,DPH
 1998:	  063C	94 00			SUBB	A,#0		;CARRY IS CLEARED
 1999:	  063E	FA			MOV	R2,A
 2000:	  063F	22			RET
 2001:					;
 2002:	  0640	E5 82		F_VAR1: MOV	A,DPL		;SUBTRACT THE STACK SIZE+ADJUST
 2003:	  0642	C3			CLR	C
 2004:	  0643	94 09			SUBB	A,#STESIZ
 2005:	  0645	F5 82			MOV	DPL,A		;RESTORE DPL
 2006:	  0647	50 E1			JNC	F_VAR0
 2007:	  0649	15 83			DEC	DPH
 2008:	  064B	80 DD			SJMP	F_VAR0		;CONTINUE COMPARE
 2009:					;
 2010:					;
 2011:					; Add the entry to the symbol table
 2012:					;
 2013:	  064D	12 0D FA	F_VAR2: LCALL	R76S		;SAVE R7 AND R6
 2014:	  0650	C3			CLR	C
 2015:	  0651	D1 35			ACALL	DLD		;BUMP THE POINTER TO GET ENTRY ADDRESS
 2016:					;
 2017:					; Adjust pointer and save storage allocation
 2018:					; and make sure we aren't wiping anything out
 2019:					; First calculate new storage allocation
 2020:					;
 2021:	  0653	E8			MOV	A,R0
 2022:	  0654	94 06			SUBB	A,#STESIZ-3	;NEED THIS MUCH RAM
 2023:	  0656	F9			MOV	R1,A
 2024:	  0657	EA			MOV	A,R2
 2025:	  0658	94 00			SUBB	A,#0
 2026:	  065A	FB			MOV	R3,A
 2027:					;
 2028:					; Now save the new storage allocation
 2029:					;
 2030:	  065B	90 01 06		MOV	DPTR,#ST_ALL
 2031:	  065E	D1 0F			CALL	S31DP		;SAVE STORAGE ALLOCATION
 2032:					;
 2033:					; Now make sure we didn't blow it, by wiping out MT_ALL
 2034:					;
 2035:	  0660	B1 D6			ACALL	DCMPX		;COMPARE STORAGE ALLOCATION
 2036:	  0662	40 32			JC	CCLR3		;ERROR IF CARRY
 2037:	  0664	D3			SETB	C		;DID NOT FIND ENTRY
 2038:	  0665	22			RET			;EXIT IF TEST IS OK
 2039:					;
 2040:					;***************************************************************
 2041:					;
 2042:					; Command action routine - NEW
 2043:					;
 2044:					;***************************************************************
 2045:					;
 2046:	  0666	90 02 00	CNEW:	MOV	DPTR,#PSTART	;SAVE THE START OF PROGRAM
 2047:	  0669	74 01			MOV	A,#EOF		;END OF FILE
 2048:	  066B	F0			MOVX	@DPTR,A 	;PUT IT IN MEMORY
 2049:					;
 2050:					; falls thru
 2051:					;
 2052:					;*****************************************************************
 2053:					;
 2054:					; The statement action routine - CLEAR
 2055:					;
 2056:					;*****************************************************************
 2057:					;
 2058:	  066C	C2 15		CNEW1:	CLR	LINEB		;SET UP FOR RUN AND GOTO
 2059:					;
 2060:	  066E	B1 F1		RCLEAR: ACALL	LCLR		;CLEAR THE INTERRUPTS, SET UP MATRICES
 2061:	  0670	90 01 0A		MOV	DPTR,#MEMTOP	;PUT MEMTOP IN R3:R1
 2062:	  0673	B1 C4			ACALL	L31DPI
 2063:	  0675	B1 B3			ACALL	G4		;DPTR GETS END ADDRESS
 2064:	  0677	D1 87			ACALL	CL_1		;CLEAR THE MEMORY
 2065:					;
 2066:	  0679	90 00 FE	RC1:	MOV	DPTR,#STACKTP	;POINT AT CONTROL STACK TOP
 2067:	  067C	E4			CLR	A		;CONTROL UNDERFLOW
 2068:					;
 2069:	  067D	F0		RC2:	MOVX	@DPTR,A 	;SAVE IN MEMORY
 2070:	  067E	75 11 FE		MOV	CSTKA,#STACKTP
 2071:	  0681	75 09 FE		MOV	ASTKA,#STACKTP
 2072:	  0684	C2 17			CLR	CONB		;CAN'T CONTINUE
 2073:	  0686	22			RET
 2074:					;
 2075:					;***************************************************************
 2076:					;
 2077:					; Loop until the memory is cleared
 2078:					;
 2079:					;***************************************************************
 2080:					;
 2081:	  0687	A3		CL_1:	INC	DPTR		;BUMP MEMORY POINTER
 2082:	  0688	E4			CLR	A		;CLEAR THE MEMORY
 2083:	  0689	F0			MOVX	@DPTR,A 	;CLEAR THE RAM
 2084:	  068A	E0			MOVX	A,@DPTR 	;READ IT
 2085:	  068B	70 09			JNZ	CCLR3		;MAKE SURE IT IS CLEARED
 2086:	  068D	EB			MOV	A,R3		;GET POINTER FOR COMPARE
 2087:	  068E	B5 83 F6		CJNE	A,DPH,CL_1	;SEE TO LOOP
 2088:	  0691	E9			MOV	A,R1		;NOW TEST LOW BYTE
 2089:	  0692	B5 82 F2		CJNE	A,DPL,CL_1
 2090:					;
 2091:	  0695	22		CL_2:	RET
 2092:					;
 2093:	  0696	02 15 C2	CCLR3:	JMP	TB		;ALLOCATED MEMORY DOESN'T EXSIST
 2094:					;
 2095:					;**************************************************************
 2096:					;
 2097:	  0699			SCLR:	;Entry point for clear return
 2098:					;
 2099:					;**************************************************************
 2100:					;
 2101:	  0699	12 0E EC		CALL	DELTST		;TEST FOR A CR
 2102:	  069C	50 D0			JNC	RCLEAR
 2103:	  069E	12 0E E2		CALL	GCI1		;BUMP THE TEST POINTER
 2104:	  06A1	B4 49 D5		CJNE	A,#'I',RC1      ;SEE IF I, ELSE RESET THE STACK
 2105:					;
 2106:					;**************************************************************
 2107:					;
 2108:	  06A4			ICLR:	; Clear interrupts and system garbage
 2109:					;
 2110:					;**************************************************************
 2111:					;
 2112:	  06A4	30 12 02		JNB	INTBIT,ICLR1	;SEE IF BASIC HAS INTERRUPTS
 2113:	  06A7	C2 AA			CLR	EX1		;IF SO, CLEAR INTERRUPTS
 2114:	  06A9	53 22 20	ICLR1:	ANL	34,#00100000B	;SET INTERRUPTS + CONTINUE
 2115:	  06AC	32			RETI
 2116:					;
 2117:					;***************************************************************
 2118:					;
 2119:					;OUTPUT ROUTINES
 2120:					;
 2121:					;***************************************************************
 2122:					;
 2123:	  06AD	D1 AF		CRLF2:	ACALL	CRLF		;DO TWO CRLF'S
 2124:					;
 2125:	  06AF	7D 0D		CRLF:	MOV	R5,#CR		;LOAD THE CR
 2126:	  06B1	F1 1B			ACALL	TEROT		;CALL TERMINAL OUT
 2127:	  06B3	7D 0A			MOV	R5,#LF		;LOAD THE LF
 2128:	  06B5	E1 1B			AJMP	TEROT		;OUTPUT IT AND RETURN
 2129:					;
 2130:					;PRINT THE MESSAGE ADDRESSED IN ROM OR RAM BY THE DPTR
 2131:					;ENDS WITH THE CHARACTER IN R4
 2132:					;DPTR HAS THE ADDRESS OF THE TERMINATOR
 2133:					;
 2134:	  06B7	D1 AF		CRP:	ACALL	CRLF		;DO A CR THEN PRINT ROM
 2135:					;
 2136:	  06B9	E4		ROM_P:	CLR	A		;CLEAR A FOR LOOKUP
 2137:	  06BA	93			MOVC	A,@A+DPTR	;GET THE CHARACTER
 2138:	  06BB	C2 E7			CLR	ACC.7		;CLEAR MS BIT
 2139:	  06BD	B4 22 01		CJNE	A,#'"',ROM_P1   ;EXIT IF TERMINATOR
 2140:	  06C0	22			RET
 2141:	  06C1	D2 34		ROM_P1: SETB	C0ORX1
 2142:					;
 2143:	  06C3	FD		PN1:	MOV	R5,A		;OUTPUT THE CHARACTER
 2144:	  06C4	F1 1B			ACALL	TEROT
 2145:	  06C6	A3			INC	DPTR		;BUMP THE POINTER
 2146:	  06C7	80 04			SJMP	PN0
 2147:					;
 2148:	  06C9	B1 83		UPRNT:	ACALL	X31DP
 2149:					;
 2150:	  06CB	7C 0D		PRNTCR: MOV	R4,#CR		;OUTPUT UNTIL A CR
 2151:					;
 2152:	  06CD	10 34 E9	PN0:	JBC	C0ORX1,ROM_P
 2153:	  06D0	E0			MOVX	A,@DPTR 	;GET THE RAM BYTE
 2154:	  06D1	60 03			JZ	PN01
 2155:	  06D3	B5 04 01		CJNE	A,R4B0,PN02	;SEE IF THE SAME AS TERMINATOR
 2156:	  06D6	22		PN01:	RET			;EXIT IF THE SAME
 2157:	  06D7	B4 0D E9	PN02:	CJNE	A,#CR,PN1	;NEVER PRINT A CR IN THIS ROUTINE
 2158:	  06DA	02 18 92		LJMP	E1XX		;BAD SYNTAX
 2159:					;
 2160:					;***************************************************************
 2161:					;
 2162:					; INLINE - Input a line to IBUF, exit when a CR is received
 2163:					;
 2164:					;***************************************************************
 2165:					;
 2166:	  06DD	B4 04 16	INL2:	CJNE	A,#CNTRLD,INL2B ;SEE IF A CONTROL D
 2167:					;
 2168:	  06E0	D1 AF		INL0:	ACALL	CRLF		;DO A CR
 2169:					;
 2170:	  06E2	75 A0 00	INLINE: MOV	P2,#HIGH IBUF	;IBUF IS IN THE ZERO PAGE
 2171:	  06E5	78 07			MOV	R0,#LOW IBUF	;POINT AT THE INPUT BUFFER
 2172:					;
 2173:	  06E7	F1 9B		INL1:	ACALL	INCHAR		;GET A CHARACTER
 2174:	  06E9	FD			MOV	R5,A		;SAVE IN R5 FOR OUTPUT
 2175:	  06EA	B4 7F F0		CJNE	A,#7FH,INL2	;SEE IF A DELETE CHARACTER
 2176:	  06ED	B8 07 18		CJNE	R0,#LOW IBUF,INL6
 2177:	  06F0	7D 07		INL11:	MOV	R5,#BELL	;OUTPUT A BELL
 2178:					;
 2179:	  06F2	F1 1B		INLX:	ACALL	TEROT		;OUTPUT CHARACTER
 2180:	  06F4	80 F1			SJMP	INL1		;DO IT AGAIN
 2181:					;
 2182:	  06F6	F2		INL2B:	MOVX	@R0,A		;SAVE THE CHARACTER
 2183:	  06F7	B4 0D 02		CJNE	A,#CR,INL2B1	;IS IT A CR
 2184:	  06FA	C1 AF			AJMP	CRLF		;OUTPUT A CRLF AND EXIT
 2185:	  06FC	B4 20 00	INL2B1: CJNE	A,#20H,INL2B2
 2186:	  06FF	40 F1		INL2B2: JC	INLX		;ONLY ECHO CONTROL CHARACTERS
 2187:	  0701	08			INC	R0		;BUMP THE POINTER
 2188:	  0702	B8 56 ED		CJNE	R0,#IBUF+79,INLX
 2189:	  0705	18			DEC	R0		;FORCE 79
 2190:	  0706	80 E8			SJMP	INL11		;OUTPUT A BELL
 2191:					;
 2192:	  0708	18		INL6:	DEC	R0		;DEC THE RAM POINTER
 2193:	  0709	7D 08			MOV	R5,#BS		;OUTPUT A BACK SPACE
 2194:	  070B	F1 1B			ACALL	TEROT
 2195:	  070D	F1 19			ACALL	STEROT		;OUTPUT A SPACE
 2196:	  070F	7D 08			MOV	R5,#BS		;ANOTHER BACK SPACE
 2197:	  0711	80 DF			SJMP	INLX		;OUTPUT IT
 2198:				;
 2199:				;*****************************************************************************
 2200:				;****** Use XTAL up to 47 MHz ************************************************
 2201:				;****** Wulf 2 ***************************************************************
 2202:				;
 2203:				;PTIME: DB	128-2		;PROM PROGRAMMER TIMER
 2204:				;	DB	00H
 2205:				;	DB	00H
 2206:				;	DB	50H
 2207:				;	DB	67H
 2208:				;	DB	41H
 2209:				;
 2210:	  0713	7D		ptime:	db	128-3		;New programmer timer value is old value
 2211:	  0714	00			db	00H		;divide by 5
 2212:	  0715	00			db	00H		;(50ms EPROM timeing to 10ms for EEPROM)
 2213:	  0716	00			db	00H
 2214:	  0717	35			db	35H
 2215:	  0718	83			db	83H
 2216:				;
 2217:				;*****************************************************************************
 2218:				;
 2219:					;***************************************************************
 2220:					;
 2221:					; TEROT - Output a character to the system console
 2222:					;	  update PHEAD position.
 2223:					;
 2224:					;***************************************************************
 2225:					;
 2226:	  0719	7D 20		STEROT: MOV	R5,#' '         ;OUTPUT A SPACE
 2227:					;
 2228:	  071B	C0 E0		TEROT:	PUSH	ACC		;SAVE THE ACCUMULATOR
 2229:	  071D	C0 83			PUSH	DPH		;SAVE THE DPTR
 2230:	  071F	C0 82			PUSH	DPL
 2231:	  0721	30 35 04	TEROT01:JNB	CNT_S,TEROT02	;WAIT FOR A CONTROL Q
 2232:	  0724	F1 97			ACALL	BCK		;GET SERIAL STATUS
 2233:	  0726	80 F9			SJMP	TEROT01
 2234:	  0728	ED		TEROT02:MOV	A,R5		;PUT OUTPUT BYTE IN A
 2235:	  0729	30 2C 05		JNB	BO,TEROT03	;CHECK FOR MONITOR
 2236:	  072C	12 20 40		LCALL	2040H		;DO THE MONITOR
 2237:	  072F	E1 70			AJMP	TEROT1		;CLEAN UP
 2238:	  0731	30 1C 05	TEROT03:JNB	COUB,TEROT04	;SEE IF USER WANTS OUTPUT
 2239:	  0734	12 40 30		LCALL	4030H
 2240:	  0737	E1 70			AJMP	TEROT1
 2241:	  0739	30 27 08	TEROT04:JNB	UPB,T_1 	;NO AT IF NO XBIT
 2242:	  073C	30 19 05		JNB	LPB,T_1 	;AT PRINT
 2243:	  073F	12 40 3C		LCALL	403CH		;CALL AT LOCATION
 2244:	  0742	E1 70			AJMP	TEROT1		;FINISH OFF OUTPUT
 2245:					;
 2246:	  0744	30 1B 22	T_1:	JNB	COB,TXX 	;SEE IF LIST SET
 2247:	  0747	90 01 24		MOV	DPTR,#SPV	;LOAD BAUD RATE
 2248:	  074A	B1 8C			ACALL	LD_T
 2249:	  074C	C2 97			CLR	LP		;OUTPUT START BIT
 2250:	  074E	B1 37			ACALL	TIMER_LOAD	;LOAD AND START THE TIMER
 2251:	  0750	ED			MOV	A,R5		;GET THE OUTPUT BYTE
 2252:	  0751	D3			SETB	C		;SET CARRY FOR LAST OUTPUT
 2253:	  0752	7D 09			MOV	R5,#9		;LOAD TIMER COUNTDOWN
 2254:					;
 2255:	  0754	13		LTOUT1: RRC	A		;ROTATE A
 2256:	  0755	30 8F FD		JNB	TF1,$		;WAIT TILL TIMER READY
 2257:	  0758	92 97			MOV	LP,C		;OUTPUT THE BIT
 2258:	  075A	B1 37			ACALL	TIMER_LOAD	;DO THE NEXT BIT
 2259:	  075C	DD F6			DJNZ	R5,LTOUT1	;LOOP UNTIL DONE
 2260:	  075E	30 8F FD		JNB	TF1,$		;FIRST STOP BIT
 2261:	  0761	B1 37			ACALL	TIMER_LOAD
 2262:	  0763	30 8F FD		JNB	TF1,$		;SECOND STOP BIT
 2263:	  0766	FD			MOV	R5,A		;RESTORE R5
 2264:	  0767	80 07			SJMP	TEROT1		;BACK TO TEROT
 2265:					;
 2266:	  0769	30 99 FD	TXX:	JNB	TI,$		;WAIT FOR TRANSMIT READY
 2267:	  076C	C2 99			CLR	TI
 2268:	  076E	8D 99			MOV	SBUF,R5 	;SEND OUT THE CHARACTER
 2269:					;
 2270:	  0770	BD 0D 03	TEROT1: CJNE	R5,#CR,TEROT11	;SEE IF A CR
 2271:	  0773	75 16 00		MOV	PHEAD,#00H	;IF A CR, RESET PHEAD AND
 2272:					;
 2273:	  0776	BD 0A 0B	TEROT11:CJNE	R5,#LF,NLC	;SEE IF A LF
 2274:	  0779	E5 15			MOV	A,NULLCT	;GET THE NULL COUNT
 2275:	  077B	60 07			JZ	NLC		;NO NULLS IF ZERO
 2276:					;
 2277:	  077D	7D 00		TEROT2: MOV	R5,#NULL	;PUT THE NULL IN THE OUTPUT REGISTER
 2278:	  077F	F1 1B			ACALL	TEROT		;OUTPUT THE NULL
 2279:	  0781	14			DEC	A		;DECREMENT NULL COUNT
 2280:	  0782	70 F9			JNZ	TEROT2		;LOOP UNTIL DONE
 2281:					;
 2282:	  0784	BD 08 02	NLC:	CJNE	R5,#BS,NLC1	;DEC PHEAD IF A BACKSPACE
 2283:	  0787	15 16			DEC	PHEAD
 2284:	  0789	BD 20 00	NLC1:	CJNE	R5,#20H,NLC2	;IS IT A PRINTABLE CHARACTER?
 2285:	  078C	40 02		NLC2:	JC	NLC3		;DON'T INCREMENT PHEAD IF NOT PRINTABLE
 2286:	  078E	05 16			INC	PHEAD		;BUMP PRINT HEAD
 2287:	  0790	D0 82		NLC3:	POP	DPL		;RESTORE DPTR
 2288:	  0792	D0 83			POP	DPH
 2289:	  0794	D0 E0			POP	ACC		;RESTORE ACC
 2290:	  0796	22			RET			;EXIT
 2291:					;
 2292:	  0797	F1 D2		BCK:	ACALL	CSTS		;CHECK STATUS
 2293:	  0799	50 2E			JNC	CI_RET1 	;EXIT IF NO CHARACTER
 2294:					;
 2295:					;***************************************************************
 2296:					;
 2297:					;INPUTS A CHARACTER FROM THE SYSTEM CONSOLE.
 2298:					;
 2299:					;***************************************************************
 2300:					;
 2301:	  079B	30 32 05	INCHAR: JNB	BI,INCHAR1	;CHECK FOR MONITOR (BUBBLE)
 2302:	  079E	12 20 60		LCALL	2060H
 2303:	  07A1	80 11			SJMP	INCH1
 2304:	  07A3	30 1E 05	INCHAR1:JNB	CIUB,INCHAR2	;CHECK FOR USER
 2305:	  07A6	12 40 33		LCALL	4033H
 2306:	  07A9	80 09			SJMP	INCH1
 2307:	  07AB	30 98 FD	INCHAR2:JNB	RI,$		;WAIT FOR RECEIVER READY.
 2308:	  07AE	E5 99			MOV	A,SBUF
 2309:	  07B0	C2 98			CLR	RI		;RESET READY
 2310:	  07B2	C2 E7			CLR	ACC.7		;NO BIT 7
 2311:					;
 2312:	  07B4	B4 13 02	INCH1:	CJNE	A,#13H,INCH11
 2313:	  07B7	D2 35			SETB	CNT_S
 2314:	  07B9	B4 11 02	INCH11: CJNE	A,#11H,INCH12
 2315:	  07BC	C2 35			CLR	CNT_S
 2316:	  07BE	B4 03 04	INCH12: CJNE	A,#CNTRLC,INCH13
 2317:	  07C1	30 30 1D		JNB	NO_C,C_EX	;TRAP NO CONTROL C
 2318:	  07C4	22			RET
 2319:					;
 2320:				;
 2321:				;*****************************************************************************
 2322:				;****** Sorry - but the ego message had to be disabled ***********************
 2323:				;
 2324:	  07C5			INCH13:
 2325:				;	CLR	JKBIT
 2326:	  07C5	B4 17 00		CJNE	A,#17H,CI_RET	;CONTROL W
 2327:				;	SETB	JKBIT
 2328:				;
 2329:				;*****************************************************************************
 2330:					;
 2331:	  07C8	D3		CI_RET: SETB	C		;CARRY SET IF A CHARACTER
 2332:	  07C9	22		CI_RET1:RET			;EXIT
 2333:					;
 2334:					;*************************************************************
 2335:					;
 2336:					;RROM - The Statement Action Routine RROM
 2337:					;
 2338:					;*************************************************************
 2339:					;
 2340:	  07CA	D2 1D		RROM:	SETB	INBIT		;SO NO ERRORS
 2341:	  07CC	B1 4D			ACALL	RO1		;FIND THE LINE NUMBER
 2342:	  07CE	10 1D 3B		JBC	INBIT,CRUN
 2343:	  07D1	22			RET			;EXIT
 2344:					;
 2345:					;***************************************************************
 2346:					;
 2347:	  07D2			CSTS:	;	RETURNS CARRY = 1 IF THERE IS A CHARACTER WAITING FROM
 2348:					;	THE SYSTEM CONSOLE. IF NO CHARACTER THE READY CHARACTER
 2349:					;	WILL BE CLEARED
 2350:					;
 2351:					;***************************************************************
 2352:					;
 2353:	  07D2	30 32 03		JNB	BI,CSTS1	;BUBBLE STATUS
 2354:	  07D5	02 20 68		LJMP	2068H
 2355:	  07D8	30 1E 03	CSTS1:	JNB	CIUB,CSTS2	;SEE IF EXTERNAL CONSOLE
 2356:	  07DB	02 40 36		LJMP	4036H
 2357:	  07DE	A2 98		CSTS2:	MOV	C,RI
 2358:	  07E0	22			RET
 2359:					;
 2360:				;
 2361:				;*****************************************************************************
 2362:				;****** Sorry - but the ego message had to be disabled ***********************
 2363:				;
 2364:				;C_EX0:  MOV	 DPTR,#WB	 ;EGO MESSAGE
 2365:				;	 ACALL	 ROM_P
 2366:				;
 2367:				;*****************************************************************************
 2368:					;
 2369:	  07E1	C2 35		C_EX:	CLR	CNT_S		;NO OUTPUT STOP
 2370:	  07E3	12 0C 3B		LCALL	SPRINT1 	;ASSURE CONSOLE
 2371:	  07E6	D1 AF			ACALL	CRLF
 2372:				;
 2373:				;*****************************************************************************
 2374:				;****** Sorry - but the ego message had to be disabled ***********************
 2375:				;
 2376:				;	 JBC	 JKBIT,C_EX0
 2377:				;
 2378:				;*****************************************************************************
 2379:				;
 2380:	  07E8	30 2F 7F		JNB	DIRF,SSTOP0
 2381:	  07EB	A1 4A			AJMP	C_K		;CLEAR COB AND EXIT
 2382:					;
 2383:	  07ED	E5 48		T_CMP:	MOV	A,TVH		;COMPARE TIMER TO SP_H AND SP_L
 2384:	  07EF	A9 49			MOV	R1,TVL
 2385:	  07F1	B5 48 F9		CJNE	A,TVH,T_CMP
 2386:	  07F4	C9			XCH	A,R1
 2387:	  07F5	95 4C			SUBB	A,SP_L
 2388:	  07F7	E9			MOV	A,R1
 2389:	  07F8	95 4B			SUBB	A,SP_H
 2390:	  07FA	22			RET
 2391:					;
 2392:					;*************************************************************
 2393:					;
 2394:	  07FB			BR0:	; Trap the timer interrupt
 2395:					;
 2396:					;*************************************************************
 2397:					;
 2398:	  07FB	F1 ED			CALL	T_CMP		;COMPARE TIMER
 2399:	  07FD	40 40			JC	BCHR1		;EXIT IF TEST FAILS
 2400:	  07FF	D2 14			SETB	OTI		;DOING THE TIMER INTERRUPT
 2401:	  0801	C2 10			CLR	OTS		;CLEAR TIMER BIT
 2402:	  0803	A2 11			MOV	C,INPROG	;SAVE IN PROGRESS
 2403:	  0805	92 2B			MOV	ISAV,C
 2404:	  0807	90 01 26		MOV	DPTR,#TIV
 2405:	  080A	80 3C			SJMP	BR2
 2406:					;
 2407:					;***************************************************************
 2408:					;
 2409:					; The command action routine - RUN
 2410:					;
 2411:					;***************************************************************
 2412:					;
 2413:	  080C	12 06 6C	CRUN:	LCALL	CNEW1		;CLEAR THE STORAGE ARRAYS
 2414:	  080F	71 DA			ACALL	SRESTR1 	;GET THE STARTING ADDRESS
 2415:	  0811	51 AE			ACALL	B_C
 2416:	  0813	60 4A			JZ	CMNDLK		;IF NULL GO TO COMMAND MODE
 2417:					;
 2418:	  0815	D1 C3			ACALL	T_DP
 2419:	  0817	F1 2E			ACALL	B_TXA		;BUMP TO STARTING LINE
 2420:					;
 2421:	  0819	91 46		CILOOP: ACALL	SP0		;DO A CR AND A LF
 2422:	  081B	C2 2F		CILOOP1:CLR	DIRF		;NOT IN DIRECT MODE
 2423:					;
 2424:					;INTERPERTER DRIVER
 2425:					;
 2426:	  081D	85 3E 81	ILOOP:	MOV	SP,SPSAV	;RESTORE THE STACK EACH TIME
 2427:	  0820	20 2F 06		JB	DIRF,ILOOP1	;NO INTERRUPTS IF IN DIRECT MODE
 2428:	  0823	85 0A 42		MOV	INTXAH,TXAH	;SAVE THE TEXT POINTER
 2429:	  0826	85 08 43		MOV	INTXAL,TXAL
 2430:	  0829	12 07 97	ILOOP1: LCALL	BCK		;GET CONSOLE STATUS
 2431:	  082C	20 2F 24		JB	DIRF,I_L	;DIRECT MODE
 2432:	  082F	B0 18			ANL	C,/GTRD 	;SEE IF CHARACTER READY
 2433:	  0831	50 06			JNC	BCHR		;NO CHARACTER = NO CARRY
 2434:					;
 2435:					; DO TRAP OPERATION
 2436:					;
 2437:	  0833	90 01 00		MOV	DPTR,#GTB	;SAVE TRAP CHARACTER
 2438:	  0836	F0			MOVX	@DPTR,A
 2439:	  0837	D2 18			SETB	GTRD		;SAYS READ A BYTE
 2440:					;
 2441:	  0839	20 14 17	BCHR:	JB	OTI,I_L 	;EXIT IF TIMER INTERRUPT IN PROGRESS
 2442:	  083C	20 10 BC		JB	OTS,BR0 	;TEST TIMER VALUE IF SET
 2443:	  083F	30 16 11	BCHR1:	JNB	INTPEN,I_L	;SEE IF INTERRUPT PENDING
 2444:	  0842	20 11 0E		JB	INPROG,I_L	;DON'T DO IT AGAIN IF IN PROGRESS
 2445:	  0845	90 01 20		MOV	DPTR,#INTLOC	;POINT AT INTERRUPT LOCATION
 2446:					;
 2447:	  0848	7C 02		BR2:	MOV	R4,#GTYPE	;SETUP FOR A FORCED GOSUB
 2448:	  084A	71 3F			ACALL	SGS1		;PUT TXA ON STACK
 2449:	  084C	D2 11			SETB	INPROG		;INTERRUPT IN PROGRESS
 2450:					;
 2451:	  084E	12 05 7D	ERL4:	CALL	L20DPI
 2452:	  0851	61 02			AJMP	D_L1		;GET THE LINE NUMBER
 2453:					;
 2454:	  0853	31 02		I_L:	ACALL	ISTAT		;LOOP
 2455:	  0855	F1 22			ACALL	CLN_UP		;FINISH IT OFF
 2456:	  0857	50 C4			JNC	ILOOP		;LOOP ON THE DRIVER
 2457:	  0859	30 2F 03		JNB	DIRF,CMNDLK	;CMND1 IF IN RUN MODE
 2458:	  085C	02 17 A1		LJMP	CMNDR		;DON'T PRINT READY
 2459:					;
 2460:	  085F	02 17 94	CMNDLK: JMP	CMND1		;DONE
 2461:					;**************************************************************
 2462:					;
 2463:					; The Statement Action Routine - STOP
 2464:					;
 2465:					;**************************************************************
 2466:					;
 2467:	  0862	F1 22		SSTOP:	ACALL	CLN_UP		;FINISH OFF THIS LINE
 2468:	  0864	85 0A 42		MOV	INTXAH,TXAH	;SAVE TEXT POINTER FOR CONT
 2469:	  0867	85 08 43		MOV	INTXAL,TXAL
 2470:					;
 2471:	  086A	D2 17		SSTOP0: SETB	CONB		;CONTINUE WILL WORK
 2472:	  086C	90 00 EE		MOV	DPTR,#STP	;PRINT THE STOP MESSAGE
 2473:	  086F	D2 20			SETB	STOPBIT 	;SET FOR ERROR ROUTINE
 2474:	  0871	02 18 BA		JMP	ERRS		;JUMP TO ERROR ROUTINE
 2475:					;
 2476:					;**************************************************************
 2477:					;
 2478:					; ITRAP - Trap special function register operators
 2479:					;
 2480:					;**************************************************************
 2481:					;
 2482:	  0874	B4 C8 05	ITRAP:	CJNE	A,#TMR0,ITRAP1	;TIMER 0
 2483:	  0877	8B 8C			MOV	TH0,R3
 2484:	  0879	89 8A			MOV	TL0,R1
 2485:	  087B	22			RET
 2486:					;
 2487:	  087C	B4 C9 05	ITRAP1: CJNE	A,#TMR1,ITRAP2	;TIMER 1
 2488:	  087F	8B 8D			MOV	TH1,R3
 2489:	  0881	89 8B			MOV	TL1,R1
 2490:	  0883	22			RET
 2491:					;
 2492:	  0884	B4 CA 05	ITRAP2: CJNE	A,#TMR2,ITRAP3	;TIMER 2
 2493:	  0887	8B CD		ITRAP21:MOV	TH2,R3
 2494:	  0889	89 CC			MOV	TL2,R1
 2495:				;	DB	8BH		;MOV R3 DIRECT OP CODE
 2496:				;	DB	0CDH		;T2H LOCATION
 2497:				;	DB	89H		;MOV R1 DIRECT OP CODE
 2498:				;	DB	0CCH		;T2L LOCATION
 2499:	  088B	22			RET
 2500:					;
 2501:	  088C	B4 CE 05	ITRAP3: CJNE	A,#TRC2,RCL1	;RCAP2 TOKEN
 2502:	  088F	8B CB		RCL:	MOV	RCAPH2,R3
 2503:	  0891	89 CA			MOV	RCAPL2,R1
 2504:				;	DB	8BH		;MOV R3 DIRECT OP CODE
 2505:				;	DB	0CBH		;RCAP2H LOCATION
 2506:				;	DB	89H		;MOV R1 DIRECT OP CODE
 2507:				;	DB	0CAH		;RCAP2L LOCATION
 2508:	  0893	22			RET
 2509:					;
 2510:	  0894	31 DF		RCL1:	ACALL	R3CK		;MAKE SURE THAT R3 IS ZERO
 2511:	  0896	B4 CB 03		CJNE	A,#TT2C,RCL2
 2512:	  0899	89 C8			MOV	T2CON,R1
 2513:				;	DB	89H		;MOV R1 DIRECT OP CODE
 2514:				;	DB	0C8H		;T2CON LOCATION
 2515:	  089B	22			RET
 2516:					;
 2517:	  089C	B4 C6 03	RCL2:	CJNE	A,#T_IE,RCL3	;IE TOKEN
 2518:	  089F	89 A8			MOV	IE,R1
 2519:	  08A1	22			RET
 2520:					;
 2521:	  08A2	B4 C7 03	RCL3:	CJNE	A,#T_IP,RCL4	;IP TOKEN
 2522:	  08A5	89 B8			MOV	IP,R1
 2523:	  08A7	22			RET
 2524:					;
 2525:	  08A8	B4 CC 03	RCL4:	CJNE	A,#TTC,RCL5	;TCON TOKEN
 2526:	  08AB	89 88			MOV	TCON,R1
 2527:	  08AD	22			RET
 2528:					;
 2529:	  08AE	B4 CD 03	RCL5:	CJNE	A,#TTM,RCL6	;TMOD TOKEN
 2530:	  08B1	89 89			MOV	TMOD,R1
 2531:	  08B3	22			RET
 2532:					;
 2533:	  08B4	B4 CF 32	RCL6:	CJNE	A,#T_P1,T_T2	;P1 TOKEN
 2534:	  08B7	89 90			MOV	P1,R1
 2535:	  08B9	22			RET
 2536:					;
 2537:					;***************************************************************
 2538:					;
 2539:					; T_TRAP - Trap special operators
 2540:					;
 2541:					;***************************************************************
 2542:					;
 2543:	  08BA	F5 0F		T_T:	MOV	TEMP5,A 	;SAVE THE TOKEN
 2544:	  08BC	D1 E2			ACALL	GCI1		;BUMP POINTER
 2545:	  08BE	31 D2			ACALL	SLET2		;EVALUATE AFTER =
 2546:	  08C0	E5 0F			MOV	A,TEMP5 	;GET THE TOKEN BACK
 2547:	  08C2	B4 C3 03		CJNE	A,#T_XTAL,T_T01
 2548:	  08C5	02 16 69		LJMP	AXTAL1		;SET UP CRYSTAL
 2549:					;
 2550:	  08C8	D1 9B		T_T01:	ACALL	IFIXL		;R3:R1 HAS THE TOS
 2551:	  08CA	E5 0F			MOV	A,TEMP5 	;GET THE TOKEN AGAIN
 2552:	  08CC	B4 C4 09		CJNE	A,#T_MTOP,T_T1	;SEE IF MTOP TOKEN
 2553:	  08CF	90 01 0A		MOV	DPTR,#MEMTOP
 2554:	  08D2	12 06 0F		CALL	S31DP
 2555:	  08D5	02 06 6E		JMP	RCLEAR		;CLEAR THE MEMORY
 2556:					;
 2557:	  08D8	B4 C5 99	T_T1:	CJNE	A,#T_TIME,ITRAP ;SEE IF A TIME TOKEN
 2558:	  08DB	A2 AF			MOV	C,EA		;SAVE INTERRUPTS
 2559:	  08DD	C2 AF			CLR	EA		;NO TIMER 0 INTERRUPTS DURING LOAD
 2560:	  08DF	8B 48			MOV	TVH,R3		;SAVE THE TIME
 2561:	  08E1	89 49			MOV	TVL,R1
 2562:				;
 2563:				;*****************************************************************************
 2564:				;****** Reset millisecond counter on "TIME=" *********************************
 2565:				;****** Boehling 2 ***********************************************************
 2566:				;
 2567:	  08E3	75 47 00		mov	MILLIV,#0	;Reset millisecond counter
 2568:				;
 2569:				;*****************************************************************************
 2570:				;
 2571:	  08E6	92 AF			MOV	EA,C		;RESTORE INTERRUPTS
 2572:	  08E8	22			RET			;EXIT
 2573:					;
 2574:	  08E9	B4 D0 56	T_T2:	CJNE	A,#T_PC,INTERX	;PCON TOKEN
 2575:	  08EC	89 87			MOV	PCON,R1
 2576:				;	DB	89H		;MOV DIRECT, R1 OP CODE
 2577:				;	DB	87H		;ADDRESS OF PCON
 2578:	  08EE	22			RET			;EXIT
 2579:					;
 2580:	  08EF	B4 D1 C8	T_TRAP: CJNE	A,#T_ASC,T_T	;SEE IF ASC TOKEN
 2581:	  08F2	D1 D6			ACALL	IGC		;EAT IT AND GET THE NEXT CHARACTER
 2582:	  08F4	B4 24 4B		CJNE	A,#'$',INTERX   ;ERROR IF NOT A STRING
 2583:	  08F7	51 28			ACALL	CSY		;CALCULATE ADDRESS
 2584:	  08F9	B1 B8			ACALL	X3120
 2585:	  08FB	12 14 C1		CALL	TWO_EY
 2586:	  08FE	31 E7			ACALL	SPEOP1		;EVALUATE AFTER EQUALS
 2587:	  0900	21 2B			AJMP	ISTAX1		;SAVE THE CHARACTER
 2588:					;
 2589:					;**************************************************************
 2590:					;
 2591:					;INTERPERT THE STATEMENT POINTED TO BY TXAL AND TXAH
 2592:					;
 2593:					;**************************************************************
 2594:					;
 2595:	  0902	D1 D8		ISTAT:	ACALL	GC		;GET THR FIRST CHARACTER
 2596:	  0904	30 2D 0E		JNB	XBIT,IAT	;TRAP TO EXTERNAL RUN PACKAGE
 2597:	  0907	B4 20 00		CJNE	A,#20H,ISTAT1
 2598:	  090A	50 09		ISTAT1: JNC	IAT
 2599:	  090C	12 20 70		LCALL	2070H		;LET THE USER SET UP THE DPTR
 2600:	  090F	D1 E2			ACALL	GCI1
 2601:	  0911	54 0F			ANL	A,#0FH		;STRIP OFF BIAS
 2602:	  0913	80 51			SJMP	ISTA1
 2603:					;
 2604:	  0915	B4 C3 00	IAT:	CJNE	A,#T_XTAL,IAT1
 2605:	  0918	50 D5		IAT1:	JNC	T_TRAP
 2606:	  091A	30 E7 5B		JNB	ACC.7,SLET	;IMPLIED LET IF BIT 7 NOT SET
 2607:	  091D	B4 BC 06		CJNE	A,#T_UOP+12,ISTAX	;DBYTE TOKEN
 2608:	  0920	31 E3			ACALL	SPEOP		;EVALUATE SPECIAL OPERATOR
 2609:	  0922	31 DF			ACALL	R3CK		;CHECK LOCATION
 2610:	  0924	F7			MOV	@R1,A		;SAVE IT
 2611:	  0925	22			RET
 2612:					;
 2613:	  0926	B4 BD 06	ISTAX:	CJNE	A,#T_UOP+13,ISTAY	;XBYTE TOKEN
 2614:	  0929	31 E3			ACALL	SPEOP
 2615:					;
 2616:	  092B	8B A0		ISTAX1: MOV	P2,R3
 2617:	  092D	F3			MOVX	@R1,A
 2618:	  092E	22			RET
 2619:					;
 2620:	  092F	B4 AB 00	ISTAY:	CJNE	A,#T_CR+1,ISTAY1;TRAP NEW OPERATORS
 2621:	  0932	40 09		ISTAY1: JC	I_S
 2622:	  0934	B4 B0 00		CJNE	A,#0B0H,ISTAY2	;SEE IF TOO BIG
 2623:	  0937	50 09		ISTAY2: JNC	INTERX
 2624:	  0939	24 F9			ADD	A,#0F9H 	;BIAS FOR LOOKUP TABLE
 2625:	  093B	80 1D			SJMP	ISTA0		;DO THE OPERATION
 2626:					;
 2627:	  093D	B4 A4 00	I_S:	CJNE	A,#T_LAST,I_S1	;MAKE SURE AN INITIAL RESERVED WORD
 2628:	  0940	40 03		I_S1:	JC	INTERX1 	;ERROR IF NOT
 2629:					;
 2630:	  0942	02 18 92	INTERX: LJMP	E1XX		;SYNTAX ERROR
 2631:					;
 2632:	  0945	30 2F 12	INTERX1:JNB	DIRF,ISTA0	;EXECUTE ALL STATEMENTS IF IN RUN MODE
 2633:	  0948	B4 90 00		CJNE	A,#T_DIR,INTERX2;SEE IF ON TOKEN
 2634:	  094B	40 0D		INTERX2:JC	ISTA0		;OK IF DIRECT
 2635:	  094D	B4 A0 02		CJNE	A,#T_GOSB+1,INTERX3;SEE IF FOR
 2636:	  0950	80 08			SJMP	ISTA0		;FOR IS OK
 2637:	  0952	B4 97 02	INTERX3:CJNE	A,#T_REM+1,INTERX4	;NEXT IS OK
 2638:	  0955	80 03			SJMP	ISTA0
 2639:	  0957	B4 96 E8	INTERX4:CJNE	A,#T_STOP+6,INTERX	;SO IS REM
 2640:					;
 2641:	  095A	D1 E2		ISTA0:	ACALL	GCI1		;ADVANCE THE TEXT POINTER
 2642:	  095C	90 01 23		MOV	DPTR,#STATD	;POINT DPTR TO LOOKUP TABLE
 2643:	  095F	B4 80 02		CJNE	A,#T_GOTO-3,ISTA01;SEE IF LET TOKEN
 2644:	  0962	80 9E			SJMP	ISTAT		;WASTE LET TOKEN
 2645:	  0964	54 3F		ISTA01: ANL	A,#3FH		;STRIP OFF THE GARBAGE
 2646:					;
 2647:	  0966	23		ISTA1:	RL	A		;ROTATE FOR OFFSET
 2648:	  0967	25 82			ADD	A,DPL		;BUMP
 2649:	  0969	F5 82			MOV	DPL,A		;SAVE IT
 2650:	  096B	E4			CLR	A
 2651:	  096C	93			MOVC	A,@A+DPTR	;GET HIGH BYTE
 2652:	  096D	C0 E0			PUSH	ACC		;SAVE IT
 2653:	  096F	A3			INC	DPTR
 2654:	  0970	E4			CLR	A
 2655:	  0971	93			MOVC	A,@A+DPTR	;GET LOW BYTE
 2656:	  0972	D0 83			POP	DPH
 2657:	  0974	F5 82			MOV	DPL,A
 2658:					;
 2659:	  0976	E4		AC1:	CLR	A
 2660:	  0977	73			JMP	@A+DPTR 	;GO DO IT
 2661:					;
 2662:					;***************************************************************
 2663:					;
 2664:					; The statement action routine - LET
 2665:					;
 2666:					;***************************************************************
 2667:					;
 2668:	  0978	D1 CA		SLET:	ACALL	S_C		;CHECK FOR POSSIBLE STRING
 2669:	  097A	40 50			JC	SLET0		;NO STRING
 2670:	  097C	C2 15			CLR	LINEB		;USED STRINGS
 2671:					;
 2672:	  097E	12 05 83		CALL	X31DP		;PUT ADDRESS IN DPTR
 2673:	  0981	7F EA			MOV	R7,#T_EQU	;WASTE =
 2674:	  0983	91 F0			ACALL	EATC
 2675:	  0985	D1 D8			ACALL	GC		;GET THE NEXT CHARACTER
 2676:	  0987	B4 22 11		CJNE	A,#'"',S_3      ;CHECK FOR A "
 2677:	  098A	AF 3F			MOV	R7,S_LEN	;GET THE STRING LENGTH
 2678:					;
 2679:	  098C	D1 E2		S_0:	ACALL	GCI1		;BUMP PAST "
 2680:	  098E	D1 EC			ACALL	DELTST		;CHECK FOR DELIMITER
 2681:	  0990	60 B0			JZ	INTERX		;EXIT IF CARRIAGE RETURN
 2682:	  0992	F0			MOVX	@DPTR,A 	;SAVE THE CHARACTER
 2683:	  0993	B4 22 26		CJNE	A,#'"',S_1      ;SEE IF DONE
 2684:					;
 2685:	  0996	74 0D		S_E:	MOV	A,#CR		;PUT A CR IN A
 2686:	  0998	F0			MOVX	@DPTR,A 	;SAVE CR
 2687:	  0999	C1 E2			AJMP	GCI1
 2688:					;
 2689:	  099B	C0 83		S_3:	PUSH	DPH
 2690:	  099D	C0 82			PUSH	DPL		;SAVE DESTINATION
 2691:	  099F	D1 CA			ACALL	S_C		;CALCULATE SOURCE
 2692:	  09A1	40 9F			JC	INTERX		;ERROR IF CARRY
 2693:	  09A3	D0 00			POP	R0B0		;GET DESTINATION BACK
 2694:	  09A5	D0 02			POP	R2B0
 2695:					;
 2696:	  09A7	AF 3F		SSOOP:	MOV	R7,S_LEN	;SET UP COUNTER
 2697:					;
 2698:	  09A9	12 15 A3	S_4:	CALL	TBYTE		;TRANSFER THE BYTE
 2699:	  09AC	B4 0D 01		CJNE	A,#CR,S_41	;EXIT IF A CR
 2700:	  09AF	22			RET
 2701:	  09B0	DF 05		S_41:	DJNZ	R7,S_5		;BUMP COUNTER
 2702:	  09B2	74 0D			MOV	A,#CR		;SAVE A CR
 2703:	  09B4	F2			MOVX	@R0,A
 2704:	  09B5	C1 59			AJMP	EIGP		;PRINT EXTRA IGNORED
 2705:					;
 2706:					;
 2707:	  09B7	12 15 83	S_5:	CALL	INC3210 	;BUMP POINTERS
 2708:	  09BA	80 ED			SJMP	S_4		;LOOP
 2709:					;
 2710:	  09BC	DF 06		S_1:	DJNZ	R7,S_11 	;SEE IF DONE
 2711:	  09BE	31 96			ACALL	S_E
 2712:	  09C0	D1 59			ACALL	EIGP		;PRINT EXTRA IGNORED
 2713:	  09C2	C1 F7			AJMP	FINDCR		;GO FIND THE END
 2714:	  09C4	A3		S_11:	INC	DPTR		;BUMP THE STORE POINTER
 2715:	  09C5	80 C5			SJMP	S_0		;CONTINUE TO LOOP
 2716:					;
 2717:	  09C7	90 18 35	E3XX:	MOV	DPTR,#E3X	;BAD ARG ERROR
 2718:	  09CA	81 18			AJMP	EK
 2719:					;
 2720:	  09CC	31 D0		SLET0:	ACALL	SLET1
 2721:	  09CE	E1 DE			AJMP	POPAS		;COPY EXPRESSION TO VARIABLE
 2722:					;
 2723:	  09D0	F1 0C		SLET1:	ACALL	VAR_ER		;CHECK FOR A"VARIABLE"
 2724:					;
 2725:	  09D2	C0 02		SLET2:	PUSH	R2B0		;SAVE THE VARIABLE ADDRESS
 2726:	  09D4	C0 00			PUSH	R0B0
 2727:	  09D6	7F EA			MOV	R7,#T_EQU	;GET EQUAL TOKEN
 2728:	  09D8	F1 4C			ACALL	WE
 2729:	  09DA	D0 01			POP	R1B0		;POP VARIABLE TO R3:R1
 2730:	  09DC	D0 03			POP	R3B0
 2731:	  09DE	22			RET			;EXIT
 2732:					;
 2733:	  09DF	BB 00 E5	R3CK:	CJNE	R3,#00H,E3XX	;CHECK TO SEE IF R3 IS ZERO
 2734:	  09E2	22			RET
 2735:					;
 2736:	  09E3	D1 E2		SPEOP:	ACALL	GCI1		;BUMP TXA
 2737:	  09E5	91 EA			ACALL	P_E		;EVALUATE PAREN
 2738:	  09E7	31 D2		SPEOP1: ACALL	SLET2		;EVALUATE AFTER =
 2739:	  09E9	12 14 AE		CALL	TWOL		;R7:R6 GETS VALUE, R3:R1 GETS LOCATION
 2740:	  09EC	EE			MOV	A,R6		;SAVE THE VALUE
 2741:					;
 2742:	  09ED	BF 00 D7		CJNE	R7,#00H,E3XX	;R2 MUST BE = 0
 2743:	  09F0	22			RET
 2744:					;
 2745:					;**************************************************************
 2746:					;
 2747:					; ST_CAL - Calculate string Address
 2748:					;
 2749:					;**************************************************************
 2750:					;
 2751:	  09F1			IST_CAL:;
 2752:					;
 2753:	  09F1	D1 A0			ACALL	I_PI		;BUMP TEXT, THEN EVALUATE
 2754:	  09F3	31 DF			ACALL	R3CK		;ERROR IF R3 <> 0
 2755:	  09F5	09			INC	R1		;BUMP FOR OFFSET
 2756:	  09F6	E9			MOV	A,R1		;ERROR IF R1 = 255
 2757:	  09F7	60 CE			JZ	E3XX
 2758:	  09F9	90 01 04		MOV	DPTR,#VARTOP	;GET TOP OF VARIABLE STORAGE
 2759:	  09FC	85 3F F0		MOV	B,S_LEN 	;MULTIPLY FOR LOCATION
 2760:	  09FF	51 1A			ACALL	VARD		;CALCULATE THE LOCATION
 2761:	  0A01	90 01 0A		MOV	DPTR,#MEMTOP	;SEE IF BLEW IT
 2762:	  0A04	12 15 BD		CALL	FUL1
 2763:	  0A07	85 3F 82		MOV	DPL,S_LEN	;GET STRING LENGTH, DPH = 00H
 2764:	  0A0A	15 83			DEC	DPH		;DPH = 0
 2765:					;
 2766:	  0A0C	C3		DUBSUB: CLR	C
 2767:	  0A0D	E9			MOV	A,R1
 2768:	  0A0E	95 82			SUBB	A,DPL
 2769:	  0A10	F9			MOV	R1,A
 2770:	  0A11	EB			MOV	A,R3
 2771:	  0A12	95 83			SUBB	A,DPH
 2772:	  0A14	FB			MOV	R3,A
 2773:	  0A15	49			ORL	A,R1
 2774:	  0A16	22			RET
 2775:					;
 2776:					;***************************************************************
 2777:					;
 2778:					;VARD - Calculate the offset base
 2779:					;
 2780:					;***************************************************************
 2781:					;
 2782:	  0A17	75 F0 06	VARB:	MOV	B,#FPSIZ	;SET UP FOR OPERATION
 2783:					;
 2784:	  0A1A	12 05 BA	VARD:	CALL	LDPTRI		;LOAD DPTR
 2785:	  0A1D	E9			MOV	A,R1		;MULTIPLY BASE
 2786:	  0A1E	A4			MUL	AB
 2787:	  0A1F	25 82			ADD	A,DPL
 2788:	  0A21	F9			MOV	R1,A
 2789:	  0A22	E5 F0			MOV	A,B
 2790:	  0A24	35 83			ADDC	A,DPH
 2791:	  0A26	FB			MOV	R3,A
 2792:	  0A27	22			RET
 2793:					;
 2794:					;*************************************************************
 2795:					;
 2796:	  0A28			CSY:	; Calculate a biased string address and put in R3:R1
 2797:					;
 2798:					;*************************************************************
 2799:					;
 2800:	  0A28	31 F1			ACALL	IST_CAL 	;CALCULATE IT
 2801:	  0A2A	C0 03			PUSH	R3B0		;SAVE IT
 2802:	  0A2C	C0 01			PUSH	R1B0
 2803:	  0A2E	7F 2C			MOV	R7,#','         ;WASTE THE COMMA
 2804:	  0A30	91 F0			ACALL	EATC
 2805:	  0A32	D1 99			ACALL	ONE		;GET THE NEXT EXPRESSION
 2806:	  0A34	E9			MOV	A,R1		;CHECK FOR BOUNDS
 2807:	  0A35	B5 3F 00		CJNE	A,S_LEN,CSY1
 2808:	  0A38	50 8D		CSY1:	JNC	E3XX		;MUST HAVE A CARRY
 2809:	  0A3A	19			DEC	R1		;BIAS THE POINTER
 2810:	  0A3B	D0 E0			POP	ACC		;GET VALUE LOW
 2811:	  0A3D	29			ADD	A,R1		;ADD IT TO BASE
 2812:	  0A3E	F9			MOV	R1,A		;SAVE IT
 2813:	  0A3F	D0 03			POP	R3B0		;GET HIGH ADDRESS
 2814:	  0A41	50 01			JNC	CSY2		;PROPAGATE THE CARRY
 2815:	  0A43	0B			INC	R3
 2816:	  0A44	81 EE		CSY2:	AJMP	ERPAR		;WASTE THE RIGHT PAREN
 2817:					;
 2818:					;***************************************************************
 2819:					;
 2820:					; The statement action routine FOR
 2821:					;
 2822:					;***************************************************************
 2823:					;
 2824:	  0A46	31 D0		SFOR:	ACALL	SLET1		;SET UP CONTROL VARIABLE
 2825:	  0A48	C0 03			PUSH	R3B0		;SAVE THE CONTROL VARIABLE LOCATION
 2826:	  0A4A	C0 01			PUSH	R1B0
 2827:	  0A4C	F1 DE			ACALL	POPAS		;POP ARG STACK AND COPY CONTROL VAR
 2828:	  0A4E	7F A6			MOV	R7,#T_TO	;GET TO TOKEN
 2829:	  0A50	F1 4C			ACALL	WE
 2830:	  0A52	D1 D8			ACALL	GC		;GET NEXT CHARACTER
 2831:	  0A54	B4 A7 06		CJNE	A,#T_STEP,SF2
 2832:	  0A57	D1 E2			ACALL	GCI1		;EAT THE TOKEN
 2833:	  0A59	F1 4E			ACALL	EXPRB		;EVALUATE EXPRESSION
 2834:	  0A5B	80 03			SJMP	SF21		;JUMP OVER
 2835:					;
 2836:	  0A5D	12 14 50	SF2:	LCALL	PUSH_ONE	;PUT ONE ON THE STACK
 2837:					;
 2838:	  0A60	74 EF		SF21:	MOV	A,#-FSIZE	;ALLOCATE FSIZE BYTES ON THE CONTROL STACK
 2839:	  0A62	71 BB			ACALL	PUSHCS		;GET CS IN R0
 2840:	  0A64	71 C7			ACALL	CSC		;CHECK CONTROL STACK
 2841:	  0A66	7B 00			MOV	R3,#CSTKAH	;IN CONTROL STACK
 2842:	  0A68	A9 00			MOV	R1,R0B0 	;STACK ADDRESS
 2843:	  0A6A	F1 DE			ACALL	POPAS		;PUT STEP ON STACK
 2844:	  0A6C	F1 DE			ACALL	POPAS		;PUT LIMIT ON STACK
 2845:	  0A6E	D1 AD			ACALL	DP_T		;DPTR GETS TEXT
 2846:	  0A70	A8 01			MOV	R0,R1B0 	;GET THE POINTER
 2847:	  0A72	71 43			ACALL	T_X_S		;SAVE THE TEXT
 2848:	  0A74	D0 08			POP	TXAL		;GET CONTROL VARIABLE
 2849:	  0A76	D0 0A			POP	TXAH
 2850:	  0A78	7C 01			MOV	R4,#FTYPE	;AND THE TYPE
 2851:	  0A7A	71 43			ACALL	T_X_S		;SAVE IT
 2852:					;
 2853:	  0A7C	D1 C3		SF3:	ACALL	T_DP		;GET THE TEXT POINTER
 2854:	  0A7E	01 1D			AJMP	ILOOP		;CONTINUE TO PROCESS
 2855:					;
 2856:					;**************************************************************
 2857:					;
 2858:					; The statement action routines - PUSH and POP
 2859:					;
 2860:					;**************************************************************
 2861:					;
 2862:	  0A80	F1 4E		SPUSH:	ACALL	EXPRB		;PUT EXPRESSION ON STACK
 2863:	  0A82	D1 D1			ACALL	C_TST		;SEE IF MORE TO DO
 2864:	  0A84	50 FA			JNC	SPUSH		;IF A COMMA PUSH ANOTHER
 2865:	  0A86	22			RET
 2866:					;
 2867:					;
 2868:	  0A87	F1 0C		SPOP:	ACALL	VAR_ER		;GET VARIABLE
 2869:	  0A89	F1 DC			ACALL	XPOP		;FLIP THE REGISTERS FOR POPAS
 2870:	  0A8B	D1 D1			ACALL	C_TST		;SEE IF MORE TO DO
 2871:	  0A8D	50 F8			JNC	SPOP
 2872:					;
 2873:	  0A8F	22		SPOP1:	RET
 2874:					;
 2875:					;***************************************************************
 2876:					;
 2877:					; The statement action routine - IF
 2878:					;
 2879:					;***************************************************************
 2880:					;
 2881:	  0A90	51 D1		SIF:	ACALL	RTST		;EVALUATE THE EXPRESSION
 2882:	  0A92	F9			MOV	R1,A		;SAVE THE RESULT
 2883:	  0A93	D1 D8			ACALL	GC		;GET THE CHARACTER AFTER EXPR
 2884:	  0A95	B4 A5 02		CJNE	A,#T_THEN,SIF1	;SEE IF THEN TOKEN
 2885:	  0A98	D1 E2			ACALL	GCI1		;WASTE THEN TOKEN
 2886:	  0A9A	B9 00 0B	SIF1:	CJNE	R1,#0,T_F1	;CHECK R_OP RESULT
 2887:					;
 2888:	  0A9D	7F A8		E_FIND: MOV	R7,#T_ELSE	;FIND ELSE TOKEN
 2889:	  0A9F	D1 F9			ACALL	FINDC
 2890:	  0AA1	60 EC			JZ	SPOP1		;EXIT IF A CR
 2891:	  0AA3	D1 E2			ACALL	GCI1		;BUMP PAST TOKEN
 2892:	  0AA5	B4 A8 F5		CJNE	A,#T_ELSE,E_FIND;WASTE IF NO ELSE
 2893:					;
 2894:	  0AA8	F1 40		T_F1:	ACALL	INTGER		;SEE IF NUMBER
 2895:	  0AAA	50 56			JNC	D_L1		;EXECUTE LINE NUMBER
 2896:	  0AAC	21 02			AJMP	ISTAT		;EXECUTE STATEMENT IN NOT
 2897:					;
 2898:	  0AAE	E0		B_C:	MOVX	A,@DPTR
 2899:	  0AAF	14			DEC	A
 2900:	  0AB0	20 E7 2E		JB	ACC.7,FL11
 2901:	  0AB3	22			RET
 2902:					;
 2903:					;***************************************************************
 2904:					;
 2905:					; The statement action routine - GOTO
 2906:					;
 2907:					;***************************************************************
 2908:					;
 2909:	  0AB4	51 FC		SGOTO:	ACALL	RLINE		;R2:R0 AND DPTR GET INTGER
 2910:					;
 2911:	  0AB6	D1 C3		SGT1:	ACALL	T_DP		;TEXT POINTER GETS DPTR
 2912:					;
 2913:	  0AB8	10 25 08		JBC	RETBIT,SGT2	;SEE IF RETI EXECUTED
 2914:					;
 2915:	  0ABB	30 15 03		JNB	LINEB,SGT11	;SEE IF A LINE WAS EDITED
 2916:	  0ABE	12 06 6C		LCALL	CNEW1		;CLEAR THE MEMORY IF SET
 2917:	  0AC1	01 1B		SGT11:	AJMP	CILOOP1 	;CLEAR DIRF AND LOOP
 2918:					;
 2919:	  0AC3	10 14 05	SGT2:	JBC	OTI,SGT21	;SEE IF TIMER INTERRUPT
 2920:	  0AC6	53 22 BD		ANL	34,#10111101B	;CLEAR INTERRUPTS
 2921:	  0AC9	01 1D			AJMP	ILOOP		;EXECUTE
 2922:	  0ACB	A2 2B		SGT21:	MOV	C,ISAV
 2923:	  0ACD	92 11			MOV	INPROG,C
 2924:	  0ACF	01 1D			AJMP	ILOOP		;RESTORE INTERRUPTS AND RET
 2925:					;
 2926:					;
 2927:					;*************************************************************
 2928:					;
 2929:	  0AD1			RTST:	; Test for ZERO
 2930:					;
 2931:					;*************************************************************
 2932:					;
 2933:	  0AD1	F1 4E			ACALL	EXPRB		;EVALUATE EXPRESSION
 2934:	  0AD3	12 12 5C		CALL	INC_ASTKA	;BUMP ARG STACK
 2935:	  0AD6	60 02			JZ	RTST1		;EXIT WITH ZERO OR 0FFH
 2936:	  0AD8	74 FF			MOV	A,#0FFH
 2937:	  0ADA	22		RTST1:	RET
 2938:					;
 2939:					;
 2940:					;**************************************************************
 2941:					;
 2942:					; GLN - get the line number in R2:R0, return in DPTR
 2943:					;
 2944:					;**************************************************************
 2945:					;
 2946:	  0ADB	D1 A6		GLN:	ACALL	DP_B		;GET THE BEGINNING ADDRESS
 2947:					;
 2948:	  0ADD	E0		FL1:	MOVX	A,@DPTR 	;GET THE LENGTH
 2949:	  0ADE	FF			MOV	R7,A		;SAVE THE LENGTH
 2950:	  0ADF	DF 05			DJNZ	R7,FL3		;SEE IF END OF FILE
 2951:					;
 2952:	  0AE1	90 1F B5	FL11:	MOV	DPTR,#E10X	;NO LINE NUMBER
 2953:	  0AE4	81 18			AJMP	EK		;HANDLE THE ERROR
 2954:					;
 2955:	  0AE6	20 E7 F8	FL3:	JB	ACC.7,FL11	;CHECK FOR BIT 7
 2956:	  0AE9	A3			INC	DPTR		;POINT AT HIGH BYTE
 2957:	  0AEA	E0			MOVX	A,@DPTR 	;GET HIGH BYTE
 2958:	  0AEB	B5 02 08		CJNE	A,R2B0,FL2	;SEE IF MATCH
 2959:	  0AEE	A3			INC	DPTR		;BUMP TO LOW BYTE
 2960:	  0AEF	1F			DEC	R7		;ADJUST AGAIN
 2961:	  0AF0	E0			MOVX	A,@DPTR 	;GET THE LOW BYTE
 2962:	  0AF1	B5 00 02		CJNE	A,R0B0,FL2	;SEE IF LOW BYTE MATCH
 2963:	  0AF4	A3			INC	DPTR		;POINT AT FIRST CHARACTER
 2964:	  0AF5	22			RET			;FOUND IT
 2965:					;
 2966:	  0AF6	EF		FL2:	MOV	A,R7		;GET THE LENGTH COUNTER
 2967:	  0AF7	12 05 E8		CALL	ADDPTR		;ADD A TO DATA POINTER
 2968:	  0AFA	80 E1			SJMP	FL1		;LOOP
 2969:					;
 2970:					;
 2971:					;*************************************************************
 2972:					;
 2973:					;RLINE - Read in ASCII string, get line, and clean it up
 2974:					;
 2975:					;*************************************************************
 2976:					;
 2977:	  0AFC	F1 3B		RLINE:	ACALL	INTERR		;GET THE INTEGER
 2978:					;
 2979:	  0AFE	51 DB		RL1:	ACALL	GLN
 2980:	  0B00	E1 22			AJMP	CLN_UP
 2981:					;
 2982:					;
 2983:	  0B02	51 DB		D_L1:	ACALL	GLN		;GET THE LINE
 2984:	  0B04	41 B6			AJMP	SGT1		;EXECUTE THE LINE
 2985:					;
 2986:					;***************************************************************
 2987:					;
 2988:					; The statement action routines WHILE and UNTIL
 2989:					;
 2990:					;***************************************************************
 2991:					;
 2992:	  0B06	51 D1		SWHILE: ACALL	RTST		;EVALUATE RELATIONAL EXPRESSION
 2993:	  0B08	F4			CPL	A
 2994:	  0B09	80 02			SJMP	S_WU
 2995:					;
 2996:	  0B0B	51 D1		SUNTIL: ACALL	RTST		;EVALUATE RELATIONAL EXPRESSION
 2997:					;
 2998:	  0B0D	7C 03		S_WU:	MOV	R4,#DTYPE	;DO EXPECTED
 2999:	  0B0F	FD			MOV	R5,A		;SAVE R_OP RESULT
 3000:	  0B10	80 0C			SJMP	SR0		;GO PROCESS
 3001:					;
 3002:					;
 3003:					;***************************************************************
 3004:					;
 3005:	  0B12			CNULL:	; The Command Action Routine - NULL
 3006:					;
 3007:					;***************************************************************
 3008:					;
 3009:	  0B12	F1 3B			ACALL	INTERR		;GET AN INTEGER FOLLOWING NULL
 3010:	  0B14	88 15			MOV	NULLCT,R0	;SAVE THE NULLCOUNT
 3011:	  0B16	01 5F			AJMP	CMNDLK		;JUMP TO COMMAND MODE
 3012:					;
 3013:					;***************************************************************
 3014:					;
 3015:					; The statement action routine - RETI
 3016:					;
 3017:					;***************************************************************
 3018:					;
 3019:	  0B18	D2 25		SRETI:	SETB	RETBIT		;SAYS THAT RETI HAS BEEN EXECUTED
 3020:					;
 3021:					;***************************************************************
 3022:					;
 3023:					; The statement action routine - RETURN
 3024:					;
 3025:					;***************************************************************
 3026:					;
 3027:	  0B1A	7C 02		SRETRN: MOV	R4,#GTYPE	;MAKE SURE OF GOSUB
 3028:	  0B1C	7D 55			MOV	R5,#55H 	;TYPE RETURN TYPE
 3029:					;
 3030:	  0B1E	71 55		SR0:	ACALL	CSETUP		;SET UP CONTROL STACK
 3031:	  0B20	E2			MOVX	A,@R0		;GET RETURN TEXT ADDRESS
 3032:	  0B21	F5 83			MOV	DPH,A
 3033:	  0B23	08			INC	R0
 3034:	  0B24	E2			MOVX	A,@R0
 3035:	  0B25	F5 82			MOV	DPL,A
 3036:	  0B27	08			INC	R0		;POP CONTROL STACK
 3037:	  0B28	E0			MOVX	A,@DPTR 	;SEE IF GOSUB WAS THE LAST STATEMENT
 3038:	  0B29	B4 01 02		CJNE	A,#EOF,SR01
 3039:	  0B2C	01 5F			AJMP	CMNDLK
 3040:	  0B2E	ED		SR01:	MOV	A,R5		;GET TYPE
 3041:	  0B2F	60 85			JZ	SGT1		;EXIT IF ZERO
 3042:	  0B31	88 11			MOV	CSTKA,R0	;POP THE STACK
 3043:	  0B33	F4			CPL	A		;OPTION TEST, 00H, 55H, 0FFH, NOW 55H
 3044:	  0B34	70 80			JNZ	SGT1		;MUST BE GOSUB
 3045:	  0B36	22			RET			;NORMAL FALL THRU EXIT FOR NO MATCH
 3046:					;
 3047:					;***************************************************************
 3048:					;
 3049:					; The statement action routine - GOSUB
 3050:					;
 3051:					;***************************************************************
 3052:					;
 3053:	  0B37	51 FC		SGOSUB: ACALL	RLINE		;NEW TXA IN DPTR
 3054:					;
 3055:	  0B39	7C 02		SGS0:	MOV	R4,#GTYPE
 3056:	  0B3B	71 3F			ACALL	SGS1		;SET EVERYTHING UP
 3057:	  0B3D	41 7C			AJMP	SF3		;EXIT
 3058:					;
 3059:	  0B3F	74 FD		SGS1:	MOV	A,#-3		;ALLOCATE 3 BYTES ON CONTROL STACK
 3060:	  0B41	71 BB			ACALL	PUSHCS
 3061:					;
 3062:	  0B43	75 A0 00	T_X_S:	MOV	P2,#CSTKAH	;SET UP PORT FOR CONTROL STACK
 3063:	  0B46	E5 08			MOV	A,TXAL		;GET RETURN ADDRESS AND SAVE IT
 3064:	  0B48	F2			MOVX	@R0,A
 3065:	  0B49	18			DEC	R0
 3066:	  0B4A	E5 0A			MOV	A,TXAH
 3067:	  0B4C	F2			MOVX	@R0,A
 3068:	  0B4D	18			DEC	R0
 3069:	  0B4E	EC			MOV	A,R4		;GET TYPE
 3070:	  0B4F	F2			MOVX	@R0,A		;SAVE TYPE
 3071:	  0B50	22			RET			;EXIT
 3072:					;
 3073:					;
 3074:	  0B51	74 03		CS1:	MOV	A,#3		;POP 3 BYTES
 3075:	  0B53	71 BB			ACALL	PUSHCS
 3076:					;
 3077:	  0B55	A8 11		CSETUP: MOV	R0,CSTKA	;GET CONTROL STACK
 3078:	  0B57	75 A0 00		MOV	P2,#CSTKAH
 3079:	  0B5A	E2			MOVX	A,@R0		;GET BYTE
 3080:	  0B5B	B5 04 02		CJNE	A,R4B0,CSETUP1	;SEE IF TYPE MATCH
 3081:	  0B5E	08			INC	R0
 3082:	  0B5F	22			RET
 3083:	  0B60	60 69		CSETUP1:JZ	E4XX		;EXIT IF STACK UNDERFLOW
 3084:	  0B62	B4 01 EC		CJNE	A,#FTYPE,CS1	;SEE IF FOR TYPE
 3085:	  0B65	71 B9			ACALL	XXI3		;WASTE THE FOR TYPE
 3086:	  0B67	80 EC			SJMP	CSETUP		;LOOP
 3087:					;
 3088:					;***************************************************************
 3089:					;
 3090:					; The statement action routine - NEXT
 3091:					;
 3092:					;***************************************************************
 3093:					;
 3094:	  0B69	7C 01		SNEXT:	MOV	R4,#FTYPE	;FOR TYPE
 3095:	  0B6B	71 55			ACALL	CSETUP		;SETUP CONTROL STACK
 3096:	  0B6D	88 0F			MOV	TEMP5,R0	;SAVE CONTROL VARIABLE ADDRESS
 3097:	  0B6F	79 0B			MOV	R1,#TEMP1	;SAVE VAR + RETURN IN TEMP1-4
 3098:					;
 3099:	  0B71	E2		XXI:	MOVX	A,@R0		;LOOP UNTIL DONE
 3100:	  0B72	F7			MOV	@R1,A
 3101:	  0B73	09			INC	R1
 3102:	  0B74	08			INC	R0
 3103:	  0B75	B9 0F F9		CJNE	R1,#TEMP5,XXI
 3104:					;
 3105:	  0B78	B1 70			ACALL	VAR		;SEE IF THE USER HAS A VARIABLE
 3106:	  0B7A	50 04			JNC	XXI1
 3107:	  0B7C	AA 0B			MOV	R2,TEMP1
 3108:	  0B7E	A8 0C			MOV	R0,TEMP2
 3109:	  0B80	EA		XXI1:	MOV	A,R2		;SEE IF VAR'S AGREE
 3110:	  0B81	B5 0B 47		CJNE	A,TEMP1,E4XX
 3111:	  0B84	E8			MOV	A,R0
 3112:	  0B85	B5 0C 43		CJNE	A,TEMP2,E4XX
 3113:	  0B88	F1 E8			ACALL	PUSHAS		;PUT CONTROL VARIABLE ON STACK
 3114:	  0B8A	74 0E			MOV	A,#FPSIZ+FPSIZ+2;COMPUTE ADDRESS TO STEP VALUE SIGN
 3115:	  0B8C	25 0F			ADD	A,TEMP5 	;ADD IT TO BASE OF STACK
 3116:	  0B8E	F8			MOV	R0,A		;SAVE IN R0
 3117:	  0B8F	7A 00			MOV	R2,#CSTKAH	;SET UP TO PUSH STEP VALUE
 3118:	  0B91	8A A0			MOV	P2,R2		;SET UP PORT
 3119:	  0B93	E2			MOVX	A,@R0		;GET SIGN
 3120:	  0B94	08			INC	R0		;BACK TO EXPONENT
 3121:	  0B95	C0 E0			PUSH	ACC		;SAVE SIGN OF STEP
 3122:	  0B97	F1 E8			ACALL	PUSHAS		;PUT STEP VALUE ON STACK
 3123:	  0B99	C0 00			PUSH	R0B0		;SAVE LIMIT VALUE LOCATION
 3124:	  0B9B	12 17 4E		CALL	AADD		;ADD STEP VALUE TO VARIABLE
 3125:	  0B9E	12 14 39		CALL	CSTAKA		;COPY STACK
 3126:	  0BA1	AB 0B			MOV	R3,TEMP1	;GET CONTROL VARIABLE
 3127:	  0BA3	A9 0C			MOV	R1,TEMP2
 3128:	  0BA5	F1 DE			ACALL	POPAS		;SAVE THE RESULT
 3129:	  0BA7	7A 00			MOV	R2,#CSTKAH	;RESTORE LIMIT LOCATION
 3130:	  0BA9	D0 00			POP	R0B0
 3131:	  0BAB	F1 E8			ACALL	PUSHAS		;PUT LIMIT ON STACK
 3132:	  0BAD	12 19 80		CALL	FP_BASE2	;DO THE COMPARE
 3133:	  0BB0	D0 E0			POP	ACC		;GET LIMIT SIGN BACK
 3134:	  0BB2	60 01			JZ	XXI2		;IF SIGN NEGATIVE, TEST "BACKWARDS"
 3135:	  0BB4	B3			CPL	C
 3136:	  0BB5	72 D5		XXI2:	ORL	C,F0		;SEE IF EQUAL
 3137:	  0BB7	40 17			JC	N4		;STILL SMALLER THAN LIMIT?
 3138:	  0BB9	74 11		XXI3:	MOV	A,#FSIZE	;REMOVE CONTROL STACK ENTRY
 3139:					;
 3140:					; Fall thru to PUSHCS
 3141:					;
 3142:					;***************************************************************
 3143:					;
 3144:					; PUSHCS - push frame onto control stack
 3145:					;	   acc has - number of bytes, also test for overflow
 3146:					;
 3147:					;***************************************************************
 3148:					;
 3149:	  0BBB	25 11		PUSHCS: ADD	A,CSTKA 	;BUMP CONTROL STACK
 3150:	  0BBD	B4 61 00		CJNE	A,#CONVT+17,PUSHCS1 ;SEE IF OVERFLOWED
 3151:	  0BC0	40 09		PUSHCS1:JC	E4XX		;EXIT IF STACK OVERFLOW
 3152:	  0BC2	C5 11			XCH	A,CSTKA 	;STORE NEW CONTROL STACK VALUE, GET OLD
 3153:	  0BC4	14			DEC	A		;BUMP OLD VALUE
 3154:	  0BC5	F8			MOV	R0,A		;PUT OLD-1 IN R0
 3155:					;
 3156:	  0BC6	22		PUSHCS2:RET			;EXIT
 3157:					;
 3158:	  0BC7	F1 22		CSC:	ACALL	CLN_UP		;FINISH OFF THE LINE
 3159:	  0BC9	50 FB			JNC	PUSHCS2 	;EXIT IF NO TERMINATOR
 3160:					;
 3161:	  0BCB	90 03 83	E4XX:	MOV	DPTR,#EXC	;CONTROL STACK ERROR
 3162:	  0BCE	81 18			AJMP	EK		;STACK ERROR
 3163:					;
 3164:	  0BD0	85 0D 0A	N4:	MOV	TXAH,TEMP3	;GET TEXT POINTER
 3165:	  0BD3	85 0E 08		MOV	TXAL,TEMP4
 3166:	  0BD6	01 1D			AJMP	ILOOP		;EXIT
 3167:					;
 3168:					;***************************************************************
 3169:					;
 3170:					; The statement action routine - RESTORE
 3171:					;
 3172:					;***************************************************************
 3173:					;
 3174:	  0BD8	71 E0		SRESTR: ACALL	X_TR		;SWAP POINTERS
 3175:	  0BDA	D1 A6		SRESTR1:ACALL	DP_B		;GET THE STARTING ADDRESS
 3176:	  0BDC	D1 C3			ACALL	T_DP		;PUT STARTING ADDRESS IN TEXT POINTER
 3177:	  0BDE	F1 2E			ACALL	B_TXA		;BUMP TXA
 3178:					;
 3179:					; Fall thru
 3180:					;
 3181:	  0BE0			X_TR:	;swap txa and rtxa
 3182:					;
 3183:	  0BE0	C5 0A			XCH	A,TXAH
 3184:	  0BE2	C5 12			XCH	A,RTXAH
 3185:	  0BE4	C5 0A			XCH	A,TXAH
 3186:	  0BE6	C5 08			XCH	A,TXAL
 3187:	  0BE8	C5 10			XCH	A,RTXAL
 3188:	  0BEA	C5 08			XCH	A,TXAL
 3189:	  0BEC	22			RET			;EXIT
 3190:					;
 3191:					;***************************************************************
 3192:					;
 3193:					; The statement action routine - READ
 3194:					;
 3195:					;***************************************************************
 3196:					;
 3197:	  0BED	71 E0		SREAD:	ACALL	X_TR		;SWAP POINTERS
 3198:					;
 3199:	  0BEF	D1 D1		SRD0:	ACALL	C_TST		;CHECK FOR COMMA
 3200:	  0BF1	40 16			JC	SRD4		;SEE WHAT IT IS
 3201:					;
 3202:	  0BF3	F1 4E		SRD:	ACALL	EXPRB		;EVALUATE THE EXPRESSION
 3203:	  0BF5	D1 D8			ACALL	GC		;GET THE CHARACTER AFTER EXPRESSION
 3204:	  0BF7	B4 2C 02		CJNE	A,#',',SRD1     ;SEE IF MORE DATA
 3205:	  0BFA	80 02			SJMP	SRD2		;BYBASS CLEAN UP IF A COMMA
 3206:					;
 3207:	  0BFC	F1 22		SRD1:	ACALL	CLN_UP		;FINISH OFF THE LINE, IF AT END
 3208:					;
 3209:	  0BFE	71 E0		SRD2:	ACALL	X_TR		;RESTORE POINTERS
 3210:	  0C00	F1 0C			ACALL	VAR_ER		;GET VARIABLE ADDRESS
 3211:	  0C02	F1 DC			ACALL	XPOP		;FLIP THE REGISTERS FOR POPAS
 3212:	  0C04	D1 D1			ACALL	C_TST		;SEE IF A COMMA
 3213:	  0C06	50 E5			JNC	SREAD		;READ AGAIN IF A COMMA
 3214:	  0C08	22		SRD21:	RET			;EXIT IF NOT
 3215:					;
 3216:	  0C09	B4 9C 04	SRD4:	CJNE	A,#T_DATA,SRD5	;SEE IF DATA
 3217:	  0C0C	D1 E2			ACALL	GCI1		;BUMP POINTER
 3218:	  0C0E	80 E3			SJMP	SRD
 3219:					;
 3220:	  0C10	B4 01 08	SRD5:	CJNE	A,#EOF,SRD6	;SEE IF YOU BLEW IT
 3221:	  0C13	71 E0		SRD51:	ACALL	X_TR		;GET THE TEXT POINTER BACK
 3222:	  0C15	90 1F 81		MOV	DPTR,#E14X	;READ ERROR
 3223:					;
 3224:	  0C18	02 18 9C	EK:	LJMP	ERROR
 3225:					;
 3226:	  0C1B	D1 F7		SRD6:	ACALL	FINDCR		;WASTE THIS LINE
 3227:	  0C1D	F1 22			ACALL	CLN_UP		;CLEAN IT UP
 3228:	  0C1F	40 F2			JC	SRD51		;ERROR IF AT END
 3229:	  0C21	80 CC			SJMP	SRD0
 3230:					;
 3231:	  0C23	D1 D8		NUMC:	ACALL	GC		;GET A CHARACTER
 3232:	  0C25	B4 23 04		CJNE	A,#'#',NUMC1    ;SEE IF A #
 3233:	  0C28	D2 1B			SETB	COB		;VALID LINE PRINT
 3234:	  0C2A	C1 D6			AJMP	IGC		;BUMP THE TEXT POINTER
 3235:					;
 3236:	  0C2C	B4 40 D9	NUMC1:	CJNE	A,#'@',SRD21    ;EXIT IF NO GOOD
 3237:	  0C2F	D2 19			SETB	LPB
 3238:	  0C31	C1 D6			AJMP	IGC
 3239:					;
 3240:					;***************************************************************
 3241:					;
 3242:					; The statement action routine - PRINT
 3243:					;
 3244:					;***************************************************************
 3245:					;
 3246:	  0C33	D2 36		SPH0:	SETB	ZSURP		;NO ZEROS
 3247:					;
 3248:	  0C35	D2 37		SPH1:	SETB	HMODE		;HEX MODE
 3249:					;
 3250:	  0C37	91 23		SPRINT: ACALL	NUMC		;TEST FOR A LINE PRINT
 3251:	  0C39	91 42			ACALL	SPRINT2 	;PROCEED
 3252:	  0C3B	53 23 F5	SPRINT1:ANL	35,#11110101B	;CLEAR COB AND LPB
 3253:	  0C3E	53 26 3F		ANL	38,#00111111B	;NO HEX MODE
 3254:					;
 3255:	  0C41	22			RET
 3256:					;
 3257:	  0C42	D1 EC		SPRINT2:ACALL	DELTST		;CHECK FOR A DELIMITER
 3258:	  0C44	40 07			JC	SP1
 3259:					;
 3260:	  0C46	02 06 AF	SP0:	JMP	CRLF		;EXIT WITH A CR IF SO
 3261:					;
 3262:	  0C49	D1 D1		SP2:	ACALL	C_TST		;CHECK FOR A COMMA
 3263:	  0C4B	40 F9			JC	SP0		;EXIT IF NO COMMA
 3264:					;
 3265:	  0C4D	D1 B4		SP1:	ACALL	CPS		;SEE IF A STRING TO PRINT
 3266:	  0C4F	50 F8			JNC	SP2		;IF A STRING, CHECK FOR A COMMA
 3267:					;
 3268:	  0C51	B4 A4 08	SP4:	CJNE	A,#T_TAB,SP6
 3269:	  0C54	D1 A0			ACALL	I_PI		;ALWAYS CLEARS CARRY
 3270:	  0C56	95 16			SUBB	A,PHEAD 	;TAKE DELTA BETWEEN TAB AND PHEAD
 3271:	  0C58	40 EF			JC	SP2		;EXIT IF PHEAD > TAB
 3272:	  0C5A	80 05			SJMP	SP7		;OUTPUT SPACES
 3273:					;
 3274:	  0C5C	B4 A9 0A	SP6:	CJNE	A,#T_SPC,SM
 3275:	  0C5F	D1 A0			ACALL	I_PI		;SET UP PAREN VALUE
 3276:					;
 3277:	  0C61	60 E6		SP7:	JZ	SP2
 3278:	  0C63	12 07 19		LCALL	STEROT		;OUTPUT A SPACE
 3279:	  0C66	14			DEC	A		;DECREMENT COUNTER
 3280:	  0C67	80 F8			SJMP	SP7		;LOOP
 3281:					;
 3282:	  0C69	B4 D3 14	SM:	CJNE	A,#T_CHR,SP8
 3283:	  0C6C	D1 D6			ACALL	IGC
 3284:	  0C6E	B4 24 07		CJNE	A,#'$',SM01
 3285:	  0C71	12 10 05		LCALL	CNX		;PUT THE CHARACTER ON THE STACK
 3286:	  0C74	D1 9B			ACALL	IFIXL		;PUT THE CHARACTER IN R1
 3287:	  0C76	80 04			SJMP	SM02
 3288:	  0C78	D1 99		SM01:	ACALL	ONE		;EVALUATE THE EXPRESSION, PUT IN R3:R1
 3289:	  0C7A	91 EE			ACALL	ERPAR
 3290:	  0C7C	AD 01		SM02:	MOV	R5,R1B0 	;BYTE TO OUTPUT
 3291:	  0C7E	80 07			SJMP	SQ
 3292:					;
 3293:	  0C80	B4 AA 09	SP8:	CJNE	A,#T_CR,SX
 3294:	  0C83	D1 E2			ACALL	GCI1		;EAT THE TOKEN
 3295:	  0C85	7D 0D			MOV	R5,#CR
 3296:					;
 3297:	  0C87	12 07 1B	SQ:	CALL	TEROT
 3298:	  0C8A	80 BD			SJMP	SP2		;OUTPUT A CR AND DO IT AGAIN
 3299:					;
 3300:	  0C8C	B4 D2 53	SX:	CJNE	A,#T_USE,SP9	;USING TOKEN
 3301:	  0C8F	D1 D6			ACALL	IGC		;GE THE CHARACTER AFTER THE USING TOKEN
 3302:	  0C91	B4 46 16		CJNE	A,#'F',U4       ;SEE IF FLOATING
 3303:	  0C94	75 17 F0		MOV	FORMAT,#0F0H	;SET FLOATING
 3304:	  0C97	D1 D6			ACALL	IGC		;BUMP THE POINTER AND GET THE CHARACTER
 3305:	  0C99	D1 E2			ACALL	GCI1		;BUMP IT AGAIN
 3306:	  0C9B	54 0F			ANL	A,#0FH		;STRIP OFF ASCII BIAS
 3307:	  0C9D	60 07			JZ	U3		;EXIT IF ZERO
 3308:	  0C9F	B4 03 00		CJNE	A,#3,SX1	;SEE IF AT LEAST A THREE
 3309:	  0CA2	50 02		SX1:	JNC	U3		;FORCE A THREE IF NOT A THREE
 3310:	  0CA4	74 03			MOV	A,#3
 3311:					;
 3312:	  0CA6	42 17		U3:	ORL	FORMAT,A	;PUT DIGIT IN FORMAT
 3313:	  0CA8	80 2A			SJMP	U8		;CLEAN UP END
 3314:					;
 3315:	  0CAA	B4 30 07	U4:	CJNE	A,#'0',U5
 3316:	  0CAD	75 17 00		MOV	FORMAT,#0	;FREE FORMAT
 3317:	  0CB0	D1 E2			ACALL	GCI1		;BUMP THE POINTER
 3318:	  0CB2	80 20			SJMP	U8
 3319:					;
 3320:	  0CB4	B4 23 1D	U5:	CJNE	A,#'#',U8       ;SEE IF INTGER FORMAT
 3321:	  0CB7	91 D8			ACALL	U6
 3322:	  0CB9	8F 17			MOV	FORMAT,R7	;SAVE THE FORMAT
 3323:	  0CBB	B4 2E 11		CJNE	A,#'.',U8A      ;SEE IF TERMINATOR WAS RADIX
 3324:	  0CBE	D1 D6			ACALL	IGC		;BUMP PAST .
 3325:	  0CC0	91 D8			ACALL	U6		;LOOP AGAIN
 3326:	  0CC2	EF			MOV	A,R7		;GET COUNT
 3327:	  0CC3	25 17			ADD	A,FORMAT	;SEE IF TOO BIG
 3328:	  0CC5	24 F7			ADD	A,#0F7H
 3329:	  0CC7	50 02			JNC	U5A
 3330:					;
 3331:	  0CC9	21 42		SE0:	AJMP	INTERX		;ERROR, BAD SYNTAX
 3332:					;
 3333:	  0CCB	EF		U5A:	MOV	A,R7		;GET THE COUNT BACK
 3334:	  0CCC	C4			SWAP	A		;ADJUST
 3335:	  0CCD	42 17			ORL	FORMAT,A	;GET THE COUNT
 3336:					;
 3337:	  0CCF	E5 17		U8A:	MOV	A,FORMAT
 3338:					;
 3339:	  0CD1	C4		U8B:	SWAP	A		;GET THE FORMAT RIGHT
 3340:	  0CD2	F5 17			MOV	FORMAT,A
 3341:					;
 3342:	  0CD4	91 EE		U8:	ACALL	ERPAR
 3343:	  0CD6	81 49			AJMP	SP2		;DONE
 3344:					;
 3345:	  0CD8	7F 00		U6:	MOV	R7,#0		;SET COUNTER
 3346:					;
 3347:	  0CDA	B4 23 0C	U7:	CJNE	A,#'#',SP9A     ;EXIT IF NOT A #
 3348:	  0CDD	0F			INC	R7		;BUMP COUNTER
 3349:	  0CDE	D1 D6			ACALL	IGC		;GET THE NEXT CHARACTER
 3350:	  0CE0	80 F8			SJMP	U7		;LOOP
 3351:					;
 3352:	  0CE2	D1 EE		SP9:	ACALL	DELTST1 	;CHECK FOR DELIMITER
 3353:	  0CE4	50 03			JNC	SP9A		;EXIT IF A DELIMITER
 3354:					;
 3355:	  0CE6	B4 A8 34		CJNE	A,#T_ELSE,SS
 3356:					;
 3357:	  0CE9	22		SP9A:	RET			;EXIT IF ELSE TOKEN
 3358:					;
 3359:					;**************************************************************
 3360:					;
 3361:					; P_E - Evaluate an expression in parens ( )
 3362:					;
 3363:					;**************************************************************
 3364:					;
 3365:	  0CEA	7F E0		P_E:	MOV	R7,#T_LPAR
 3366:	  0CEC	F1 4C			ACALL	WE
 3367:					;
 3368:	  0CEE	7F 29		ERPAR:	MOV	R7,#')'         ;EAT A RIGHT PAREN
 3369:					;
 3370:	  0CF0	D1 E0		EATC:	ACALL	GCI		;GET THE CHARACTER
 3371:	  0CF2	B5 07 D4		CJNE	A,R7B0,SE0	;ERROR IF NOT THE SAME
 3372:	  0CF5	22			RET
 3373:					;
 3374:					;***************************************************************
 3375:					;
 3376:	  0CF6			S_ON:	; ON Statement
 3377:					;
 3378:					;***************************************************************
 3379:					;
 3380:	  0CF6	D1 99			ACALL	ONE		;GET THE EXPRESSION
 3381:	  0CF8	D1 E0			ACALL	GCI		;GET THE NEXT CHARACTER
 3382:	  0CFA	B4 83 04		CJNE	A,#T_GOTO,C0
 3383:	  0CFD	B1 08			ACALL	C1		;EAT THE COMMAS
 3384:	  0CFF	41 7C			AJMP	SF3		;DO GOTO
 3385:					;
 3386:	  0D01	B4 9F C5	C0:	CJNE	A,#T_GOSB,SE0
 3387:	  0D04	B1 08			ACALL	C1
 3388:	  0D06	61 39			AJMP	SGS0		;DO GOSUB
 3389:					;
 3390:	  0D08	B9 00 06	C1:	CJNE	R1,#0,C2
 3391:	  0D0B	F1 3B			ACALL	INTERR		;GET THE LINE NUMBER
 3392:	  0D0D	D1 F7			ACALL	FINDCR
 3393:	  0D0F	41 FE			AJMP	RL1		;FINISH UP THIS LINE
 3394:					;
 3395:	  0D11	7F 2C		C2:	MOV	R7,#','
 3396:	  0D13	D1 F9			ACALL	FINDC
 3397:	  0D15	B4 2C B1		CJNE	A,#',',SE0      ;ERROR IF NOT A COMMA
 3398:	  0D18	19			DEC	R1
 3399:	  0D19	D1 E2			ACALL	GCI1		;BUMP PAST COMMA
 3400:	  0D1B	80 EB			SJMP	C1
 3401:					;
 3402:	  0D1D	D1 CA		SS:	ACALL	S_C		;SEE IF A STRING
 3403:	  0D1F	40 05			JC	SA		;NO STRING IF CARRY IS SET
 3404:	  0D21	12 06 C9		LCALL	UPRNT		;PUT POINTER IN DPTR
 3405:	  0D24	81 49			AJMP	SP2		;SEE IF MORE
 3406:					;
 3407:	  0D26	F1 4E		SA:	ACALL	EXPRB		;MUST BE AN EXPRESSION
 3408:	  0D28	74 48			MOV	A,#72
 3409:	  0D2A	B5 16 00		CJNE	A,PHEAD,SA1	;CHECK PHEAD POSITION
 3410:	  0D2D	50 02		SA1:	JNC	SA2
 3411:	  0D2F	91 46			ACALL	SP0		;FORCE A CRLF
 3412:	  0D31	30 37 14	SA2:	JNB	HMODE,S13	;HEX MODE?
 3413:	  0D34	12 12 0F		CALL	FCMP		;SEE IF TOS IS < 0FFFH
 3414:	  0D37	40 0F			JC	S13		;EXIT IF GREATER
 3415:	  0D39	12 13 9C		CALL	AABS		;GET THE SIGN
 3416:	  0D3C	70 07			JNZ	OOPS		;WASTE IF NEGATIVE
 3417:	  0D3E	D1 9B			ACALL	IFIXL
 3418:	  0D40	12 19 92		CALL	FP_BASE11	;PRINT HEXMODE
 3419:	  0D43	81 49			AJMP	SP2
 3420:	  0D45	12 13 AE	OOPS:	CALL	ANEG		;MAKE IT NEGATIVE
 3421:					;
 3422:	  0D48	12 19 8A	S13:	CALL	FP_BASE7	;DO FP OUTPUT
 3423:	  0D4B	74 01			MOV	A,#1		;OUTPUT A SPACE
 3424:	  0D4D	81 61			AJMP	SP7
 3425:					;
 3426:					;***************************************************************
 3427:					;
 3428:					; ANU -  Get variable name from text - set carry if not found
 3429:					;	 if succeeds returns variable in R7:R6
 3430:					;	 R6 = 0 if no digit in name
 3431:					;
 3432:					;***************************************************************
 3433:					;
 3434:	  0D4F	D1 D6		ANU:	ACALL	IGC		;INCREMENT AND GET CHARACTER
 3435:	  0D51	12 1F ED		LCALL	DIGIT_CHECK	;CHECK FOR DIGIT
 3436:	  0D54	40 0C			JC	AL2		;EXIT IF VALID DIGIT
 3437:	  0D56	B4 5F 01		CJNE	A,#'_',AL       ;SEE IF A _
 3438:	  0D59	22			RET
 3439:					;
 3440:	  0D5A	B4 41 00	AL:	CJNE	A,#'A',AL1      ;IS IT AN ASCII A?
 3441:	  0D5D	40 04		AL1:	JC	AL3		;EXIT IF CARRY IS SET
 3442:	  0D5F	B4 5B 00		CJNE	A,#'Z'+1,AL2    ;IS IT LESS THAN AN ASCII Z
 3443:	  0D62	B3		AL2:	CPL	C		;FLIP CARRY
 3444:	  0D63	22		AL3:	RET
 3445:					;
 3446:	  0D64	30 D5 3E	SD01:	JNB	F0,VAR2
 3447:					;
 3448:	  0D67	90 17 6E	SD0:	MOV	DPTR,#E6X
 3449:	  0D6A	81 18			AJMP	EK
 3450:					;
 3451:	  0D6C	D2 D5		SDIMX:	SETB	F0		;SAYS DOING A DIMENSION
 3452:	  0D6E	80 02			SJMP	VAR1
 3453:					;
 3454:	  0D70	C2 D5		VAR:	CLR	F0		;SAYS DOING A VARIABLE
 3455:					;
 3456:	  0D72	D1 D8		VAR1:	ACALL	GC		;GET THE CHARACTER
 3457:	  0D74	B1 5A			ACALL	AL		;CHECK FOR ALPHA
 3458:	  0D76	50 04			JNC	VAR11		;ERROR IF IN DIM
 3459:	  0D78	20 D5 EC		JB	F0,SD0
 3460:	  0D7B	22			RET
 3461:	  0D7C	FF		VAR11:	MOV	R7,A		;SAVE ALPHA CHARACTER
 3462:	  0D7D	E4			CLR	A		;ZERO IN CASE OF FAILURE
 3463:	  0D7E	FD			MOV	R5,A		;SAVE IT
 3464:					;
 3465:	  0D7F	FE		VY:	MOV	R6,A
 3466:	  0D80	B1 4F			ACALL	ANU		;CHECK FOR ALPHA OR NUMBER
 3467:	  0D82	40 07			JC	VX		;EXIT IF NO ALPHA OR NUM
 3468:					;
 3469:	  0D84	CF			XCH	A,R7
 3470:	  0D85	2D			ADD	A,R5		;NUMBER OF CHARACTERS IN ALPHABET
 3471:	  0D86	CF			XCH	A,R7		;PUT IT BACK
 3472:	  0D87	7D 1A			MOV	R5,#26		;FOR THE SECOND TIME AROUND
 3473:	  0D89	80 F4			SJMP	VY
 3474:					;
 3475:	  0D8B	C2 15		VX:	CLR	LINEB		;TELL EDITOR A VARIABLE IS DECLARED
 3476:	  0D8D	B4 E0 2F		CJNE	A,#T_LPAR,V4	;SEE IF A LEFT PAREN
 3477:					;
 3478:	  0D90	43 06 80		ORL	R6B0,#80H	;SET BIT 7 TO SIGINIFY MATRIX
 3479:	  0D93	12 06 23		CALL	F_VAR		;FIND THE VARIABLE
 3480:	  0D96	C0 02			PUSH	R2B0		;SAVE THE LOCATION
 3481:	  0D98	C0 00			PUSH	R0B0
 3482:	  0D9A	50 C8			JNC	SD01		;DEFAULT IF NOT IN TABLE
 3483:	  0D9C	20 D5 28		JB	F0,SDI		;NO DEFAULT FOR DIMENSION
 3484:	  0D9F	79 0A			MOV	R1,#10
 3485:	  0DA1	7B 00			MOV	R3,#0
 3486:	  0DA3	B1 D7			ACALL	D_CHK
 3487:					;
 3488:	  0DA5	D1 A2		VAR2:	ACALL	PAREN_INT	;EVALUATE INTEGER IN PARENS
 3489:	  0DA7	BB 00 BD		CJNE	R3,#0,SD0	;ERROR IF R3<>0
 3490:	  0DAA	D0 82			POP	DPL		;GET VAR FOR LOOKUP
 3491:	  0DAC	D0 83			POP	DPH
 3492:	  0DAE	E0			MOVX	A,@DPTR 	;GET DIMENSION
 3493:	  0DAF	14			DEC	A		;BUMP OFFSET
 3494:	  0DB0	99			SUBB	A,R1		;A MUST BE > R1
 3495:	  0DB1	40 B4			JC	SD0
 3496:	  0DB3	12 05 CA		LCALL	DECDP2		;BUMP POINTER TWICE
 3497:	  0DB6	51 17			ACALL	VARB		;CALCULATE THE BASE
 3498:					;
 3499:	  0DB8	C9		X3120:	XCH	A,R1		;SWAP R2:R0, R3:R1
 3500:	  0DB9	C8			XCH	A,R0
 3501:	  0DBA	C9			XCH	A,R1
 3502:	  0DBB	CB			XCH	A,R3
 3503:	  0DBC	CA			XCH	A,R2
 3504:	  0DBD	CB			XCH	A,R3
 3505:	  0DBE	22			RET
 3506:					;
 3507:	  0DBF	20 D5 A5	V4:	JB	F0,SD0		;ERROR IF NO LPAR FOR DIM
 3508:	  0DC2	12 06 23		LCALL	F_VAR		;GET SCALAR VARIABLE
 3509:	  0DC5	C3			CLR	C
 3510:	  0DC6	22			RET
 3511:					;
 3512:	  0DC7	D1 A2		SDI:	ACALL	PAREN_INT	;EVALUATE PAREN EXPRESSION
 3513:	  0DC9	BB 00 9B		CJNE	R3,#0,SD0	;ERROR IF NOT ZERO
 3514:	  0DCC	D0 00			POP	R0B0		;SET UP R2:R0
 3515:	  0DCE	D0 02			POP	R2B0
 3516:	  0DD0	B1 D7			ACALL	D_CHK		;DO DIM
 3517:	  0DD2	D1 D1			ACALL	C_TST		;CHECK FOR COMMA
 3518:	  0DD4	50 96			JNC	SDIMX		;LOOP IF COMMA
 3519:	  0DD6	22			RET			;RETURN IF NO COMMA
 3520:					;
 3521:	  0DD7	09		D_CHK:	INC	R1		;BUMP FOR TABLE LOOKUP
 3522:	  0DD8	E9			MOV	A,R1
 3523:	  0DD9	60 8C			JZ	SD0		;ERROR IF 0FFFFH
 3524:	  0DDB	FC			MOV	R4,A		;SAVE FOR LATER
 3525:	  0DDC	90 01 08		MOV	DPTR,#MT_ALL	;GET MATRIX ALLOCATION
 3526:	  0DDF	51 17			ACALL	VARB		;DO THE CALCULATION
 3527:	  0DE1	AF 83			MOV	R7,DPH		;SAVE MATRIX ALLOCATION
 3528:	  0DE3	AE 82			MOV	R6,DPL
 3529:	  0DE5	90 01 06		MOV	DPTR,#ST_ALL	;SEE IF TOO MUCH MEMORY TAKEN
 3530:	  0DE8	12 15 BD		CALL	FUL1		;ST_ALL SHOULD BE > R3:R1
 3531:	  0DEB	90 01 08		MOV	DPTR,#MT_ALL	;SAVE THE NEW MATRIX POINTER
 3532:	  0DEE	12 06 0F		CALL	S31DP
 3533:	  0DF1	88 82			MOV	DPL,R0		;GET VARIABLE ADDRESS
 3534:	  0DF3	8A 83			MOV	DPH,R2
 3535:	  0DF5	EC			MOV	A,R4		;DIMENSION SIZE
 3536:	  0DF6	F0			MOVX	@DPTR,A 	;SAVE IT
 3537:	  0DF7	12 05 CA		CALL	DECDP2		;SAVE TARGET ADDRESS
 3538:					;
 3539:	  0DFA	EF		R76S:	MOV	A,R7
 3540:	  0DFB	F0			MOVX	@DPTR,A
 3541:	  0DFC	A3			INC	DPTR
 3542:	  0DFD	EE			MOV	A,R6		;ELEMENT SIZE
 3543:	  0DFE	F0			MOVX	@DPTR,A
 3544:	  0DFF	22			RET			;R2:R0 STILL HAS SYMBOL TABLE ADDRESS
 3545:					;
 3546:					;***************************************************************
 3547:					;
 3548:					; The statement action routine - INPUT
 3549:					;
 3550:					;***************************************************************
 3551:					;
 3552:	  0E00	D1 B4		SINPUT: ACALL	CPS		;PRINT STRING IF THERE
 3553:					;
 3554:	  0E02	D1 D1			ACALL	C_TST		;CHECK FOR A COMMA
 3555:	  0E04	50 07			JNC	IN2A		;NO CRLF
 3556:	  0E06	91 46			ACALL	SP0		;DO A CRLF
 3557:					;
 3558:	  0E08	7D 3F		IN2:	MOV	R5,#'?'         ;OUTPUT A ?
 3559:	  0E0A	12 07 1B		CALL	TEROT
 3560:					;
 3561:	  0E0D	D2 22		IN2A:	SETB	INP_B		;DOING INPUT
 3562:	  0E0F	12 06 E2		CALL	INLINE		;INPUT THE LINE
 3563:	  0E12	C2 22			CLR	INP_B
 3564:	  0E14	75 0F 00		MOV	TEMP5,#HIGH IBUF
 3565:	  0E17	75 0E 07		MOV	TEMP4,#LOW IBUF
 3566:					;
 3567:	  0E1A	D1 CA		IN3:	ACALL	S_C		;SEE IF A STRING
 3568:	  0E1C	40 0D			JC	IN3A		;IF CARRY IS SET, NO STRING
 3569:	  0E1E	B1 B8			ACALL	X3120		;FLIP THE ADDRESSES
 3570:	  0E20	AB 0F			MOV	R3,TEMP5
 3571:	  0E22	A9 0E			MOV	R1,TEMP4
 3572:	  0E24	31 A7			ACALL	SSOOP
 3573:	  0E26	D1 D1			ACALL	C_TST		;SEE IF MORE TO DO
 3574:	  0E28	50 DE			JNC	IN2
 3575:	  0E2A	22			RET
 3576:					;
 3577:	  0E2B	12 18 5A	IN3A:	CALL	DTEMP		;GET THE USER LOCATION
 3578:	  0E2E	12 19 64		CALL	GET_NUM 	;GET THE USER SUPPLIED NUMBER
 3579:	  0E31	70 18			JNZ	IN5		;ERROR IF NOT ZERO
 3580:	  0E33	12 18 61		CALL	TEMPD		;SAVE THE DATA POINTER
 3581:	  0E36	F1 0C			ACALL	VAR_ER		;GET THE VARIABLE
 3582:	  0E38	F1 DC			ACALL	XPOP		;SAVE THE VARIABLE
 3583:	  0E3A	12 18 5A		CALL	DTEMP		;GET DPTR BACK FROM VAR_ER
 3584:	  0E3D	D1 D1			ACALL	C_TST		;SEE IF MORE TO DO
 3585:	  0E3F	40 13			JC	IN6		;EXIT IF NO COMMA
 3586:	  0E41	E0			MOVX	A,@DPTR 	;GET INPUT TERMINATOR
 3587:	  0E42	B4 2C 06		CJNE	A,#',',IN5      ;IF NOT A COMMA DO A CR AND TRY AGAIN
 3588:	  0E45	A3			INC	DPTR		;BUMP PAST COMMA AND READ NEXT VALUE
 3589:	  0E46	12 18 61		CALL	TEMPD
 3590:	  0E49	80 CF			SJMP	IN3
 3591:					;
 3592:	  0E4B	90 00 F3	IN5:	MOV	DPTR,#IAN	;PRINT INPUT A NUMBER
 3593:	  0E4E	12 06 B7		CALL	CRP		;DO A CR, THEN, PRINT FROM ROM
 3594:	  0E51	02 18 51		LJMP	CC1		;TRY IT AGAIN
 3595:					;
 3596:	  0E54	E0		IN6:	MOVX	A,@DPTR
 3597:	  0E55	B4 0D 01		CJNE	A,#CR,EIGP
 3598:	  0E58	22			RET
 3599:					;
 3600:	  0E59	90 03 6D	EIGP:	MOV	DPTR,#EIG
 3601:	  0E5C	12 06 B7		CALL	CRP		;PRINT THE MESSAGE AND EXIT
 3602:	  0E5F	81 46			AJMP	SP0		;EXIT WITH A CRLF
 3603:					;
 3604:					;***************************************************************
 3605:					;
 3606:	  0E61			SOT:	; On timer interrupt
 3607:					;
 3608:					;***************************************************************
 3609:					;
 3610:	  0E61	D1 90			ACALL	TWO		;GET THE NUMBERS
 3611:	  0E63	8B 4B			MOV	SP_H,R3
 3612:	  0E65	89 4C			MOV	SP_L,R1
 3613:	  0E67	90 01 26		MOV	DPTR,#TIV	;SAVE THE NUMBER
 3614:	  0E6A	D2 10			SETB	OTS
 3615:	  0E6C	A1 FA			AJMP	R76S		;EXIT
 3616:					;
 3617:					;
 3618:					;***************************************************************
 3619:					;
 3620:	  0E6E			SCALL:	; Call a user rountine
 3621:					;
 3622:					;***************************************************************
 3623:					;
 3624:	  0E6E	F1 3B			ACALL	INTERR		;CONVERT INTEGER
 3625:	  0E70	BA 00 0A		CJNE	R2,#0,S_C_1	;SEE IF TRAP
 3626:	  0E73	E8			MOV	A,R0
 3627:	  0E74	20 E7 06		JB	ACC.7,S_C_1
 3628:	  0E77	28			ADD	A,R0
 3629:	  0E78	90 41 00		MOV	DPTR,#4100H
 3630:	  0E7B	F5 82			MOV	DPL,A
 3631:					;
 3632:	  0E7D	31 76		S_C_1:	ACALL	AC1		;JUMP TO USER PROGRAM
 3633:	  0E7F	53 D0 E7		ANL	PSW,#11100111B	;BACK TO BANK 0
 3634:	  0E82	22			RET			;EXIT
 3635:					;
 3636:					;**************************************************************
 3637:					;
 3638:	  0E83			THREE:	; Save value for timer function
 3639:					;
 3640:					;**************************************************************
 3641:					;
 3642:	  0E83	D1 99			ACALL	ONE		;GET THE FIRST INTEGER
 3643:	  0E85	12 16 88		CALL	CBIAS		;BIAS FOR TIMER LOAD
 3644:	  0E88	8B 40			MOV	T_HH,R3
 3645:	  0E8A	89 41			MOV	T_LL,R1
 3646:	  0E8C	7F 2C			MOV	R7,#','         ;WASTE A COMMA
 3647:	  0E8E	91 F0			ACALL	EATC		;FALL THRU TO TWO
 3648:					;
 3649:					;**************************************************************
 3650:					;
 3651:	  0E90			TWO:	; Get two values seperated by a comma off the stack
 3652:					;
 3653:					;**************************************************************
 3654:					;
 3655:	  0E90	F1 4E			ACALL	EXPRB
 3656:	  0E92	7F 2C			MOV	R7,#','         ;WASTE THE COMMA
 3657:	  0E94	F1 4C			ACALL	WE
 3658:	  0E96	02 14 AE		JMP	TWOL		;EXIT
 3659:					;
 3660:					;*************************************************************
 3661:					;
 3662:	  0E99			ONE:	; Evaluate an expression and get an integer
 3663:					;
 3664:					;*************************************************************
 3665:					;
 3666:	  0E99	F1 4E			ACALL	EXPRB		;EVALUATE EXPERSSION
 3667:					;
 3668:	  0E9B	12 12 30	IFIXL:	CALL	IFIX		;INTEGERS IN R3:R1
 3669:	  0E9E	E9			MOV	A,R1
 3670:	  0E9F	22			RET
 3671:					;
 3672:					;
 3673:					;*************************************************************
 3674:					;
 3675:	  0EA0			I_PI:	; Increment text pointer then get an integer
 3676:					;
 3677:					;*************************************************************
 3678:					;
 3679:	  0EA0	D1 E2			ACALL	GCI1		;BUMP TEXT, THEN GET INTEGER
 3680:					;
 3681:	  0EA2			PAREN_INT:; Get an integer in parens ( )
 3682:					;
 3683:	  0EA2	91 EA			ACALL	P_E
 3684:	  0EA4	80 F5			SJMP	IFIXL
 3685:					;
 3686:	  0EA6	85 13 83	DP_B:	MOV	DPH,BOFAH
 3687:	  0EA9	85 14 82		MOV	DPL,BOFAL
 3688:	  0EAC	22			RET
 3689:					;
 3690:	  0EAD	85 0A 83	DP_T:	MOV	DPH,TXAH
 3691:	  0EB0	85 08 82		MOV	DPL,TXAL
 3692:	  0EB3	22			RET
 3693:					;
 3694:	  0EB4	D1 D8		CPS:	ACALL	GC		;GET THE CHARACTER
 3695:	  0EB6	B4 22 73		CJNE	A,#'"',NOPASS   ;EXIT IF NO STRING
 3696:	  0EB9	D1 AD			ACALL	DP_T		;GET TEXT POINTER
 3697:	  0EBB	A3			INC	DPTR		;BUMP PAST "
 3698:	  0EBC	7C 22			MOV	R4,#'"'
 3699:	  0EBE	12 06 CD		CALL	PN0		;DO THE PRINT
 3700:	  0EC1	A3			INC	DPTR		;GO PAST QUOTE
 3701:	  0EC2	C3			CLR	C		;PASSED TEST
 3702:					;
 3703:	  0EC3	85 83 0A	T_DP:	MOV	TXAH,DPH	;TEXT POINTER GETS DPTR
 3704:	  0EC6	85 82 08		MOV	TXAL,DPL
 3705:	  0EC9	22			RET
 3706:					;
 3707:					;*************************************************************
 3708:					;
 3709:	  0ECA			S_C:	; Check for a string
 3710:					;
 3711:					;*************************************************************
 3712:					;
 3713:	  0ECA	D1 D8			ACALL	GC		;GET THE CHARACTER
 3714:	  0ECC	B4 24 5D		CJNE	A,#'$',NOPASS   ;SET CARRY IF NOT A STRING
 3715:	  0ECF	21 F1			AJMP	IST_CAL 	;CLEAR CARRY, CALCULATE OFFSET
 3716:					;
 3717:					;
 3718:					;
 3719:					;**************************************************************
 3720:					;
 3721:	  0ED1	D1 D8		C_TST:	ACALL	GC		;GET A CHARACTER
 3722:	  0ED3	B4 2C 56		CJNE	A,#',',NOPASS   ;SEE IF A COMMA
 3723:					;
 3724:					;***************************************************************
 3725:					;
 3726:					;GC AND GCI - GET A CHARACTER FROM TEXT (NO BLANKS)
 3727:					;	      PUT CHARACTER IN THE ACC
 3728:					;
 3729:					;***************************************************************
 3730:					;
 3731:	  0ED6	D1 E2		IGC:	ACALL	GCI1		;BUMP POINTER, THEN GET CHARACTER
 3732:					;
 3733:	  0ED8	D2 D3		GC:	SETB	RS0		;USE BANK 1
 3734:	  0EDA	8A A0			MOV	P2,R2		;SET UP PORT 2
 3735:	  0EDC	E2			MOVX	A,@R0		;GET EXTERNAL BYTE
 3736:	  0EDD	C2 D3			CLR	RS0		;BACK TO BANK 0
 3737:	  0EDF	22			RET			;EXIT
 3738:					;
 3739:	  0EE0	D1 D8		GCI:	ACALL	GC
 3740:					;
 3741:					; This routine bumps txa by one and always clears the carry
 3742:					;
 3743:	  0EE2	D2 D3		GCI1:	SETB	RS0		;BANK 1
 3744:	  0EE4	08			INC	R0		;BUMP TXA
 3745:	  0EE5	B8 00 01		CJNE	R0,#0,GCI11
 3746:	  0EE8	0A			INC	R2
 3747:	  0EE9	C2 D3		GCI11:	CLR	RS0
 3748:	  0EEB	22			RET			;EXIT
 3749:					;
 3750:					;**************************************************************
 3751:					;
 3752:					; Check delimiters
 3753:					;
 3754:					;**************************************************************
 3755:					;
 3756:	  0EEC	D1 D8		DELTST: ACALL	GC		;GET A CHARACTER
 3757:	  0EEE	B4 0D 02	DELTST1:CJNE	A,#CR,DT1	;SEE IF A CR
 3758:	  0EF1	E4			CLR	A
 3759:	  0EF2	22			RET
 3760:					;
 3761:	  0EF3	B4 3A 36	DT1:	CJNE	A,#':',NOPASS   ;SET CARRY IF NO MATCH
 3762:					;
 3763:	  0EF6	22		L_RET:	RET
 3764:					;
 3765:					;
 3766:					;***************************************************************
 3767:					;
 3768:					; FINDC - Find the character in R7, update TXA
 3769:					;
 3770:					;***************************************************************
 3771:					;
 3772:	  0EF7	7F 0D		FINDCR: MOV	R7,#CR		;KILL A STATEMENT LINE
 3773:					;
 3774:	  0EF9	D1 EC		FINDC:	ACALL	DELTST
 3775:	  0EFB	50 F9			JNC	L_RET
 3776:					;
 3777:	  0EFD	B5 07 01		CJNE	A,R7B0,FNDCL2	;MATCH?
 3778:	  0F00	22			RET
 3779:					;
 3780:	  0F01	D1 E2		FNDCL2: ACALL	GCI1
 3781:	  0F03	80 F4			SJMP	FINDC		;LOOP
 3782:					;
 3783:	  0F05	D1 E2		FNDCL3: ACALL	GCI1
 3784:					;
 3785:	  0F07	D1 EC		WCR:	ACALL	DELTST		;WASTE UNTIL A "REAL" CR
 3786:	  0F09	70 FA			JNZ	FNDCL3
 3787:	  0F0B	22			RET
 3788:					;
 3789:					;***************************************************************
 3790:					;
 3791:					; VAR_ER - Check for a variable, exit if error
 3792:					;
 3793:					;***************************************************************
 3794:					;
 3795:	  0F0C	B1 70		VAR_ER: ACALL	VAR
 3796:	  0F0E	80 2D			SJMP	INTERR1
 3797:					;
 3798:					;
 3799:					;***************************************************************
 3800:					;
 3801:					; S_D0 - The Statement Action Routine DO
 3802:					;
 3803:					;***************************************************************
 3804:					;
 3805:	  0F10	71 C7		S_DO:	ACALL	CSC		;FINISH UP THE LINE
 3806:	  0F12	7C 03			MOV	R4,#DTYPE	;TYPE FOR STACK
 3807:	  0F14	71 3F			ACALL	SGS1		;SAVE ON STACK
 3808:	  0F16	01 1D			AJMP	ILOOP		;EXIT
 3809:					;
 3810:					;***************************************************************
 3811:					;
 3812:					; CLN_UP - Clean up the end of a statement, see if at end of
 3813:					;	   file, eat character and line count after CR
 3814:					;
 3815:					;***************************************************************
 3816:					;
 3817:	  0F18	B4 3A 02	C_2:	CJNE	A,#':',C_1      ;SEE IF A TERMINATOR
 3818:	  0F1B	C1 E2			AJMP	GCI1		;BUMP POINTER AND EXIT, IF SO
 3819:					;
 3820:	  0F1D	B4 A8 6D	C_1:	CJNE	A,#T_ELSE,EP5
 3821:	  0F20	F1 07			ACALL	WCR		;WASTE UNTIL A CR
 3822:					;
 3823:	  0F22	D1 D8		CLN_UP: ACALL	GC		;GET THE CHARACTER
 3824:	  0F24	B4 0D F1		CJNE	A,#CR,C_2	;SEE IF A CR
 3825:	  0F27	D1 D6			ACALL	IGC		;GET THE NEXT CHARACTER
 3826:	  0F29	B4 01 02		CJNE	A,#EOF,B_TXA	;SEE IF TERMINATOR
 3827:					;
 3828:	  0F2C	D3		NOPASS: SETB	C
 3829:	  0F2D	22			RET
 3830:					;
 3831:	  0F2E	C5 08		B_TXA:	XCH	A,TXAL		;BUMP TXA BY THREE
 3832:	  0F30	24 03			ADD	A,#3
 3833:	  0F32	C5 08			XCH	A,TXAL
 3834:	  0F34	10 D7 01		JBC	CY,B_TXA1
 3835:	  0F37	22			RET
 3836:	  0F38	05 0A		B_TXA1: INC	TXAH
 3837:	  0F3A	22			RET
 3838:					;
 3839:					;***************************************************************
 3840:					;
 3841:					;	  Get an INTEGER from the text
 3842:					;	  sets CARRY if not found
 3843:					;	  returns the INTGER value in DPTR and R2:R0
 3844:					;	  returns the terminator in ACC
 3845:					;
 3846:					;***************************************************************
 3847:					;
 3848:	  0F3B	F1 40		INTERR: ACALL	INTGER		;GET THE INTEGER
 3849:	  0F3D	40 4E		INTERR1:JC	EP5		;ERROR IF NOT FOUND
 3850:	  0F3F	22			RET			;EXIT IF FOUND
 3851:					;
 3852:	  0F40	D1 AD		INTGER: ACALL	DP_T
 3853:	  0F42	12 19 8E		CALL	FP_BASE9	;CONVERT THE INTEGER
 3854:	  0F45	D1 C3			ACALL	T_DP
 3855:	  0F47	8A 83			MOV	DPH,R2		;PUT THE RETURNED VALUE IN THE DPTR
 3856:	  0F49	88 82			MOV	DPL,R0
 3857:					;
 3858:	  0F4B	22		ITRET:	RET			;EXIT
 3859:					;
 3860:					;
 3861:	  0F4C	91 F0		WE:	ACALL	EATC		;WASTE THE CHARACTER
 3862:					;
 3863:					; Fall thru to evaluate the expression
 3864:					;
 3865:					;***************************************************************
 3866:					;
 3867:					; EXPRB - Evaluate an expression
 3868:					;
 3869:					;***************************************************************
 3870:					;
 3871:	  0F4E	7A CF		EXPRB:	MOV	R2,#LOW OPBOL	;BASE PRECEDENCE
 3872:					;
 3873:	  0F50	C0 02		EP1:	PUSH	R2B0		;SAVE OPERATOR PRECEDENCE
 3874:	  0F52	C2 24			CLR	ARGF		;RESET STACK DESIGNATOR
 3875:					;
 3876:	  0F54	E5 81		EP2:	MOV	A,SP		;GET THE STACK POINTER
 3877:	  0F56	24 0C			ADD	A,#12		;NEED AT LEAST 12 BYTES
 3878:	  0F58	50 03			JNC	EP21
 3879:	  0F5A	02 18 99		LJMP	E1XX2
 3880:	  0F5D	E5 09		EP21:	MOV	A,ASTKA 	;GET THE ARG STACK
 3881:	  0F5F	94 38			SUBB	A,#LOW TM_TOP+12;NEED 12 BYTES ALSO
 3882:	  0F61	50 03			JNC	EP22
 3883:	  0F63	02 12 27		LJMP	E4YY
 3884:	  0F66	20 24 13	EP22:	JB	ARGF,EP4	;MUST BE AN OPERATOR, IF SET
 3885:	  0F69	B1 70			ACALL	VAR		;IS THE VALUE A VARIABLE?
 3886:	  0F6B	50 0D			JNC	EP3		;PUT VARIABLE ON STACK
 3887:					;
 3888:	  0F6D	F1 FA			ACALL	CONST		;IS THE VALUE A NUMERIC CONSTANT?
 3889:	  0F6F	50 0B			JNC	EP4		;IF SO, CONTINUE, IF NOT, SEE WHAT
 3890:	  0F71	D1 D8			CALL	GC		;GET THE CHARACTER
 3891:	  0F73	B4 E0 06		CJNE	A,#T_LPAR,EP4	;SEE IF A LEFT PAREN
 3892:	  0F76	74 D0			MOV	A,#(LOW OPBOL+1)
 3893:	  0F78	80 55			SJMP	XLPAR		;PROCESS THE LEFT PAREN
 3894:					;
 3895:	  0F7A	F1 E8		EP3:	ACALL	PUSHAS		;SAVE VAR ON STACK
 3896:					;
 3897:	  0F7C	D1 D8		EP4:	ACALL	GC		;GET THE OPERATOR
 3898:					;
 3899:	  0F7E	B4 E0 00		CJNE	A,#T_LPAR,EP41	;IS IT AN OPERATOR
 3900:	  0F81	50 0E		EP41:	JNC	XOP		;PROCESS OPERATOR
 3901:	  0F83	B4 B0 00		CJNE	A,#T_UOP,EP42	;IS IT A UNARY OPERATOR
 3902:	  0F86	50 3B		EP42:	JNC	XBILT		;PROCESS UNARY (BUILT IN) OPERATOR
 3903:	  0F88	D0 02			POP	R2B0		;GET BACK PREVIOUS OPERATOR PRECEDENCE
 3904:	  0F8A	20 24 BE		JB	ARGF,ITRET	;OK IF ARG FLAG IS SET
 3905:					;
 3906:	  0F8D	C3		EP5:	CLR	C		;NO RECOVERY
 3907:	  0F8E	02 18 94		LJMP	E1XX1
 3908:					;
 3909:					; Process the operator
 3910:					;
 3911:	  0F91	54 1F		XOP:	ANL	A,#1FH		;STRIP OFF THE TOKE BITS
 3912:	  0F93	20 24 05		JB	ARGF,XOP1	;IF ARG FLAG IS SET, PROCESS
 3913:	  0F96	B4 05 3C		CJNE	A,#T_SUB-T_LPAR,XOP3
 3914:	  0F99	74 09			MOV	A,#T_NEG-T_LPAR
 3915:					;
 3916:	  0F9B	24 D0		XOP1:	ADD	A,#LOW OPBOL+1	;BIAS THE TABLE
 3917:	  0F9D	FA			MOV	R2,A
 3918:	  0F9E	90 00 00		MOV	DPTR,#00H
 3919:	  0FA1	93			MOVC	A,@A+DPTR	;GET THE CURRENT PRECEDENCE
 3920:	  0FA2	FC			MOV	R4,A
 3921:	  0FA3	D0 E0			POP	ACC		;GET THE PREVIOUS PRECEDENCE
 3922:	  0FA5	FD			MOV	R5,A		;SAVE THE PREVIOUS PRECEDENCE
 3923:	  0FA6	93			MOVC	A,@A+DPTR	;GET IT
 3924:	  0FA7	B5 04 04		CJNE	A,R4B0,XOP11	;SEE WHICH HAS HIGHER PRECEDENCE
 3925:	  0FAA	B4 0C 9E		CJNE	A,#12,ITRET	;SEE IF ANEG
 3926:	  0FAD	D3			SETB	C
 3927:	  0FAE	50 9B		XOP11:	JNC	ITRET		;PROCESS NON-INCREASING PRECEDENCE
 3928:					;
 3929:					; Save increasing precedence
 3930:					;
 3931:	  0FB0	C0 05			PUSH	R5B0		;SAVE OLD PRECEDENCE ADDRESS
 3932:	  0FB2	C0 02			PUSH	R2B0		;SAVE NEW PRECEDENCE ADDRESS
 3933:	  0FB4	D1 E2			ACALL	GCI1		;EAT THE OPERATOR
 3934:	  0FB6	F1 50			ACALL	EP1		;EVALUATE REMAINING EXPRESSION
 3935:	  0FB8	D0 E0		XOP12:	POP	ACC
 3936:					;
 3937:					; R2 has the action address, now setup and perform operation
 3938:					;
 3939:	  0FBA	90 00 57	XOP2:	MOV	DPTR,#OPTAB
 3940:	  0FBD	24 30			ADD	A,#LOW (NOT OPBOL)
 3941:	  0FBF	31 66			CALL	ISTA1		;SET UP TO RETURN TO EP2
 3942:	  0FC1	E1 54			AJMP	EP2		;JUMP TO EVALUATE EXPRESSION
 3943:					;
 3944:					; Built-in operator processing
 3945:					;
 3946:	  0FC3	D1 E2		XBILT:	ACALL	GCI1		;EAT THE TOKEN
 3947:	  0FC5	24 30			ADD	A,#LOW (50H+LOW UOPBOL)
 3948:	  0FC7	20 24 C3		JB	ARGF,EP5	;XBILT MUST COME AFTER AN OPERATOR
 3949:	  0FCA	B4 EE 00		CJNE	A,#STP,XBILT1
 3950:	  0FCD	50 EB		XBILT1: JNC	XOP2
 3951:					;
 3952:	  0FCF	C0 E0		XLPAR:	PUSH	ACC		;PUT ADDRESS ON THE STACK
 3953:	  0FD1	91 EA			ACALL	P_E
 3954:	  0FD3	80 E3			SJMP	XOP12		;PERFORM OPERATION
 3955:					;
 3956:	  0FD5	B4 03 B5	XOP3:	CJNE	A,#T_ADD-T_LPAR,EP5
 3957:	  0FD8	D1 E2			ACALL	GCI1
 3958:	  0FDA	E1 54			AJMP	EP2		;WASTE + SIGN
 3959:					;
 3960:	  0FDC	B1 B8		XPOP:	ACALL	X3120		;FLIP ARGS THEN POP
 3961:					;
 3962:					;***************************************************************
 3963:					;
 3964:					; POPAS - Pop arg stack and copy variable to R3:R1
 3965:					;
 3966:					;***************************************************************
 3967:					;
 3968:	  0FDE	12 12 5C	POPAS:	LCALL	INC_ASTKA
 3969:	  0FE1	02 14 7F		JMP	VARCOP		;COPY THE VARIABLE
 3970:					;
 3971:	  0FE4	7A 01		AXTAL:	MOV	R2,#HIGH CXTAL
 3972:	  0FE6	78 13			MOV	R0,#LOW CXTAL
 3973:					;
 3974:					; fall thru
 3975:					;
 3976:					;***************************************************************
 3977:					;
 3978:	  0FE8			PUSHAS: ; Push the Value addressed by R2:R0 onto the arg stack
 3979:					;
 3980:					;***************************************************************
 3981:					;
 3982:	  0FE8	12 12 18		CALL	DEC_ASTKA
 3983:	  0FEB	D2 24			SETB	ARGF		;SAYS THAT SOMTHING IS ON THE STACK
 3984:	  0FED	02 14 7F		LJMP	VARCOP
 3985:					;
 3986:					;
 3987:					;***************************************************************
 3988:					;
 3989:	  0FF0			ST_A:	; Store at expression
 3990:					;
 3991:					;***************************************************************
 3992:					;
 3993:	  0FF0	D1 99			ACALL	ONE		;GET THE EXPRESSION
 3994:	  0FF2	80 EA			SJMP	POPAS		;SAVE IT
 3995:					;
 3996:					;
 3997:					;***************************************************************
 3998:					;
 3999:	  0FF4			LD_A:	; Load at expression
 4000:					;
 4001:					;***************************************************************
 4002:					;
 4003:	  0FF4	D1 99			ACALL	ONE		;GET THE EXPRESSION
 4004:	  0FF6	B1 B8			ACALL	X3120		;FLIP ARGS
 4005:	  0FF8	80 EE			SJMP	PUSHAS
 4006:					;
 4007:					;***************************************************************
 4008:					;
 4009:	  0FFA			CONST:	; Get a constant fron the text
 4010:					;
 4011:					;***************************************************************
 4012:					;
 4013:	  0FFA	D1 D8			CALL	GC		;FIRST SEE IF LITERAL
 4014:	  0FFC	B4 D1 33		CJNE	A,#T_ASC,C0C	;SEE IF ASCII TOKEN
 4015:	  0FFF	12 0E D6		CALL	IGC		;GET THE CHARACTER AFTER TOKEN
 4016:	  1002	B4 24 06		CJNE	A,#'$',CN0      ;SEE IF A STRING
 4017:					;
 4018:	  1005	12 0A 28	CNX:	CALL	CSY		;CALCULATE IT
 4019:	  1008	02 13 CD		JMP	AXBYTE1 	;SAVE IT ON THE STACK
 4020:				;
 4021:				;*****************************************************************************
 4022:				;****** Correct ASC(x) bug ***************************************************
 4023:				;****** Wulf 5 ***************************************************************
 4024:				;
 4025:				;
 4026:	  100B	30 E7 1B	CN0:	jnb	acc.7,cn0t	;jump if possibly ascii
 4027:	  100E	90 01 75		mov	dptr,#toktab
 4028:	  1011	FE			mov	r6,a		;save search token
 4029:	  1012	F4		cn0t1:	cpl	a
 4030:	  1013	60 13			jz	cn0t4		;jump if EOT
 4031:	  1015	E4			clr	a
 4032:	  1016	93			movc	a,@a+dptr	;read token from token table
 4033:	  1017	A3			inc	dptr
 4034:	  1018	B5 06 F7		cjne	a,r6b0,cn0t1	;jump if wrong entry
 4035:					;
 4036:	  101B	FD			mov	r5,a		;save search token
 4037:	  101C	E4			clr	a
 4038:	  101D	93		cn0t2:	movc	a,@a+dptr
 4039:	  101E	FE			mov	r6,a		;save first ascii of token text
 4040:					;
 4041:	  101F	E4		cn0t3:	clr	a
 4042:	  1020	93			movc	a,@a+dptr
 4043:	  1021	A3			inc	dptr
 4044:	  1022	30 E7 FA		jnb	acc.7,cn0t3	;jump if possibly ascii
 4045:					;
 4046:	  1025	6D			xrl	a,r5
 4047:	  1026	60 F5			jz	cn0t2		;jump if same search token again
 4048:					;
 4049:	  1028	EE		cn0t4:	mov	a,r6		;get saved ascii
 4050:	  1029	12 14 BE	CN0t:	CALL	TWO_R2		;PUT IT ON THE STACK
 4051:				;
 4052:				;****** continue with original code: *****************************************
 4053:				;
 4054:	  102C	12 0E E2		CALL	GCI1		;BUMP THE POINTER
 4055:	  102F	02 0C EE		JMP	ERPAR		;WASTE THE RIGHT PAREN
 4056:					;
 4057:	  1032	12 0E AD	C0C:	CALL	DP_T		;GET THE TEXT POINTER
 4058:	  1035	12 19 64		CALL	GET_NUM 	;GET THE NUMBER
 4059:	  1038	B4 FF 02		CJNE	A,#0FFH,C1C	;SEE IF NO NUMBER
 4060:	  103B	D3			SETB	C
 4061:	  103C	22		C2C:	RET
 4062:					;
 4063:	  103D	70 06		C1C:	JNZ	FPTST
 4064:	  103F	C3			CLR	C
 4065:	  1040	D2 24			SETB	ARGF
 4066:					;
 4067:	  1042	02 0E C3	C3C:	JMP	T_DP
 4068:					;
 4069:	  1045	54 0B		FPTST:	ANL	A,#00001011B	;CHECK FOR ERROR
 4070:	  1047	60 F3			JZ	C2C		;EXIT IF ZERO
 4071:					;
 4072:					; Handle the error condition
 4073:					;
 4074:	  1049	90 17 5E		MOV	DPTR,#E2X	;DIVIDE BY ZERO
 4075:	  104C	30 E0 03		JNB	ACC.0,FPTST1	;UNDERFLOW
 4076:	  104F	90 18 11		MOV	DPTR,#E7X
 4077:	  1052	30 E1 03	FPTST1: JNB	ACC.1,FPTS	;OVERFLOW
 4078:	  1055	90 1F 89		MOV	DPTR,#E11X
 4079:					;
 4080:	  1058	02 18 9C	FPTS:	JMP	ERROR
 4081:					;
 4082:					;***************************************************************
 4083:					;
 4084:					; The Command action routine - LIST
 4085:					;
 4086:					;***************************************************************
 4087:					;
 4088:	  105B	12 0C 23	CLIST:	CALL	NUMC		;SEE IF TO LINE PORT
 4089:	  105E	71 D8			ACALL	FSTK		;PUT 0FFFFH ON THE STACK
 4090:	  1060	12 0F 40		CALL	INTGER		;SEE IF USER SUPPLIES LN
 4091:	  1063	E4			CLR	A		;LN = 0 TO START
 4092:	  1064	FB			MOV	R3,A
 4093:	  1065	F9			MOV	R1,A
 4094:	  1066	40 14			JC	CL1		;START FROM ZERO
 4095:					;
 4096:	  1068	12 18 61		CALL	TEMPD		;SAVE THE START ADDTESS
 4097:	  106B	12 0E E0		CALL	GCI		;GET THE CHARACTER AFTER LIST
 4098:	  106E	B4 E5 07		CJNE	A,#T_SUB,CLIST1 ;CHECK FOR TERMINATION ADDRESS '-'
 4099:	  1071	51 5C			ACALL	INC_ASTKA	;WASTE 0FFFFH
 4100:	  1073	12 0F 3B		LCALL	INTERR		;GET TERMINATION ADDRESS
 4101:	  1076	91 C1			ACALL	TWO_EY		;PUT TERMINATION ON THE ARG STACK
 4102:	  1078	AB 0F		CLIST1: MOV	R3,TEMP5	;GET THE START ADDTESS
 4103:	  107A	A9 0E			MOV	R1,TEMP4
 4104:					;
 4105:	  107C	12 05 96	CL1:	CALL	GETLIN		;GET THE LINE NO IN R3:R1
 4106:	  107F	60 1E			JZ	CL3		;RET IF AT END
 4107:					;
 4108:	  1081	11 42		CL2:	ACALL	C3C		;SAVE THE ADDRESS
 4109:	  1083	A3			INC	DPTR		;POINT TO LINE NUMBER
 4110:	  1084	D1 5F			ACALL	PMTOP1		;PUT LINE NUMBER ON THE STACK
 4111:	  1086	51 15			ACALL	CMPLK		;COMPARE LN TO END ADDRESS
 4112:	  1088	40 15			JC	CL3		;EXIT IF GREATER
 4113:	  108A	12 07 97		CALL	BCK		;CHECK FOR A CONTROL C
 4114:	  108D	51 18			ACALL	DEC_ASTKA	;SAVE THE COMPARE ADDRESS
 4115:	  108F	12 0E AD		CALL	DP_T		;RESTORE ADDRESS
 4116:	  1092	11 B0			ACALL	UPPL		;UN-PROCESS THE LINE
 4117:	  1094	11 42			ACALL	C3C		;SAVE THE CR ADDRESS
 4118:	  1096	11 A1			ACALL	CL6		;PRINT IT
 4119:	  1098	A3			INC	DPTR		;BUMP POINTER TO NEXT LINE
 4120:	  1099	E0			MOVX	A,@DPTR 	;GET LIN LENGTH
 4121:	  109A	D5 E0 E4		DJNZ	ACC,CL2 	;LOOP
 4122:	  109D	51 5C			ACALL	INC_ASTKA	;WASTE THE COMPARE BYTE
 4123:					;
 4124:	  109F	E1 94		CL3:	AJMP	CMND1		;BACK TO COMMAND PROCESSOR
 4125:					;
 4126:	  10A1	90 00 07	CL6:	MOV	DPTR,#IBUF	;PRINT IBUF
 4127:	  10A4	12 06 CB		CALL	PRNTCR		;PRINT IT
 4128:	  10A7	12 0E AD		CALL	DP_T
 4129:					;
 4130:	  10AA	02 06 AF	CL7:	JMP	CRLF
 4131:					;
 4132:	  10AD	12 05 83	UPPL0:	LCALL	X31DP
 4133:					;
 4134:					;***************************************************************
 4135:					;
 4136:					;UPPL - UN PREPROCESS A LINE ADDRESSED BY DPTR INTO IBUF
 4137:					;	RETURN SOURCE ADDRESS OF CR IN DPTR ON RETURN
 4138:					;
 4139:					;***************************************************************
 4140:					;
 4141:	  10B0	7B 00		UPPL:	MOV	R3,#HIGH IBUF	;POINT R3 AT HIGH IBUF
 4142:	  10B2	79 07			MOV	R1,#LOW IBUF	;POINT R1 AT IBUF
 4143:	  10B4	A3			INC	DPTR		;SKIP OVER LINE LENGTH
 4144:				;
 4145:				;*****************************************************************************
 4146:				;****** Elektor 1 Patch ******************************************************
 4147:				;
 4148:				;	ACALL	C3C		;SAVE THE DPTR (DP_T)
 4149:				;	CALL	L20DPI		;PUT LINE NUMBER IN R2:R0
 4150:				;	CALL	FP_BASE8	;CONVERT R2:R0 TO INTEGER
 4151:				;	CALL	DP_T
 4152:				;	INC	DPTR		;BUMP DPTR PAST THE LINE NUMBER
 4153:				;
 4154:				;****** Proper code starts here: *********************************************
 4155:				;
 4156:	  10B5	12 05 7D		lcall	L20DPI		;PUT LINE NUMBER IN R2:R0
 4157:	  10B8	12 19 8C		lcall	FP_BASE8	;CONVERT R2:R0 TO INTEGER
 4158:				;
 4159:				;****** continue with original code: *****************************************
 4160:				;
 4161:	  10BB	B9 0D 00	UPP0:	CJNE	R1,#LOW IBUF+6,UPP01
 4162:	  10BE	40 22		UPP01:	JC	UPP91		;PUT SPACES IN TEXT
 4163:	  10C0	A3			INC	DPTR		;BUMP PAST LN HIGH
 4164:	  10C1	E0			MOVX	A,@DPTR 	;GET USER TEXT
 4165:	  10C2	FE			MOV	R6,A		;SAVE A IN R6 FOR TOKE COMPARE
 4166:	  10C3	20 E7 24		JB	ACC.7,UPP1	;IF TOKEN, PROCESS
 4167:	  10C6	B4 20 00		CJNE	A,#20H,UPP02	;TRAP THE USER TOKENS
 4168:	  10C9	50 03		UPP02:	JNC	UPP03
 4169:	  10CB	B4 0D 1C		CJNE	A,#CR,UPP1	;DO IT IF NOT A CR
 4170:	  10CE	B4 22 09	UPP03:	CJNE	A,#'"',UPP9     ;SEE IF STRING
 4171:	  10D1	31 2E			ACALL	UPP7		;SAVE IT
 4172:	  10D3	31 30		UPP04:	ACALL	UPP8		;GET THE NEXT CHARACTER AND SAVE IT
 4173:	  10D5	B4 22 FB		CJNE	A,#'"',UPP04    ;LOOP ON QUOTES
 4174:	  10D8	80 E1			SJMP	UPP0
 4175:					;
 4176:	  10DA	B4 3A 09	UPP9:	CJNE	A,#':',UPP1A    ;PUT A SPACE IN DELIMITER
 4177:	  10DD	31 2C			ACALL	UPP7A
 4178:	  10DF	EE			MOV	A,R6
 4179:	  10E0	31 2E			ACALL	UPP7
 4180:	  10E2	31 2C		UPP91:	ACALL	UPP7A
 4181:	  10E4	80 D5			SJMP	UPP0
 4182:					;
 4183:	  10E6	31 32		UPP1A:	ACALL	UPP81		;SAVE THE CHARACTER, UPDATE POINTER
 4184:	  10E8	80 D1			SJMP	UPP0		;EXIT IF A CR, ELSE LOOP
 4185:					;
 4186:	  10EA	11 42		UPP1:	ACALL	C3C		;SAVE THE TEXT POINTER
 4187:	  10EC	A2 2D			MOV	C,XBIT
 4188:	  10EE	92 D5			MOV	F0,C		;SAVE XBIT IN F0
 4189:	  10F0	90 01 75	UPP11:	MOV	DPTR,#TOKTAB	;POINT AT TOKEN TABLE
 4190:	  10F3	30 D5 03		JNB	F0,UPP2
 4191:	  10F6	12 20 78		LCALL	2078H		;SET UP DPTR FOR LOOKUP
 4192:					;
 4193:	  10F9	E4		UPP2:	CLR	A		;ZERO A FOR LOOKUP
 4194:	  10FA	93			MOVC	A,@A+DPTR	;GET TOKEN
 4195:	  10FB	A3			INC	DPTR		;ADVANCE THE TOKEN POINTER
 4196:	  10FC	B4 FF 05		CJNE	A,#0FFH,UP_2	;SEE IF DONE
 4197:	  10FF	10 D5 EE		JBC	F0,UPP11	;NOW DO NORMAL TABLE
 4198:	  1102	E1 94			AJMP	CMND1		;EXIT IF NOT FOUND
 4199:					;
 4200:	  1104	B5 06 F2	UP_2:	CJNE	A,R6B0,UPP2	;LOOP UNTIL THE SAME
 4201:					;
 4202:	  1107	B4 B0 00	UP_3:	CJNE	A,#T_UOP,UP_4
 4203:	  110A	50 02		UP_4:	JNC	UPP3
 4204:	  110C	31 2C			ACALL	UPP7A		;PRINT THE SPACE IF OK
 4205:					;
 4206:	  110E	E4		UPP3:	CLR	A		;DO LOOKUP
 4207:	  110F	93			MOVC	A,@A+DPTR
 4208:	  1110	20 E7 07		JB	ACC.7,UPP4	;EXIT IF DONE, ELSE SAVE
 4209:	  1113	60 05			JZ	UPP4		;DONE IF ZERO
 4210:	  1115	31 2E			ACALL	UPP7		;SAVE THE CHARACTER
 4211:	  1117	A3			INC	DPTR
 4212:	  1118	80 F4			SJMP	UPP3		;LOOP
 4213:					;
 4214:	  111A	12 0E AD	UPP4:	CALL	DP_T		;GET IT BACK
 4215:	  111D	EE			MOV	A,R6		;SEE IF A REM TOKEN
 4216:	  111E	64 96			XRL	A,#T_REM
 4217:	  1120	70 04			JNZ	UPP42
 4218:	  1122	31 30		UPP41:	ACALL	UPP8
 4219:	  1124	80 FC			SJMP	UPP41
 4220:	  1126	50 93		UPP42:	JNC	UPP0		;START OVER AGAIN IF NO TOKEN
 4221:	  1128	31 2C			ACALL	UPP7A		;PRINT THE SPACE IF OK
 4222:	  112A	80 8F			SJMP	UPP0		;DONE
 4223:					;
 4224:	  112C	74 20		UPP7A:	MOV	A,#' '          ;OUTPUT A SPACE
 4225:					;
 4226:	  112E	C1 51		UPP7:	AJMP	PPL91		;SAVE A
 4227:					;
 4228:	  1130	A3		UPP8:	INC	DPTR
 4229:	  1131	E0			MOVX	A,@DPTR
 4230:	  1132	B4 0D F9	UPP81:	CJNE	A,#CR,UPP7
 4231:	  1135	C1 3D			AJMP	PPL71
 4232:					;
 4233:					;**************************************************************
 4234:					;
 4235:					; This table contains all of the floating point constants
 4236:					;
 4237:					; The constants in ROM are stored "backwards" from the way
 4238:					; basic normally treats floating point numbers. Instead of
 4239:					; loading from the exponent and decrementing the pointer,
 4240:					; ROM constants pointers load from the most significant
 4241:					; digits and increment the pointers. This is done to 1) make
 4242:					; arg stack loading faster and 2) compensate for the fact that
 4243:					; no decrement data pointer instruction exsist.
 4244:					;
 4245:					; The numbers are stored as follows:
 4246:					;
 4247:					; BYTE X+5    = MOST SIGNIFICANT DIGITS IN BCD
 4248:					; BYTE X+4    = NEXT MOST SIGNIFICANT DIGITS IN BCD
 4249:					; BYTE X+3    = NEXT LEAST SIGNIFICANT DIGITS IN BCD
 4250:					; BYTE X+2    = LEAST SIGNIFICANT DIGITS IN BCD
 4251:					; BYTE X+1    = SIGN OF THE ABOVE MANTISSA 0 = +, 1 = -
 4252:					; BYTE X      = EXPONENT IN TWO'S COMPLEMENT BINARY
 4253:					;		ZERO EXPONENT = THE NUMBER ZERO
 4254:					;
 4255:					;**************************************************************
 4256:					;
 4257:	  1137	7E		ATTAB:	DB	128-2		; ARCTAN LOOKUP
 4258:	  1138	00			DB	00H
 4259:	  1139	57			DB	57H
 4260:	  113A	22			DB	22H
 4261:	  113B	66			DB	66H
 4262:	  113C	28			DB	28H
 4263:					;
 4264:	  113D	7F			DB	128-1
 4265:	  113E	01			DB	01H
 4266:	  113F	37			DB	37H
 4267:	  1140	57			DB	57H
 4268:	  1141	16			DB	16H
 4269:	  1142	16			DB	16H
 4270:					;
 4271:	  1143	7F			DB	128-1
 4272:	  1144	00			DB	00H
 4273:	  1145	14			DB	14H
 4274:	  1146	96			DB	96H
 4275:	  1147	90			DB	90H
 4276:	  1148	42			DB	42H
 4277:					;
 4278:	  1149	7F			DB	128-1
 4279:	  114A	01			DB	01H
 4280:	  114B	40			DB	40H
 4281:	  114C	96			DB	96H
 4282:	  114D	28			DB	28H
 4283:	  114E	75			DB	75H
 4284:					;
 4285:	  114F	80			DB	128
 4286:	  1150	00			DB	00H
 4287:	  1151	64			DB	64H
 4288:	  1152	62			DB	62H
 4289:	  1153	65			DB	65H
 4290:	  1154	10			DB	10H
 4291:					;
 4292:	  1155	80			DB	128
 4293:	  1156	01			DB	01H
 4294:	  1157	99			DB	99H
 4295:	  1158	88			DB	88H
 4296:	  1159	20			DB	20H
 4297:	  115A	14			DB	14H
 4298:					;
 4299:	  115B	80			DB	128
 4300:	  115C	00			DB	00H
 4301:	  115D	51			DB	51H
 4302:	  115E	35			DB	35H
 4303:	  115F	99			DB	99H
 4304:	  1160	19			DB	19H
 4305:					;
 4306:	  1161	80			DB	128
 4307:	  1162	01			DB	01H
 4308:	  1163	45			DB	45H
 4309:	  1164	31			DB	31H
 4310:	  1165	33			DB	33H
 4311:	  1166	33			DB	33H
 4312:					;
 4313:	  1167	81			DB	129
 4314:	  1168	00			DB	00H
 4315:	  1169	00			DB	00H
 4316:	  116A	00			DB	00H
 4317:	  116B	00			DB	00H
 4318:	  116C	10			DB	10H
 4319:					;
 4320:	  116D	FF			DB	0FFH		;END OF TABLE
 4321:					;
 4322:	  116E	81		NTWO:	DB	129
 4323:	  116F	00			DB	0
 4324:	  1170	00			DB	0
 4325:	  1171	00			DB	0
 4326:	  1172	00			DB	0
 4327:	  1173	20			DB	20H
 4328:				;
 4329:				;*****************************************************************************
 4330:				;****** Use XTAL up to 47 MHz ************************************************
 4331:				;****** Wulf 2 ***************************************************************
 4332:				;
 4333:				;TTIME: DB	128-4		; CLOCK CALCULATION
 4334:				;	DB	00H
 4335:				;	DB	00H
 4336:				;	DB	00H
 4337:				;	DB	04H
 4338:				;	DB	13H
 4339:				;
 4340:	  1174	7B		ttime:	db	128-5		;New clock calculation for timer 0 in
 4341:	  1175	00			db	00H		;16 bit mode
 4342:	  1176	42			db	42H
 4343:	  1177	60			db	60H
 4344:	  1178	27			db	27H
 4345:	  1179	16			db	16H
 4346:				;
 4347:				;*****************************************************************************
 4348:				;
 4349:					;***************************************************************
 4350:					;
 4351:					; COSINE - Add pi/2 to stack, then fall thru to SIN
 4352:					;
 4353:					;***************************************************************
 4354:					;
 4355:	  117A	31 9F		ACOS:	ACALL	POTWO		;PUT PI/2 ON THE STACK
 4356:	  117C	F1 4E			ACALL	AADD		;TOS = TOS+PI/2
 4357:					;
 4358:					;***************************************************************
 4359:					;
 4360:					; SINE - use taylor series to calculate sin function
 4361:					;
 4362:					;***************************************************************
 4363:					;
 4364:	  117E	91 8C		ASIN:	ACALL	PIPI		;PUT PI ON THE STACK
 4365:	  1180	31 C2			ACALL	RV		;REDUCE THE VALUE
 4366:	  1182	E5 46			MOV	A,MT2		;CALCULATE THE SIGN
 4367:	  1184	54 01			ANL	A,#01H		;SAVE LSB
 4368:	  1186	62 45			XRL	MT1,A		;SAVE SIGN IN MT1
 4369:	  1188	91 39			ACALL	CSTAKA		;NOW CONVERT TO ONE QUADRANT
 4370:	  118A	31 9F			ACALL	POTWO
 4371:	  118C	51 15			ACALL	CMPLK		;DO COMPARE
 4372:	  118E	40 04			JC	ASIN1
 4373:	  1190	91 8C			ACALL	PIPI
 4374:	  1192	F1 29			ACALL	ASUB
 4375:	  1194	71 9C		ASIN1:	ACALL	AABS
 4376:	  1196	90 16 DB		MOV	DPTR,#SINTAB	;SET UP LOOKUP TABLE
 4377:	  1199	31 A8			ACALL	POLYC		;CALCULATE THE POLY
 4378:	  119B	31 E7			ACALL	STRIP
 4379:	  119D	41 09			AJMP	SIN0
 4380:					;
 4381:					; Put PI/2 on the stack
 4382:					;
 4383:	  119F	91 8C		POTWO:	ACALL	PIPI		;PUT PI ON THE STACK, NOW DIVIDE
 4384:					;
 4385:	  11A1	90 11 6E	DBTWO:	MOV	DPTR,#NTWO
 4386:	  11A4	91 40			ACALL	PUSHC
 4387:					;MOV	A,#2		;BY TWO
 4388:					;ACALL	TWO_R2
 4389:	  11A6	81 17			AJMP	ADIV
 4390:					;
 4391:					;*************************************************************
 4392:					;
 4393:	  11A8			POLYC:	; Expand a power series to calculate a polynomial
 4394:					;
 4395:					;*************************************************************
 4396:					;
 4397:	  11A8	91 37			ACALL	CSTAKA2 	;COPY THE STACK
 4398:	  11AA	31 BD			ACALL	AMUL		;SQUARE THE STACK
 4399:	  11AC	91 55			ACALL	POP_T1		;SAVE X*X
 4400:	  11AE	91 40			ACALL	PUSHC		;PUT CONSTANT ON STACK
 4401:					;
 4402:	  11B0	91 5C		POLY1:	ACALL	PUSH_T1 	;PUT COMPUTED VALUE ON STACK
 4403:	  11B2	31 BD			ACALL	AMUL		;MULTIPLY CONSTANT AND COMPUTED VALUE
 4404:	  11B4	91 40			ACALL	PUSHC		;PUT NEXT CONSTANT ON STACK
 4405:	  11B6	F1 4E			ACALL	AADD		;ADD IT TO THE OLD VALUE
 4406:	  11B8	E4			CLR	A		;CHECK TO SEE IF DONE
 4407:	  11B9	93			MOVC	A,@A+DPTR
 4408:	  11BA	B4 FF F3		CJNE	A,#0FFH,POLY1	;LOOP UNTIL DONE
 4409:					;
 4410:	  11BD	12 19 82	AMUL:	LCALL	FP_BASE3
 4411:	  11C0	01 45			AJMP	FPTST
 4412:					;
 4413:					;*************************************************************
 4414:					;
 4415:	  11C2			RV:	; Reduce a value for Trig and A**X functions
 4416:					;
 4417:					; value = (value/x - INT(value/x)) * x
 4418:					;
 4419:					;*************************************************************
 4420:					;
 4421:	  11C2	91 79			ACALL	C2_T2		;COPY TOS TO T2
 4422:	  11C4	91 17			ACALL	ADIV		;TOS = TOS/TEMP2
 4423:	  11C6	71 9C			ACALL	AABS		;MAKE THE TOS A POSITIVE NUMBER
 4424:	  11C8	F5 45			MOV	MT1,A		;SAVE THE SIGN
 4425:	  11CA	91 37			ACALL	CSTAKA2 	;COPY THE STACK TWICE
 4426:	  11CC	51 30			ACALL	IFIX		;PUT THE NUMBER IN R3:R1
 4427:	  11CE	C0 03			PUSH	R3B0		;SAVE R3
 4428:	  11D0	89 46			MOV	MT2,R1		;SAVE THE LS BYTE IN MT2
 4429:	  11D2	71 7A			ACALL	AINT		;MAKE THE TOS AN INTEGER
 4430:	  11D4	F1 29			ACALL	ASUB		;TOS = TOS/T2 - INT(TOS/T2)
 4431:	  11D6	91 63			ACALL	P_T2		;TOS = T2
 4432:	  11D8	31 BD			ACALL	AMUL		;TOS = T2*(TOS/T2 - INT(TOS/T2)
 4433:	  11DA	D0 03			POP	R3B0		;RESTORE R3
 4434:	  11DC	22			RET			;EXIT
 4435:					;
 4436:					;**************************************************************
 4437:					;
 4438:					; TAN
 4439:					;
 4440:					;**************************************************************
 4441:					;
 4442:	  11DD	91 39		ATAN:	ACALL	CSTAKA		;DUPLACATE STACK
 4443:	  11DF	31 7E			ACALL	ASIN		;TOS = SIN(X)
 4444:	  11E1	91 67			ACALL	SWAP_ASTKA	;TOS = X
 4445:	  11E3	31 7A			ACALL	ACOS		;TOS = COS(X)
 4446:	  11E5	81 17			AJMP	ADIV		;TOS = SIN(X)/COS(X)
 4447:					;
 4448:	  11E7	51 60		STRIP:	ACALL	SETREG		;SETUP R0
 4449:	  11E9	7B 01			MOV	R3,#1		;LOOP COUNT
 4450:	  11EB	61 8E			AJMP	AI11		;WASTE THE LSB
 4451:					;
 4452:					;************************************************************
 4453:					;
 4454:					; ARC TAN
 4455:					;
 4456:					;************************************************************
 4457:					;
 4458:	  11ED	71 9C		AATAN:	ACALL	AABS
 4459:	  11EF	F5 45			MOV	MT1,A		;SAVE THE SIGN
 4460:	  11F1	51 60			ACALL	SETREG		;GET THE EXPONENT
 4461:	  11F3	24 7F			ADD	A,#7FH		;BIAS THE EXPONENT
 4462:	  11F5	92 2A			MOV	UBIT,C		;SAVE CARRY STATUS
 4463:	  11F7	50 02			JNC	AATAN1		;SEE IF > 1
 4464:	  11F9	51 89			ACALL	RECIP		;IF > 1, TAKE RECIP
 4465:	  11FB	90 11 37	AATAN1: MOV	DPTR,#ATTAB	;SET UP TO CALCULATE THE POLY
 4466:	  11FE	31 A8			ACALL	POLYC		;CALCULATE THE POLY
 4467:	  1200	30 2A 06		JNB	UBIT,SIN0	;JUMP IF NOT SET
 4468:	  1203	71 AE			ACALL	ANEG		;MAKE X POLY NEGATIVE
 4469:	  1205	31 9F			ACALL	POTWO		;SUBTRACT PI/2
 4470:	  1207	F1 4E			ACALL	AADD
 4471:					;
 4472:	  1209	E5 45		SIN0:	MOV	A,MT1		;GET THE SIGN
 4473:	  120B	60 19			JZ	SRT
 4474:	  120D	61 AE			AJMP	ANEG
 4475:					;
 4476:					;*************************************************************
 4477:					;
 4478:					; FCOMP - COMPARE 0FFFFH TO TOS
 4479:					;
 4480:					;*************************************************************
 4481:					;
 4482:	  120F	91 39		FCMP:	ACALL	CSTAKA		;COPY THE STACK
 4483:	  1211	71 D8			ACALL	FSTK		;MAKE THE TOS = 0FFFFH
 4484:	  1213	91 67			ACALL	SWAP_ASTKA	;NOW COMPARE IS 0FFFFH - X
 4485:					;
 4486:	  1215	02 19 80	CMPLK:	JMP	FP_BASE2	;DO THE COMPARE
 4487:					;
 4488:					;*************************************************************
 4489:					;
 4490:	  1218			DEC_ASTKA:	;Push ARG STACK and check for underflow
 4491:					;
 4492:					;*************************************************************
 4493:					;
 4494:	  1218	74 FA			MOV	A,#-FPSIZ
 4495:	  121A	25 09			ADD	A,ASTKA
 4496:	  121C	B4 32 00		CJNE	A,#LOW TM_TOP+6,DEC_ASTKA1
 4497:	  121F			DEC_ASTKA1:
 4498:	  121F	40 06			JC	E4YY
 4499:	  1221	F5 09			MOV	ASTKA,A
 4500:	  1223	F9			MOV	R1,A
 4501:	  1224	7B 01			MOV	R3,#ASTKAH
 4502:					;
 4503:	  1226	22		SRT:	RET
 4504:					;
 4505:	  1227	90 03 7B	E4YY:	MOV	DPTR,#EXA
 4506:	  122A	01 58			AJMP	FPTS		;ARG STACK ERROR
 4507:					;
 4508:					;
 4509:	  122C	91 40		AXTAL3: ACALL	PUSHC		;PUSH CONSTANT, THEN MULTIPLY
 4510:	  122E	31 BD			ACALL	AMUL
 4511:					;
 4512:					; Fall thru to IFIX
 4513:					;
 4514:					;***************************************************************
 4515:					;
 4516:	  1230			IFIX:	; Convert a floating point number to an integer, put in R3:R1
 4517:					;
 4518:					;***************************************************************
 4519:					;
 4520:	  1230	E4			CLR	A		;RESET THE START
 4521:	  1231	FB			MOV	R3,A
 4522:	  1232	F9			MOV	R1,A
 4523:	  1233	A8 09			MOV	R0,ASTKA	;GET THE ARG STACK
 4524:	  1235	75 A0 01		MOV	P2,#ASTKAH
 4525:	  1238	E2			MOVX	A,@R0		;READ EXPONENT
 4526:	  1239	C3			CLR	C
 4527:	  123A	94 81			SUBB	A,#81H		;BASE EXPONENT
 4528:	  123C	FC			MOV	R4,A		;SAVE IT
 4529:	  123D	18			DEC	R0		;POINT AT SIGN
 4530:	  123E	E2			MOVX	A,@R0		;GET THE SIGN
 4531:	  123F	70 56			JNZ	SQ_ERR		;ERROR IF NEGATIVE
 4532:	  1241	40 19			JC	INC_ASTKA	;EXIT IF EXPONENT IS < 81H
 4533:	  1243	0C			INC	R4		;ADJUST LOOP COUNTER
 4534:	  1244	E8			MOV	A,R0		;BUMP THE POINTER REGISTER
 4535:	  1245	94 05			SUBB	A,#FPSIZ-1
 4536:	  1247	F8			MOV	R0,A
 4537:					;
 4538:	  1248	08		I2:	INC	R0		;POINT AT DIGIT
 4539:	  1249	E2			MOVX	A,@R0		;GET DIGIT
 4540:	  124A	C4			SWAP	A		;FLIP
 4541:	  124B	12 19 90		CALL	FP_BASE10	;ACCUMULATE
 4542:	  124E	40 47			JC	SQ_ERR
 4543:	  1250	DC 02			DJNZ	R4,I21
 4544:	  1252	80 08			SJMP	INC_ASTKA
 4545:	  1254	E2		I21:	MOVX	A,@R0		;GET DIGIT
 4546:	  1255	12 19 90		CALL	FP_BASE10
 4547:	  1258	40 3D			JC	SQ_ERR
 4548:	  125A	DC EC			DJNZ	R4,I2
 4549:					;
 4550:					;************************************************************
 4551:					;
 4552:	  125C			INC_ASTKA:	; Pop the ARG STACK and check for overflow
 4553:					;
 4554:					;************************************************************
 4555:					;
 4556:	  125C	74 06			MOV	A,#FPSIZ	;NUMBER TO POP
 4557:	  125E	80 01			SJMP	SETREG1
 4558:					;
 4559:	  1260	E4		SETREG: CLR	A		;DON'T POP ANYTHING
 4560:	  1261	A8 09		SETREG1:MOV	R0,ASTKA
 4561:	  1263	7A 01			MOV	R2,#ASTKAH
 4562:	  1265	8A A0			MOV	P2,R2
 4563:	  1267	28			ADD	A,R0
 4564:	  1268	40 BD			JC	E4YY
 4565:	  126A	F5 09			MOV	ASTKA,A
 4566:	  126C	E2			MOVX	A,@R0
 4567:	  126D	22		A_D:	RET
 4568:					;
 4569:					;************************************************************
 4570:					;
 4571:					; EBIAS - Bias a number for E to the X calculations
 4572:					;
 4573:					;************************************************************
 4574:					;
 4575:	  126E	91 50		EBIAS:	ACALL	PUSH_ONE
 4576:	  1270	31 C2			ACALL	RV
 4577:	  1272	BB 00 22		CJNE	R3,#00H,SQ_ERR	;ERROR IF R3 <> 0
 4578:	  1275	91 79			ACALL	C2_T2		;TEMP 2 GETS FRACTIONS
 4579:	  1277	51 5C			ACALL	INC_ASTKA
 4580:	  1279	91 55			ACALL	POP_T1
 4581:	  127B	91 50			ACALL	PUSH_ONE
 4582:					;
 4583:	  127D	E5 46		AELP:	MOV	A,MT2
 4584:	  127F	70 0E			JNZ	AEL1
 4585:					;
 4586:	  1281	E5 45			MOV	A,MT1
 4587:	  1283	60 E8			JZ	A_D
 4588:	  1285	90 01 1E		MOV	DPTR,#FPT2-1
 4589:	  1288	F0			MOVX	@DPTR,A 	;MAKE THE FRACTIONS NEGATIVE
 4590:					;
 4591:	  1289	91 50		RECIP:	ACALL	PUSH_ONE
 4592:	  128B	91 67			ACALL	SWAP_ASTKA
 4593:	  128D	81 17			AJMP	ADIV
 4594:					;
 4595:	  128F	15 46		AEL1:	DEC	MT2
 4596:	  1291	91 5C			ACALL	PUSH_T1
 4597:	  1293	31 BD			ACALL	AMUL
 4598:	  1295	80 E6			SJMP	AELP
 4599:					;
 4600:	  1297	02 09 C7	SQ_ERR: LJMP	E3XX		;LINK TO BAD ARG
 4601:					;
 4602:					;************************************************************
 4603:					;
 4604:					; SQUARE ROOT
 4605:					;
 4606:					;************************************************************
 4607:					;
 4608:	  129A	71 9C		ASQR:	ACALL	AABS		;GET THE SIGN
 4609:	  129C	70 F9			JNZ	SQ_ERR		;ERROR IF NEGATIVE
 4610:	  129E	91 79			ACALL	C2_T2		;COPY VARIABLE TO T2
 4611:	  12A0	91 55			ACALL	POP_T1		;SAVE IT IN T1
 4612:	  12A2	78 19			MOV	R0,#LOW FPT1
 4613:	  12A4	E2			MOVX	A,@R0		;GET EXPONENT
 4614:	  12A5	60 24			JZ	SQR41		;EXIT IF ZERO
 4615:	  12A7	24 80			ADD	A,#128		;BIAS THE EXPONENT
 4616:	  12A9	50 05			JNC	SQR1		;SEE IF < 80H
 4617:	  12AB	03			RR	A
 4618:	  12AC	54 7F			ANL	A,#127
 4619:	  12AE	80 07			SJMP	SQR2
 4620:					;
 4621:	  12B0	F4		SQR1:	CPL	A		;FLIP BITS
 4622:	  12B1	04			INC	A
 4623:	  12B2	03			RR	A
 4624:	  12B3	54 7F			ANL	A,#127		;STRIP MSB
 4625:	  12B5	F4			CPL	A
 4626:	  12B6	04			INC	A
 4627:					;
 4628:	  12B7	24 80		SQR2:	ADD	A,#128		;BIAS EXPONENT
 4629:	  12B9	F2			MOVX	@R0,A		;SAVE IT
 4630:					;
 4631:					; NEWGUESS = ( X/OLDGUESS + OLDGUESS) / 2
 4632:					;
 4633:	  12BA	91 63		SQR4:	ACALL	P_T2		;TOS = X
 4634:	  12BC	91 5C			ACALL	PUSH_T1 	;PUT NUMBER ON STACK
 4635:	  12BE	91 17			ACALL	ADIV		;TOS = X/GUESS
 4636:	  12C0	91 5C			ACALL	PUSH_T1 	;PUT ON AGAIN
 4637:	  12C2	F1 4E			ACALL	AADD		;TOS = X/GUESS + GUESS
 4638:	  12C4	31 A1			ACALL	DBTWO		;TOS = ( X/GUESS + GUESS ) / 2
 4639:	  12C6	71 29			ACALL	TEMP_COMP	;SEE IF DONE
 4640:	  12C8	30 D5 EF		JNB	F0,SQR4
 4641:					;
 4642:	  12CB	81 5C		SQR41:	AJMP	PUSH_T1 	;PUT THE ANSWER ON THE STACK
 4643:					;
 4644:					;*************************************************************
 4645:					;
 4646:					; NATURAL LOG
 4647:					;
 4648:					;*************************************************************
 4649:					;
 4650:	  12CD	71 9C		ALN:	ACALL	AABS		;MAKE SURE THAT NUM IS POSITIVE
 4651:	  12CF	70 C6			JNZ	SQ_ERR		;ERROR IF NOT
 4652:	  12D1	F5 46			MOV	MT2,A		;CLEAR FOR LOOP
 4653:	  12D3	08			INC	R0		;POINT AT EXPONENT
 4654:	  12D4	E2			MOVX	A,@R0		;READ THE EXPONENT
 4655:	  12D5	60 C0			JZ	SQ_ERR		;ERROR IF EXPONENT IS ZERO
 4656:	  12D7	B4 81 00		CJNE	A,#81H,ALN1	;SEE IF NUM >= 1
 4657:	  12DA	92 2A		ALN1:	MOV	UBIT,C		;SAVE CARRY STATUS
 4658:	  12DC	40 02			JC	ALNL		;TAKE RECIP IF >= 1
 4659:	  12DE	51 89			ACALL	RECIP
 4660:					;
 4661:					; Loop to reduce
 4662:					;
 4663:	  12E0	91 39		ALNL:	ACALL	CSTAKA		;COPY THE STACK FOR COMPARE
 4664:	  12E2	91 50			ACALL	PUSH_ONE	;COMPARE NUM TO ONE
 4665:	  12E4	51 15			ACALL	CMPLK
 4666:	  12E6	50 1D			JNC	ALNO		;EXIT IF DONE
 4667:	  12E8	51 60			ACALL	SETREG		;GET THE EXPONENT
 4668:	  12EA	24 85			ADD	A,#85H		;SEE HOW BIG IT IS
 4669:	  12EC	50 0E			JNC	ALN11		;BUMP BY EXP(11) IF TOO SMALL
 4670:	  12EE	91 3D			ACALL	PLNEXP		;PUT EXP(1) ON STACK
 4671:	  12F0	74 01			MOV	A,#1		;BUMP COUNT
 4672:					;
 4673:	  12F2	25 46		ALNE:	ADD	A,MT2
 4674:	  12F4	40 A1			JC	SQ_ERR
 4675:	  12F6	F5 46			MOV	MT2,A
 4676:	  12F8	31 BD			ACALL	AMUL		;BIAS THE NUMBER
 4677:	  12FA	80 E4			SJMP	ALNL
 4678:					;
 4679:	  12FC	90 17 FF	ALN11:	MOV	DPTR,#EXP11	;PUT EXP(11) ON STACK
 4680:	  12FF	91 40			ACALL	PUSHC
 4681:	  1301	74 0B			MOV	A,#11
 4682:	  1303	80 ED			SJMP	ALNE
 4683:					;
 4684:	  1305	91 79		ALNO:	ACALL	C2_T2		;PUT NUM IN TEMP 2
 4685:	  1307	91 50			ACALL	PUSH_ONE	;TOS = 1
 4686:	  1309	F1 29			ACALL	ASUB		;TOS = X - 1
 4687:	  130B	91 63			ACALL	P_T2		;TOS = X
 4688:	  130D	91 50			ACALL	PUSH_ONE	;TOS = 1
 4689:	  130F	F1 4E			ACALL	AADD		;TOS = X + 1
 4690:	  1311	91 17			ACALL	ADIV		;TOS = (X-1)/(X+1)
 4691:	  1313	90 16 B6		MOV	DPTR,#LNTAB	;LOG TABLE
 4692:	  1316	31 A8			ACALL	POLYC
 4693:	  1318	A3			INC	DPTR		;POINT AT LN(10)
 4694:	  1319	91 40			ACALL	PUSHC
 4695:	  131B	31 BD			ACALL	AMUL
 4696:	  131D	E5 46			MOV	A,MT2		;GET THE COUNT
 4697:	  131F	91 BE			ACALL	TWO_R2		;PUT IT ON THE STACK
 4698:	  1321	F1 29			ACALL	ASUB		;INT - POLY
 4699:	  1323	31 E7			ACALL	STRIP
 4700:	  1325	30 2A 74		JNB	UBIT,AABS
 4701:					;
 4702:	  1328	22		LN_D:	RET
 4703:					;
 4704:					;*************************************************************
 4705:					;
 4706:	  1329			TEMP_COMP:	; Compare FPTEMP1 to TOS, FPTEMP1 gets TOS
 4707:					;
 4708:					;*************************************************************
 4709:					;
 4710:	  1329	91 5C			ACALL	PUSH_T1 	;SAVE THE TEMP
 4711:	  132B	91 67			ACALL	SWAP_ASTKA	;TRADE WITH THE NEXT NUMBER
 4712:	  132D	91 39			ACALL	CSTAKA		;COPY THE STACK
 4713:	  132F	91 55			ACALL	POP_T1		;SAVE THE NEW NUMBER
 4714:	  1331	02 19 80		JMP	FP_BASE2	;DO THE COMPARE
 4715:					;
 4716:	  1334	91 3D		AETOX:	ACALL	PLNEXP		;EXP(1) ON TOS
 4717:	  1336	91 67			ACALL	SWAP_ASTKA	;X ON TOS
 4718:					;
 4719:	  1338			AEXP:	;EXPONENTIATION
 4720:					;
 4721:	  1338	51 6E			ACALL	EBIAS		;T1=BASE,T2=FRACTIONS,TOS=INT MULTIPLIED
 4722:	  133A	90 01 1F		MOV	DPTR,#FPT2	;POINT AT FRACTIONS
 4723:	  133D	E0			MOVX	A,@DPTR 	;READ THE EXP OF THE FRACTIONS
 4724:	  133E	60 E8			JZ	LN_D		;EXIT IF ZERO
 4725:	  1340	91 63			ACALL	P_T2		;TOS = FRACTIONS
 4726:	  1342	91 5C			ACALL	PUSH_T1 	;TOS = BASE
 4727:	  1344	51 60			ACALL	SETREG		;SEE IF BASE IS ZERO
 4728:	  1346	60 02			JZ	AEXP1
 4729:	  1348	51 CD			ACALL	ALN		;TOS = LN(BASE)
 4730:	  134A	31 BD		AEXP1:	ACALL	AMUL		;TOS = FRACTIONS * LN(BASE)
 4731:	  134C	91 3D			ACALL	PLNEXP		;TOS = EXP(1)
 4732:	  134E	91 67			ACALL	SWAP_ASTKA	;TOS = FRACTIONS * LN(BASE)
 4733:	  1350	51 6E			ACALL	EBIAS		;T2 = FRACTIONS, TOS = INT MULTIPLIED
 4734:	  1352	75 46 00		MOV	MT2,#00H	;NOW CALCULATE E**X
 4735:	  1355	91 50			ACALL	PUSH_ONE
 4736:	  1357	91 39			ACALL	CSTAKA
 4737:	  1359	91 55			ACALL	POP_T1		;T1 = 1
 4738:					;
 4739:	  135B	91 63		AEXL:	ACALL	P_T2		;TOS = FRACTIONS
 4740:	  135D	31 BD			ACALL	AMUL		;TOS = FRACTIONS * ACCUMLATION
 4741:	  135F	05 46			INC	MT2		;DO THE DEMONIATOR
 4742:	  1361	E5 46			MOV	A,MT2
 4743:	  1363	91 BE			ACALL	TWO_R2
 4744:	  1365	91 17			ACALL	ADIV
 4745:	  1367	91 39			ACALL	CSTAKA		;SAVE THE ITERATION
 4746:	  1369	91 5C			ACALL	PUSH_T1 	;NOW ACCUMLATE
 4747:	  136B	F1 4E			ACALL	AADD		;ADD ACCUMLATION
 4748:	  136D	71 29			ACALL	TEMP_COMP
 4749:	  136F	30 D5 E9		JNB	F0,AEXL 	;LOOP UNTIL DONE
 4750:					;
 4751:	  1372	51 5C			ACALL	INC_ASTKA
 4752:	  1374	91 5C			ACALL	PUSH_T1
 4753:	  1376	31 BD			ACALL	AMUL		;LAST INT MULTIPLIED
 4754:					;
 4755:	  1378	21 BD		MU1:	AJMP	AMUL		;FIRST INT MULTIPLIED
 4756:					;
 4757:					;***************************************************************
 4758:					;
 4759:					; integer operator - INT
 4760:					;
 4761:					;***************************************************************
 4762:					;
 4763:	  137A	51 60		AINT:	ACALL	SETREG		;SET UP THE REGISTERS, CLEAR CARRY
 4764:	  137C	94 81			SUBB	A,#129		;SUBTRACT EXPONENT BIAS
 4765:	  137E	50 07			JNC	AI1		;JUMP IF ACC > 81H
 4766:					;
 4767:					; Force the number to be a zero
 4768:					;
 4769:	  1380	51 5C			ACALL	INC_ASTKA	;BUMP THE STACK
 4770:					;
 4771:	  1382	90 04 EA	P_Z:	MOV	DPTR,#ZRO	;PUT ZERO ON THE STACK
 4772:	  1385	81 40			AJMP	PUSHC
 4773:					;
 4774:	  1387	94 07		AI1:	SUBB	A,#7
 4775:	  1389	50 10			JNC	AI3
 4776:	  138B	F4			CPL	A
 4777:	  138C	04			INC	A
 4778:	  138D	FB			MOV	R3,A
 4779:	  138E	18		AI11:	DEC	R0		;POINT AT SIGN
 4780:					;
 4781:	  138F	18		AI2:	DEC	R0		;NOW AT LSB'S
 4782:	  1390	E2			MOVX	A,@R0		;READ BYTE
 4783:	  1391	54 F0			ANL	A,#0F0H 	;STRIP NIBBLE
 4784:	  1393	F2			MOVX	@R0,A		;WRITE BYTE
 4785:	  1394	DB 01			DJNZ	R3,AI21
 4786:	  1396	22			RET
 4787:	  1397	E4		AI21:	CLR	A
 4788:	  1398	F2			MOVX	@R0,A		;CLEAR THE LOCATION
 4789:	  1399	DB F4			DJNZ	R3,AI2
 4790:					;
 4791:	  139B	22		AI3:	RET			;EXIT
 4792:					;
 4793:					;***************************************************************
 4794:					;
 4795:	  139C			AABS:	; Absolute value - Make sign of number positive
 4796:					;		   return sign in ACC
 4797:					;
 4798:					;***************************************************************
 4799:					;
 4800:	  139C	71 AE			ACALL	ANEG		;CHECK TO SEE IF + OR -
 4801:	  139E	70 19			JNZ	ALPAR		;EXIT IF NON ZERO, BECAUSE THE NUM IS
 4802:	  13A0	F2			MOVX	@R0,A		;MAKE A POSITIVE SIGN
 4803:	  13A1	22			RET
 4804:					;
 4805:					;***************************************************************
 4806:					;
 4807:	  13A2			ASGN:	; Returns the sign of the number 1 = +, -1 = -
 4808:					;
 4809:					;***************************************************************
 4810:					;
 4811:	  13A2	51 5C			ACALL	INC_ASTKA	;POP STACK, GET EXPONENT
 4812:	  13A4	60 DC			JZ	P_Z		;EXIT IF ZERO
 4813:	  13A6	18			DEC	R0		;BUMP TO SIGN
 4814:	  13A7	E2			MOVX	A,@R0		;GET THE SIGN
 4815:	  13A8	FF			MOV	R7,A		;SAVE THE SIGN
 4816:	  13A9	91 50			ACALL	PUSH_ONE	;PUT A ONE ON THE STACK
 4817:	  13AB	EF			MOV	A,R7		;GET THE SIGN
 4818:	  13AC	60 0B			JZ	ALPAR		;EXIT IF ZERO
 4819:					;
 4820:					; Fall thru to ANEG
 4821:					;
 4822:					;***************************************************************
 4823:					;
 4824:	  13AE			ANEG:	; Flip the sign of the number on the tos
 4825:					;
 4826:					;***************************************************************
 4827:					;
 4828:	  13AE	51 60			ACALL	SETREG
 4829:	  13B0	18			DEC	R0		;POINT AT THE SIGN OF THE NUMBER
 4830:	  13B1	60 06			JZ	ALPAR		;EXIT IF ZERO
 4831:	  13B3	E2			MOVX	A,@R0
 4832:	  13B4	64 01			XRL	A,#01H		;FLIP THE SIGN
 4833:	  13B6	F2			MOVX	@R0,A
 4834:	  13B7	64 01			XRL	A,#01H		;RESTORE THE SIGN
 4835:					;
 4836:	  13B9	22		ALPAR:	RET
 4837:					;
 4838:					;***************************************************************
 4839:					;
 4840:	  13BA			ACBYTE: ; Read the ROM
 4841:					;
 4842:					;***************************************************************
 4843:					;
 4844:	  13BA	51 30			ACALL	IFIX		;GET EXPRESSION
 4845:	  13BC	12 05 83		CALL	X31DP		;PUT R3:R1 INTO THE DP
 4846:	  13BF	E4			CLR	A
 4847:	  13C0	93			MOVC	A,@A+DPTR
 4848:	  13C1	81 BE			AJMP	TWO_R2
 4849:					;
 4850:					;***************************************************************
 4851:					;
 4852:	  13C3			ADBYTE: ; Read internal memory
 4853:					;
 4854:					;***************************************************************
 4855:					;
 4856:	  13C3	51 30			ACALL	IFIX		;GET THE EXPRESSION
 4857:	  13C5	12 09 DF		CALL	R3CK		;MAKE SURE R3 = 0
 4858:	  13C8	E7			MOV	A,@R1
 4859:	  13C9	81 BE			AJMP	TWO_R2
 4860:					;
 4861:					;***************************************************************
 4862:					;
 4863:	  13CB			AXBYTE: ; Read external memory
 4864:					;
 4865:					;***************************************************************
 4866:					;
 4867:	  13CB	51 30			ACALL	IFIX		;GET THE EXPRESSION
 4868:	  13CD	8B A0		AXBYTE1:MOV	P2,R3
 4869:	  13CF	E3			MOVX	A,@R1
 4870:	  13D0	81 BE			AJMP	TWO_R2
 4871:					;
 4872:					;***************************************************************
 4873:					;
 4874:					; The relational operators - EQUAL			  (=)
 4875:					;			     GREATER THAN		  (>)
 4876:					;			     LESS THAN			  (<)
 4877:					;			     GREATER THAN OR EQUAL	  (>=)
 4878:					;			     LESS THAN OR EQUAL 	  (<=)
 4879:					;			     NOT EQUAL			  (<>)
 4880:					;
 4881:					;***************************************************************
 4882:					;
 4883:	  13D2	51 15		AGT:	ACALL	CMPLK
 4884:	  13D4	72 D5			ORL	C,F0		;SEE IF EITHER IS A ONE
 4885:	  13D6	40 AA		AGT1:	JC	P_Z
 4886:					;
 4887:	  13D8	90 13 DD	FSTK:	MOV	DPTR,#FS
 4888:	  13DB	81 40			AJMP	PUSHC
 4889:					;
 4890:	  13DD	85		FS:	DB	85H
 4891:	  13DE	00			DB	00H
 4892:	  13DF	00			DB	00H
 4893:	  13E0	50			DB	50H
 4894:	  13E1	53			DB	53H
 4895:	  13E2	65			DB	65H
 4896:					;
 4897:	  13E3	51 15		ALT:	ACALL	CMPLK
 4898:	  13E5	B3		ALT1:	CPL	C
 4899:	  13E6	80 EE			SJMP	AGT1
 4900:					;
 4901:	  13E8	51 15		AEQ:	ACALL	CMPLK
 4902:	  13EA	A2 D5		AEQ1:	MOV	C,F0
 4903:	  13EC	80 F7			SJMP	ALT1
 4904:					;
 4905:	  13EE	51 15		ANE:	ACALL	CMPLK
 4906:	  13F0	B2 D5			CPL	F0
 4907:	  13F2	80 F6			SJMP	AEQ1
 4908:					;
 4909:	  13F4	51 15		AGE:	ACALL	CMPLK
 4910:	  13F6	80 DE			SJMP	AGT1
 4911:					;
 4912:	  13F8	51 15		ALE:	ACALL	CMPLK
 4913:	  13FA	72 D5			ORL	C,F0
 4914:	  13FC	80 E7			SJMP	ALT1
 4915:					;
 4916:					;***************************************************************
 4917:					;
 4918:	  13FE			ARND:	; Generate a random number
 4919:					;
 4920:					;***************************************************************
 4921:					;
 4922:	  13FE	90 01 0C		MOV	DPTR,#RCELL	;GET THE BINARY SEED
 4923:	  1401	12 05 C4		CALL	L31DPI
 4924:	  1404	E9			MOV	A,R1
 4925:	  1405	C3			CLR	C
 4926:	  1406	13			RRC	A
 4927:	  1407	F8			MOV	R0,A
 4928:	  1408	74 06			MOV	A,#6
 4929:	  140A	13			RRC	A
 4930:	  140B	29			ADD	A,R1
 4931:	  140C	C8			XCH	A,R0
 4932:	  140D	3B			ADDC	A,R3
 4933:	  140E	FA			MOV	R2,A
 4934:	  140F	15 82			DEC	DPL		;SAVE THE NEW SEED
 4935:	  1411	91 31			ACALL	S20DP
 4936:	  1413	91 C1			ACALL	TWO_EY
 4937:	  1415	71 D8			ACALL	FSTK
 4938:					;
 4939:	  1417	12 19 84	ADIV:	LCALL	FP_BASE4
 4940:	  141A	01 45			AJMP	FPTST
 4941:					;
 4942:					;***************************************************************
 4943:					;
 4944:	  141C			SONERR: ; ON ERROR Statement
 4945:					;
 4946:					;***************************************************************
 4947:					;
 4948:	  141C	12 0F 3B		LCALL	INTERR		;GET THE LINE NUMBER
 4949:	  141F	D2 13			SETB	ON_ERR
 4950:	  1421	90 01 02		MOV	DPTR,#ERRNUM	;POINT AT THR ERROR LOCATION
 4951:	  1424	80 0B			SJMP	S20DP
 4952:					;
 4953:					;
 4954:					;**************************************************************
 4955:					;
 4956:	  1426			SONEXT: ; ON EXT1 Statement
 4957:					;
 4958:					;**************************************************************
 4959:					;
 4960:	  1426	12 0F 3B		LCALL	INTERR
 4961:	  1429	D2 12			SETB	INTBIT
 4962:	  142B	43 A8 84		ORL	IE,#10000100B	;ENABLE INTERRUPTS
 4963:	  142E	90 01 20		MOV	DPTR,#INTLOC
 4964:					;
 4965:	  1431	EA		S20DP:	MOV	A,R2		;SAVE R2:R0 @DPTR
 4966:	  1432	F0			MOVX	@DPTR,A
 4967:	  1433	A3			INC	DPTR
 4968:	  1434	E8			MOV	A,R0
 4969:	  1435	F0			MOVX	@DPTR,A
 4970:	  1436	22			RET
 4971:					;
 4972:					;***************************************************************
 4973:					;
 4974:					; CASTAK - Copy and push another top of arg stack
 4975:					;
 4976:					;***************************************************************
 4977:					;
 4978:	  1437	91 39		CSTAKA2:ACALL	CSTAKA		;COPY STACK TWICE
 4979:					;
 4980:	  1439	51 60		CSTAKA: ACALL	SETREG		;SET UP R2:R0
 4981:	  143B	80 23			SJMP	PUSH_T12
 4982:					;
 4983:	  143D	90 18 05	PLNEXP: MOV	DPTR,#EXP1
 4984:					;
 4985:					;***************************************************************
 4986:					;
 4987:					; PUSHC - Push constant on to the arg stack
 4988:					;
 4989:					;***************************************************************
 4990:					;
 4991:	  1440	51 18		PUSHC:	ACALL	DEC_ASTKA
 4992:	  1442	8B A0			MOV	P2,R3
 4993:	  1444	7B 06			MOV	R3,#FPSIZ	;LOOP COUNTER
 4994:					;
 4995:	  1446	E4		PCL:	CLR	A		;SET UP A
 4996:	  1447	93			MOVC	A,@A+DPTR	;LOAD IT
 4997:	  1448	F3			MOVX	@R1,A		;SAVE IT
 4998:	  1449	A3			INC	DPTR		;BUMP POINTERS
 4999:	  144A	19			DEC	R1
 5000:	  144B	DB F9			DJNZ	R3,PCL		;LOOP
 5001:					;
 5002:	  144D	D2 24			SETB	ARGF
 5003:	  144F	22			RET			;EXIT
 5004:					;
 5005:	  1450			PUSH_ONE:;
 5006:					;
 5007:	  1450	90 16 FF		MOV	DPTR,#FPONE
 5008:	  1453	81 40			AJMP	PUSHC
 5009:					;
 5010:	  1455			POP_T1:
 5011:					;
 5012:	  1455	7B 01			MOV	R3,#HIGH FPT1
 5013:	  1457	79 19			MOV	R1,#LOW FPT1
 5014:	  1459	02 0F DE		JMP	POPAS
 5015:					;
 5016:	  145C			PUSH_T1:
 5017:					;
 5018:	  145C	78 19			MOV	R0,#LOW FPT1
 5019:	  145E			PUSH_T11:
 5020:	  145E	7A 01			MOV	R2,#HIGH FPT1
 5021:	  1460			PUSH_T12:
 5022:	  1460	02 0F E8		LJMP	PUSHAS
 5023:					;
 5024:	  1463	78 1F		P_T2:	MOV	R0,#LOW FPT2
 5025:	  1465	80 F7			SJMP	PUSH_T11		;JUMP TO PUSHAS
 5026:					;
 5027:					;****************************************************************
 5028:					;
 5029:	  1467			SWAP_ASTKA:	; SWAP TOS<>TOS-1
 5030:					;
 5031:					;****************************************************************
 5032:					;
 5033:	  1467	51 60			ACALL	SETREG		;SET UP R2:R0 AND P2
 5034:	  1469	74 06			MOV	A,#FPSIZ	;PUT TOS+1 IN R1
 5035:	  146B	FA			MOV	R2,A
 5036:	  146C	28			ADD	A,R0
 5037:	  146D	F9			MOV	R1,A
 5038:					;
 5039:	  146E	E2		S_L:	MOVX	A,@R0
 5040:	  146F	FB			MOV	R3,A
 5041:	  1470	E3			MOVX	A,@R1
 5042:	  1471	F2			MOVX	@R0,A
 5043:	  1472	EB			MOV	A,R3
 5044:	  1473	F3			MOVX	@R1,A
 5045:	  1474	19			DEC	R1
 5046:	  1475	18			DEC	R0
 5047:	  1476	DA F6			DJNZ	R2,S_L
 5048:	  1478	22			RET
 5049:					;
 5050:	  1479	51 60		C2_T2:	ACALL	SETREG		;SET UP R2:R0
 5051:	  147B	7B 01			MOV	R3,#HIGH FPT2
 5052:	  147D	79 1F			MOV	R1,#LOW FPT2	;TEMP VALUE
 5053:					;
 5054:					; Fall thru
 5055:					;
 5056:					;***************************************************************
 5057:					;
 5058:					; VARCOP - Copy a variable from R2:R0 to R3:R1
 5059:					;
 5060:					;***************************************************************
 5061:					;
 5062:	  147F	7C 06		VARCOP: MOV	R4,#FPSIZ	;LOAD THE LOOP COUNTER
 5063:					;
 5064:	  1481	8A A0		V_C:	MOV	P2,R2		;SET UP THE PORTS
 5065:	  1483	E2			MOVX	A,@R0		;READ THE VALUE
 5066:	  1484	8B A0			MOV	P2,R3		;PORT TIME AGAIN
 5067:	  1486	F3			MOVX	@R1,A		;SAVE IT
 5068:	  1487	B1 98			ACALL	DEC3210 	;BUMP POINTERS
 5069:	  1489	DC F6			DJNZ	R4,V_C		;LOOP
 5070:	  148B	22			RET			;EXIT
 5071:					;
 5072:	  148C	90 18 0B	PIPI:	MOV	DPTR,#PIE
 5073:	  148F	81 40			AJMP	PUSHC
 5074:					;
 5075:					;***************************************************************
 5076:					;
 5077:					; The logical operators ANL, ORL, XRL, NOT
 5078:					;
 5079:					;***************************************************************
 5080:					;
 5081:	  1491	91 AE		AANL:	ACALL	TWOL		;GET THE EXPRESSIONS
 5082:	  1493	EB			MOV	A,R3		;DO THE AND
 5083:	  1494	5F			ANL	A,R7
 5084:	  1495	FA			MOV	R2,A
 5085:	  1496	E9			MOV	A,R1
 5086:	  1497	5E			ANL	A,R6
 5087:	  1498	80 26			SJMP	TWO_EX
 5088:					;
 5089:	  149A	91 AE		AORL:	ACALL	TWOL		;SAME THING FOR OR
 5090:	  149C	EB			MOV	A,R3
 5091:	  149D	4F			ORL	A,R7
 5092:	  149E	FA			MOV	R2,A
 5093:	  149F	E9			MOV	A,R1
 5094:	  14A0	4E			ORL	A,R6
 5095:	  14A1	80 1D			SJMP	TWO_EX
 5096:					;
 5097:	  14A3	71 D8		ANOT:	ACALL	FSTK		;PUT 0FFFFH ON THE STACK
 5098:					;
 5099:	  14A5	91 AE		AXRL:	ACALL	TWOL
 5100:	  14A7	EB			MOV	A,R3
 5101:	  14A8	6F			XRL	A,R7
 5102:	  14A9	FA			MOV	R2,A
 5103:	  14AA	E9			MOV	A,R1
 5104:	  14AB	6E			XRL	A,R6
 5105:	  14AC	80 12			SJMP	TWO_EX
 5106:					;
 5107:	  14AE	51 30		TWOL:	ACALL	IFIX
 5108:	  14B0	AF 03			MOV	R7,R3B0
 5109:	  14B2	AE 01			MOV	R6,R1B0
 5110:	  14B4	41 30			AJMP	IFIX
 5111:					;
 5112:					;*************************************************************
 5113:					;
 5114:	  14B6			AGET:	; READ THE BREAK BYTE AND PUT IT ON THE ARG STACK
 5115:					;
 5116:					;*************************************************************
 5117:					;
 5118:	  14B6	90 01 00		MOV	DPTR,#GTB	;GET THE BREAK BYTE
 5119:	  14B9	E0			MOVX	A,@DPTR
 5120:	  14BA	10 18 01		JBC	GTRD,TWO_R2
 5121:	  14BD	E4			CLR	A
 5122:					;
 5123:	  14BE	7A 00		TWO_R2: MOV	R2,#00H 	;ACC GOES TO STACK
 5124:					;
 5125:					;
 5126:	  14C0	F8		TWO_EX: MOV	R0,A		;R2:ACC GOES TO STACK
 5127:					;
 5128:					;
 5129:	  14C1	D2 24		TWO_EY: SETB	ARGF		;R2:R0 GETS PUT ON THE STACK
 5130:	  14C3	02 19 94		JMP	FP_BASE12	;DO IT
 5131:					;
 5132:					;*************************************************************
 5133:					;
 5134:					; Put directs onto the stack
 5135:					;
 5136:					;**************************************************************
 5137:					;
 5138:	  14C6	E5 A8		A_IE:	MOV	A,IE		;IE
 5139:	  14C8	80 F4			SJMP	TWO_R2
 5140:					;
 5141:	  14CA	E5 B8		A_IP:	MOV	A,IP		;IP
 5142:	  14CC	80 F0			SJMP	TWO_R2
 5143:					;
 5144:	  14CE	AA 8C		ATIM0:	MOV	R2,TH0		;TIMER 0
 5145:	  14D0	A8 8A			MOV	R0,TL0
 5146:	  14D2	80 ED			SJMP	TWO_EY
 5147:					;
 5148:	  14D4	AA 8D		ATIM1:	MOV	R2,TH1		;TIMER 1
 5149:	  14D6	A8 8B			MOV	R0,TL1
 5150:	  14D8	80 E7			SJMP	TWO_EY
 5151:					;
 5152:	  14DA	AA CD		ATIM2:	MOV	R2,TH2
 5153:	  14DC	A8 CC			MOV	R0,TL2
 5154:				;	DB	0AAH		;MOV R2 DIRECT OP CODE
 5155:				;	DB	0CDH		;T2 HIGH
 5156:				;	DB	0A8H		;MOV R0 DIRECT OP CODE
 5157:				;	DB	0CCH		;T2 LOW
 5158:	  14DE	80 E1			SJMP	TWO_EY		;TIMER 2
 5159:					;
 5160:	  14E0	E5 C8		AT2CON: MOV	A,T2CON
 5161:				;	DB	0E5H		;MOV A,DIRECT OPCODE
 5162:				;	DB	0C8H		;T2CON LOCATION
 5163:	  14E2	80 DA			SJMP	TWO_R2
 5164:					;
 5165:	  14E4	E5 88		ATCON:	MOV	A,TCON		;TCON
 5166:	  14E6	80 D6			SJMP	TWO_R2
 5167:					;
 5168:	  14E8	E5 89		ATMOD:	MOV	A,TMOD		;TMOD
 5169:	  14EA	80 D2			SJMP	TWO_R2
 5170:					;
 5171:	  14EC	AA CB		ARCAP2: MOV	R2,RCAPH2
 5172:	  14EE	A8 CA			MOV	R0,RCAPL2
 5173:				;	DB	0AAH		;MOV R2, DIRECT OP CODE
 5174:				;	DB	0CBH		;RCAP2H LOCATION
 5175:				;	DB	0A8H		;MOV R0, DIRECT OP CODE
 5176:				;	DB	0CAH		;R2CAPL LOCATION
 5177:	  14F0	80 CF			SJMP	TWO_EY
 5178:					;
 5179:	  14F2	E5 90		AP1:	MOV	A,P1		;GET P1
 5180:	  14F4	80 C8			SJMP	TWO_R2		;PUT IT ON THE STACK
 5181:					;
 5182:	  14F6	E5 87		APCON:	MOV	A,PCON
 5183:				;	DB	0E5H		;MOV A, DIRECT OP CODE
 5184:				;	DB	87H		;ADDRESS OF PCON
 5185:	  14F8	80 C4			SJMP	TWO_R2		;PUT PCON ON THE STACK
 5186:					;
 5187:					;***************************************************************
 5188:					;
 5189:					;THIS IS THE LINE EDITOR
 5190:					;
 5191:					;TAKE THE PROCESSED LINE IN IBUF AND INSERT IT INTO THE
 5192:					;BASIC TEXT FILE.
 5193:					;
 5194:					;***************************************************************
 5195:					;
 5196:	  14FA	02 05 78	LINE0:	LJMP	NOGO		;CAN'T EDIT A ROM
 5197:					;
 5198:	  14FD	E5 13		LINE:	MOV	A,BOFAH
 5199:	  14FF	B4 02 F8		CJNE	A,#HIGH PSTART,LINE0
 5200:	  1502	12 05 B3		CALL	G4		;GET END ADDRESS FOR EDITING
 5201:	  1505	AC 82			MOV	R4,DPL
 5202:	  1507	AD 83			MOV	R5,DPH
 5203:	  1509	AB 0F			MOV	R3,TEMP5	;GET HIGH ORDER IBLN
 5204:	  150B	A9 0E			MOV	R1,TEMP4	;LOW ORDER IBLN
 5205:					;
 5206:	  150D	12 05 96		CALL	GETLIN		;FIND THE LINE
 5207:	  1510	70 12			JNZ	INSR		;INSERT IF NOT ZERO, ELSE APPEND
 5208:					;
 5209:					;APPEND THE LINE AT THE END
 5210:					;
 5211:	  1512	E5 0D			MOV	A,TEMP3 	;PUT IBCNT IN THE ACC
 5212:	  1514	B4 04 01		CJNE	A,#4H,LINE1	;SEE IF NO ENTRY
 5213:	  1517	22			RET			;RET IF NO ENTRY
 5214:					;
 5215:	  1518	B1 B5		LINE1:	ACALL	FULL		;SEE IF ENOUGH SPACE LEFT
 5216:	  151A	AA 05			MOV	R2,R5B0 	;PUT END ADDRESS A INTO TRANSFER
 5217:	  151C	A8 04			MOV	R0,R4B0 	;REGISTERS
 5218:	  151E	B1 73			ACALL	IMOV		;DO THE BLOCK MOVE
 5219:					;
 5220:	  1520	74 01		UE:	MOV	A,#EOF		;SAVE EOF CHARACTER
 5221:	  1522	A1 A6			AJMP	TBR
 5222:					;
 5223:					;INSERT A LINE INTO THE FILE
 5224:					;
 5225:	  1524	FF		INSR:	MOV	R7,A		;SAVE IT IN R7
 5226:	  1525	12 18 61		CALL	TEMPD		;SAVE INSERATION ADDRESS
 5227:	  1528	E5 0D			MOV	A,TEMP3 	;PUT THE COUNT LENGTH IN THE ACC
 5228:	  152A	40 09			JC	LTX		;JUMP IF NEW LINE # NOT = OLD LINE #
 5229:	  152C	B4 04 01		CJNE	A,#04H,INSR1	;SEE IF NULL
 5230:	  152F	E4			CLR	A
 5231:					;
 5232:	  1530	9F		INSR1:	SUBB	A,R7		;SUBTRACT LINE COUNT FROM ACC
 5233:	  1531	60 36			JZ	LIN1		;LINE LENGTHS EQUAL
 5234:	  1533	40 1F			JC	GTX		;SMALLER LINE
 5235:					;
 5236:					;EXPAND FOR A NEW LINE OR A LARGER LINE
 5237:					;
 5238:	  1535	FF		LTX:	MOV	R7,A		;SAVE A IN R7
 5239:	  1536	E5 0D			MOV	A,TEMP3 	;GET THE COUNT IN THE ACC
 5240:	  1538	B4 04 01		CJNE	A,#04H,LTX1	;DO NO INSERTATION IF NULL LINE
 5241:	  153B	22			RET			;EXIT IF IT IS
 5242:					;
 5243:	  153C	EF		LTX1:	MOV	A,R7		;GET THE COUNT BACK - DELTA IN A
 5244:	  153D	B1 B5			ACALL	FULL		;SEE IF ENOUGH MEMORY NEW EOFA IN R3:R1
 5245:	  153F	12 18 5A		CALL	DTEMP		;GET INSERATION ADDRESS
 5246:	  1542	B1 AA			ACALL	NMOV		;R7:R6 GETS (EOFA)-DPTR
 5247:	  1544	12 0D B8		CALL	X3120
 5248:	  1547	A9 04			MOV	R1,R4B0 	;EOFA LOW
 5249:	  1549	AB 05			MOV	R3,R5B0 	;EOFA HIGH
 5250:	  154B	0E			INC	R6		;INCREMENT BYTE COUNT
 5251:	  154C	BE 00 01		CJNE	R6,#00,LTX2	;NEED TO BUMP HIGH BYTE?
 5252:	  154F	0F			INC	R7
 5253:					;
 5254:	  1550	B1 8E		LTX2:	ACALL	RMOV		;GO DO THE INSERTION
 5255:	  1552	80 15			SJMP	LIN1		;INSERT THE CURRENT LINE
 5256:					;
 5257:	  1554	F4		GTX:	CPL	A		;FLIP ACC
 5258:	  1555	04			INC	A		;TWOS COMPLEMENT
 5259:	  1556	12 05 E8		CALL	ADDPTR		;DO THE ADDITION
 5260:	  1559	B1 AA			ACALL	NMOV		;R7:R6 GETS (EOFA)-DPTR
 5261:	  155B	A9 82			MOV	R1,DPL		;SET UP THE REGISTERS
 5262:	  155D	AB 83			MOV	R3,DPH
 5263:	  155F	AA 0F			MOV	R2,TEMP5	;PUT INSERTATION ADDRESS IN THE RIGHT REG
 5264:	  1561	A8 0E			MOV	R0,TEMP4
 5265:	  1563	60 02			JZ	GTX1		;IF ACC WAS ZERO FROM NMOV, JUMP
 5266:	  1565	B1 7A			ACALL	LMOV		;IF NO ZERO DO A LMOV
 5267:					;
 5268:	  1567	B1 20		GTX1:	ACALL	UE		;SAVE NEW END ADDRESS
 5269:					;
 5270:	  1569	AA 0F		LIN1:	MOV	R2,TEMP5	;GET THE INSERTATION ADDRESS
 5271:	  156B	A8 0E			MOV	R0,TEMP4
 5272:	  156D	E5 0D			MOV	A,TEMP3 	;PUT THE COUNT LENGTH IN ACC
 5273:	  156F	B4 04 01		CJNE	A,#04H,IMOV	;SEE IF NULL
 5274:	  1572	22			RET			;EXIT IF NULL
 5275:					;
 5276:					;***************************************************************
 5277:					;
 5278:					;INSERT A LINE AT ADDRESS R2:R0
 5279:					;
 5280:					;***************************************************************
 5281:					;
 5282:	  1573	E4		IMOV:	CLR	A		;TO SET UP
 5283:	  1574	79 04			MOV	R1,#LOW IBCNT	;INITIALIZE THE REGISTERS
 5284:	  1576	FB			MOV	R3,A
 5285:	  1577	AE 0D			MOV	R6,TEMP3	;PUT THE BYTE COUNT IN R6 FOR LMOV
 5286:	  1579	FF			MOV	R7,A		;PUT A 0 IN R7 FOR LMOV
 5287:					;
 5288:					;***************************************************************
 5289:					;
 5290:					;COPY A BLOCK FROM THE BEGINNING
 5291:					;
 5292:					;R2:R0 IS THE DESTINATION ADDRESS
 5293:					;R3:R1 IS THE SOURCE ADDRESS
 5294:					;R7:R6 IS THE COUNT REGISTER
 5295:					;
 5296:					;***************************************************************
 5297:					;
 5298:	  157A	B1 A3		LMOV:	ACALL	TBYTE		;TRANSFER THE BYTE
 5299:	  157C	B1 83			ACALL	INC3210 	;BUMP THE POINTER
 5300:	  157E	D1 54			ACALL	DEC76		;BUMP R7:R6
 5301:	  1580	70 F8			JNZ	LMOV		;LOOP
 5302:	  1582	22			RET			;GO BACK TO CALLING ROUTINE
 5303:					;
 5304:	  1583	08		INC3210:INC	R0
 5305:	  1584	B8 00 01		CJNE	R0,#00H,INC3211
 5306:	  1587	0A			INC	R2
 5307:					;
 5308:	  1588	09		INC3211:INC	R1
 5309:	  1589	B9 00 01		CJNE	R1,#00H,INC3212
 5310:	  158C	0B			INC	R3
 5311:	  158D	22		INC3212:RET
 5312:					;
 5313:					;***************************************************************
 5314:					;
 5315:					;COPY A BLOCK STARTING AT THE END
 5316:					;
 5317:					;R2:R0 IS THE DESTINATION ADDRESS
 5318:					;R3:R1 IS THE SOURCE ADDRESS
 5319:					;R6:R7 IS THE COUNT REGISTER
 5320:					;
 5321:					;***************************************************************
 5322:					;
 5323:	  158E	B1 A3		RMOV:	ACALL	TBYTE		;TRANSFER THE BYTE
 5324:	  1590	B1 98			ACALL	DEC3210 	;DEC THE LOCATIONS
 5325:	  1592	D1 54			ACALL	DEC76		;BUMP THE COUNTER
 5326:	  1594	70 F8			JNZ	RMOV		;LOOP
 5327:					;
 5328:	  1596	00		DEC_R:	NOP			;CREATE EQUAL TIMING
 5329:	  1597	22			RET			;EXIT
 5330:					;
 5331:	  1598	18		DEC3210:DEC	R0		;BUMP THE POINTER
 5332:	  1599	B8 FF 01		CJNE	R0,#0FFH,DEC3212;SEE IF OVERFLOWED
 5333:	  159C	1A		DEC3211:DEC	R2		;BUMP THE HIGH BYTE
 5334:	  159D	19		DEC3212:DEC	R1		;BUMP THE POINTER
 5335:	  159E	B9 FF F5		CJNE	R1,#0FFH,DEC_R	;SEE IF OVERFLOWED
 5336:	  15A1	1B			DEC	R3		;CHANGE THE HIGH BYTE
 5337:	  15A2	22			RET			;EXIT
 5338:					;
 5339:					;***************************************************************
 5340:					;
 5341:					;TBYTE - TRANSFER A BYTE
 5342:					;
 5343:					;***************************************************************
 5344:					;
 5345:	  15A3	8B A0		TBYTE:	MOV	P2,R3		;OUTPUT SOURCE REGISTER TO PORT
 5346:	  15A5	E3			MOVX	A,@R1		;PUT BYTE IN ACC
 5347:					;
 5348:	  15A6	8A A0		TBR:	MOV	P2,R2		;OUTPUT DESTINATION TO PORT
 5349:	  15A8	F2			MOVX	@R0,A		;SAVE THE BYTE
 5350:	  15A9	22			RET			;EXIT
 5351:					;
 5352:					;***************************************************************
 5353:					;
 5354:					;NMOV - R7:R6 = END ADDRESS - DPTR
 5355:					;
 5356:					;ACC GETS CLOBBERED
 5357:					;
 5358:					;***************************************************************
 5359:					;
 5360:	  15AA	EC		NMOV:	MOV	A,R4		;THE LOW BYTE OF EOFA
 5361:	  15AB	C3			CLR	C		;CLEAR THE CARRY FOR SUBB
 5362:	  15AC	95 82			SUBB	A,DPL		;SUBTRACT DATA POINTER LOW
 5363:	  15AE	FE			MOV	R6,A		;PUT RESULT IN R6
 5364:	  15AF	ED			MOV	A,R5		;HIGH BYTE OF EOFA
 5365:	  15B0	95 83			SUBB	A,DPH		;SUBTRACT DATA POINTER HIGH
 5366:	  15B2	FF			MOV	R7,A		;PUT RESULT IN R7
 5367:	  15B3	4E			ORL	A,R6		;SEE IF ZERO
 5368:	  15B4	22		NMOV1:	RET			;EXIT
 5369:					;
 5370:					;***************************************************************
 5371:					;
 5372:					;CHECK FOR A FILE OVERFLOW
 5373:					;LEAVES THE NEW END ADDRESS IN R3:R1
 5374:					;A HAS THE INCREASE IN SIZE
 5375:					;
 5376:					;***************************************************************
 5377:					;
 5378:	  15B5	2C		FULL:	ADD	A,R4		;ADD A TO END ADDRESS
 5379:	  15B6	F9			MOV	R1,A		;SAVE IT
 5380:	  15B7	E4			CLR	A
 5381:	  15B8	3D			ADDC	A,R5		;ADD THE CARRY
 5382:	  15B9	FB			MOV	R3,A
 5383:	  15BA	90 01 04		MOV	DPTR,#VARTOP	;POINT AT VARTOP
 5384:					;
 5385:	  15BD	12 05 D6	FUL1:	CALL	DCMPX		;COMPARE THE TWO
 5386:	  15C0	40 F2			JC	NMOV1		;OUT OF ROOM
 5387:					;
 5388:	  15C2	90 18 23	TB:	MOV	DPTR,#E5X	;OUT OF MEMORY
 5389:	  15C5	01 58			AJMP	FPTS
 5390:					;
 5391:					;***************************************************************
 5392:					;
 5393:					; PP - Preprocesses the line in IBUF back into IBUF
 5394:					;      sets F0 if no line number
 5395:					;      leaves the correct length of processed line in IBCNT
 5396:					;      puts the line number in IBLN
 5397:					;      wastes the text address TXAL and TXAH
 5398:					;
 5399:					;***************************************************************
 5400:					;
 5401:	  15C7	F1 79		PP:	ACALL	T_BUF		;TXA GETS IBUF
 5402:	  15C9	12 0F 40		CALL	INTGER		;SEE IF A NUMBER PRESENT
 5403:	  15CC	12 18 61		CALL	TEMPD		;SAVE THE INTEGER IN TEMP5:TEMP4
 5404:	  15CF	92 D5			MOV	F0,C		;SAVE INTEGER IF PRESENT
 5405:	  15D1	90 00 05		MOV	DPTR,#IBLN	;SAVE THE LINE NUMBER, EVEN IF NONE
 5406:	  15D4	91 31			ACALL	S20DP
 5407:	  15D6	A8 08			MOV	R0,TXAL 	;TEXT POINTER
 5408:	  15D8	79 07			MOV	R1,#LOW IBUF	;STORE POINTER
 5409:					;
 5410:					; Now process the line back into IBUF
 5411:					;
 5412:	  15DA	C2 24		PPL:	CLR	ARGF		;FIRST PASS DESIGNATOR
 5413:	  15DC	90 01 75		MOV	DPTR,#TOKTAB	;POINT DPTR AT LOOK UP TABLE
 5414:					;
 5415:	  15DF	88 05		PPL1:	MOV	R5B0,R0 	;SAVE THE READ POINTER
 5416:	  15E1	E4			CLR	A		;ZERO A FOR LOOKUP
 5417:	  15E2	93			MOVC	A,@A+DPTR	;GET THE TOKEN
 5418:	  15E3	FF			MOV	R7,A		;SAVE TOKEN IN CASE OF MATCH
 5419:					;
 5420:	  15E4	E2		PPL2:	MOVX	A,@R0		;GET THE USER CHARACTER
 5421:	  15E5	FB			MOV	R3,A		;SAVE FOR REM
 5422:	  15E6	B4 61 00		CJNE	A,#'a',PPL21
 5423:	  15E9	40 07		PPL21:	JC	PPX		;CONVERT LOWER TO UPPER CASE
 5424:	  15EB	B4 7B 00		CJNE	A,#('z'+1),PPL22
 5425:	  15EE	50 02		PPL22:	JNC	PPX
 5426:	  15F0	C2 E5			CLR	ACC.5
 5427:					;
 5428:	  15F2	FA		PPX:	MOV	R2,A
 5429:	  15F3	F2			MOVX	@R0,A		;SAVE UPPER CASE
 5430:	  15F4	A3			INC	DPTR		;BUMP THE LOOKUP POINTER
 5431:	  15F5	E4			CLR	A
 5432:	  15F6	93			MOVC	A,@A+DPTR
 5433:	  15F7	B5 02 03		CJNE	A,R2B0,PPL3	;LEAVE IF NOT THE SAME
 5434:	  15FA	08			INC	R0		;BUMP THE USER POINTER
 5435:	  15FB	80 E7			SJMP	PPL2		;CONTINUE TO LOOP
 5436:					;
 5437:	  15FD	20 E7 2F	PPL3:	JB	ACC.7,PPL6	;JUMP IF FOUND MATCH
 5438:	  1600	60 2D			JZ	PPL6		;USER MATCH
 5439:					;
 5440:					;
 5441:					; Scan to the next TOKTAB entry
 5442:					;
 5443:	  1602	A3		PPL4:	INC	DPTR		;ADVANCE THE POINTER
 5444:	  1603	E4			CLR	A		;ZERO A FOR LOOKUP
 5445:	  1604	93			MOVC	A,@A+DPTR	;LOAD A WITH TABLE
 5446:	  1605	20 E7 03		JB	ACC.7,PPL41	;KEEP SCANNING IF NOT A RESERVED WORD
 5447:	  1608	70 F8			JNZ	PPL4
 5448:	  160A	A3			INC	DPTR
 5449:					;
 5450:					; See if at the end of TOKTAB
 5451:					;
 5452:	  160B	A8 05		PPL41:	MOV	R0,R5B0 	;RESTORE THE POINTER
 5453:	  160D	B4 FF CF		CJNE	A,#0FFH,PPL1	;SEE IF END OF TABLE
 5454:					;
 5455:					; Character not in TOKTAB, so see what it is
 5456:					;
 5457:	  1610	BA 20 03		CJNE	R2,#' ',PPLX    ;SEE IF A SPACE
 5458:	  1613	08			INC	R0		;BUMP USER POINTER
 5459:	  1614	80 C4			SJMP	PPL		;TRY AGAIN
 5460:					;
 5461:	  1616	30 2D 0A	PPLX:	JNB	XBIT,PPLY	;EXTERNAL TRAP
 5462:	  1619	20 24 07		JB	ARGF,PPLY
 5463:	  161C	D2 24			SETB	ARGF		;SAYS THAT THE USER HAS TABLE
 5464:	  161E	12 20 78		LCALL	2078H		;SET UP POINTER
 5465:	  1621	A1 DF			AJMP	PPL1
 5466:					;
 5467:	  1623	D1 3C		PPLY:	ACALL	PPL7		;SAVE CHARACTER, EXIT IF A CR
 5468:	  1625	B4 22 B2		CJNE	A,#'"',PPL      ;SEE IF QUOTED STRING, START AGAIN IF NOT
 5469:					;
 5470:					; Just copy a quoted string
 5471:					;
 5472:	  1628	D1 3C		PPLY1:	ACALL	PPL7		;SAVE THE CHARACTER, TEST FOR CR
 5473:	  162A	B4 22 FB		CJNE	A,#'"',PPLY1    ;IS THERE AN ENDQUOTE, IF NOT LOOP
 5474:	  162D	80 AB			SJMP	PPL		;DO IT AGAIN IF ENDQUOTE
 5475:					;
 5476:	  162F	EF		PPL6:	MOV	A,R7		;GET THE TOKEN
 5477:	  1630	D1 51			ACALL	PPL91		;SAVE THE TOKEN
 5478:	  1632	B4 96 A5		CJNE	A,#T_REM,PPL	;SEE IF A REM TOKEN
 5479:	  1635	EB			MOV	A,R3
 5480:	  1636	D1 3D			ACALL	PPL71		;WASTE THE REM STATEMENT
 5481:	  1638	D1 3C		PPL61:	ACALL	PPL7		;LOOP UNTIL A CR
 5482:	  163A	80 FC			SJMP	PPL61
 5483:					;
 5484:	  163C	E2		PPL7:	MOVX	A,@R0		;GET THE CHARACTER
 5485:	  163D	B4 0D 10	PPL71:	CJNE	A,#CR,PPL9	;FINISH IF A CR
 5486:	  1640	D0 00			POP	R0B0		;WASTE THE CALLING STACK
 5487:	  1642	D0 00			POP	R0B0
 5488:	  1644	F3			MOVX	@R1,A		;SAVE CR IN MEMORY
 5489:	  1645	09			INC	R1		;SAVE A TERMINATOR
 5490:	  1646	74 01			MOV	A,#EOF
 5491:	  1648	F3			MOVX	@R1,A
 5492:	  1649	E9			MOV	A,R1		;SUBTRACT FOR LENGTH
 5493:	  164A	94 04			SUBB	A,#4
 5494:	  164C	F5 0D			MOV	TEMP3,A 	;SAVE LENGTH
 5495:	  164E	79 04			MOV	R1,#LOW IBCNT	;POINT AT BUFFER COUNT
 5496:					;
 5497:	  1650	08		PPL9:	INC	R0
 5498:	  1651	F3		PPL91:	MOVX	@R1,A		;SAVE THE CHARACTER
 5499:	  1652	09			INC	R1		;BUMP THE POINTERS
 5500:	  1653	22			RET			;EXIT TO CALLING ROUTINE
 5501:					;
 5502:					;
 5503:					;***************************************************************
 5504:					;
 5505:					;DEC76 - DECREMENT THE REGISTER PAIR R7:R6
 5506:					;
 5507:					;ACC = ZERO IF R7:R6 = ZERO ; ELSE ACC DOES NOT
 5508:					;
 5509:					;***************************************************************
 5510:					;
 5511:	  1654	1E		DEC76:	DEC	R6		;BUMP R6
 5512:	  1655	BE FF 01		CJNE	R6,#0FFH,DEC77	;SEE IF RAPPED AROUND
 5513:	  1658	1F			DEC	R7
 5514:	  1659	EF		DEC77:	MOV	A,R7		;SEE IF ZERO
 5515:	  165A	4E			ORL	A,R6
 5516:	  165B	22			RET			;EXIT
 5517:					;
 5518:					;***************************************************************
 5519:					;
 5520:					; MTOP - Get or Put the top of assigned memory
 5521:					;
 5522:					;***************************************************************
 5523:					;
 5524:	  165C	90 01 0A	PMTOP:	MOV	DPTR,#MEMTOP
 5525:	  165F	12 05 7D	PMTOP1: CALL	L20DPI
 5526:	  1662	81 C1			AJMP	TWO_EY		;PUT R2:R0 ON THE STACK
 5527:					;
 5528:					;*************************************************************
 5529:					;
 5530:					; AXTAL - Crystal value calculations
 5531:					;
 5532:					;*************************************************************
 5533:					;
 5534:	  1664	90 17 F9	AXTAL0: MOV	DPTR,#XTALV	;CRYSTAL VALUE
 5535:	  1667	91 40			ACALL	PUSHC
 5536:					;
 5537:	  1669	91 37		AXTAL1: ACALL	CSTAKA2 	;COPY CRYSTAL VALUE TWICE
 5538:				;
 5539:				;*****************************************************************************
 5540:				;****** Disable Intel programming for to get room ****************************
 5541:				;
 5542:				;	ACALL	CSTAKA		;Copy crystal value the 3rd.
 5543:				;
 5544:				;*****************************************************************************
 5545:				;
 5546:	  166B	90 07 13		MOV	DPTR,#PTIME	;PROM TIMER
 5547:	  166E	D1 86			ACALL	AXTAL2
 5548:	  1670	90 01 28		MOV	DPTR,#PROGS
 5549:	  1673	F1 1B			ACALL	S31L
 5550:				;
 5551:				;*****************************************************************************
 5552:				;****** Disable Intel programming for to get room ****************************
 5553:				;
 5554:				;	MOV	DPTR,#IPTIME	;IPROM TIMER
 5555:				;	ACALL	AXTAL2
 5556:				;	MOV	DPTR,#IPROGS
 5557:				;	ACALL	S31L
 5558:				;
 5559:				;*****************************************************************************
 5560:				;
 5561:	  1675	90 11 74		MOV	DPTR,#TTIME	;CLOCK CALCULATION
 5562:	  1678	51 2C			ACALL	AXTAL3
 5563:	  167A	E9			MOV	A,R1
 5564:	  167B	F4			CPL	A
 5565:	  167C	04			INC	A
 5566:	  167D	F5 4A			MOV	SAVE_T,A
 5567:	  167F	7B 01			MOV	R3,#HIGH CXTAL
 5568:	  1681	79 13			MOV	R1,#LOW CXTAL
 5569:	  1683	02 0F DE		JMP	POPAS
 5570:					;
 5571:	  1686	51 2C		AXTAL2: ACALL	AXTAL3
 5572:					;
 5573:	  1688			CBIAS:	;Bias the crystal calculations
 5574:					;
 5575:	  1688	E9			MOV	A,R1		;GET THE LOW COUNT
 5576:	  1689	F4			CPL	A		;FLIP IT FOR TIMER LOAD
 5577:	  168A	24 0F			ADD	A,#15		;BIAS FOR CALL AND LOAD TIMES
 5578:	  168C	F9			MOV	R1,A		;RESTORE IT
 5579:	  168D	EB			MOV	A,R3		;GET THE HIGH COUNT
 5580:	  168E	F4			CPL	A		;FLIP IT
 5581:	  168F	34 00			ADDC	A,#00H		;ADD THE CARRY
 5582:	  1691	FB			MOV	R3,A		;RESTORE IT
 5583:	  1692	22			RET
 5584:					;
 5585:					;**************************************************************
 5586:					;
 5587:	  1693			STONE:	; Toggle the I/O port
 5588:					;
 5589:					;**************************************************************
 5590:					;
 5591:	  1693	12 0E 83		CALL	THREE		;GET THE NUMBERS
 5592:	  1696	D1 88			ACALL	CBIAS		;BIAS R3:R1 FOR COUNT LOOP
 5593:					;
 5594:	  1698	C2 92		STONE1: CLR	T_BIT		;TOGGLE THE BIT
 5595:	  169A	C2 8E			CLR	TR1		;STOP THE TIMER
 5596:	  169C	8B 8D			MOV	TH1,R3		;LOAD THE TIMER
 5597:	  169E	89 8B			MOV	TL1,R1
 5598:	  16A0	C2 8F			CLR	TF1		;CLEAR THE OVERFLOW FLAG
 5599:	  16A2	D2 8E			SETB	TR1		;TURN IT ON
 5600:	  16A4	D1 54			ACALL	DEC76
 5601:	  16A6	30 8F FD		JNB	TF1,$		;WAIT
 5602:	  16A9	71 B9			ACALL	ALPAR
 5603:	  16AB	D2 92			SETB	T_BIT		;BACK TO A ONE
 5604:	  16AD	12 05 39		CALL	TIMER_LOAD1	;LOAD THE HIGH VALUE
 5605:	  16B0	30 8F FD		JNB	TF1,$		;WAIT
 5606:	  16B3	70 E3			JNZ	STONE1		;LOOP
 5607:	  16B5	22			RET
 5608:					;
 5609:					;LNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLN
 5610:					;
 5611:	  16B6			LNTAB:	; Natural log lookup table
 5612:					;
 5613:					;LNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLNLN
 5614:					;
 5615:	  16B6	80			DB	80H
 5616:	  16B7	00			DB	00H
 5617:	  16B8	71			DB	71H
 5618:	  16B9	37			DB	37H
 5619:	  16BA	13			DB	13H
 5620:	  16BB	19			DB	19H
 5621:					;
 5622:	  16BC	7F			DB	7FH
 5623:	  16BD	00			DB	00H
 5624:	  16BE	76			DB	76H
 5625:	  16BF	64			DB	64H
 5626:	  16C0	37			DB	37H
 5627:	  16C1	94			DB	94H
 5628:					;
 5629:	  16C2	80			DB	80H
 5630:	  16C3	00			DB	00H
 5631:	  16C4	07			DB	07H
 5632:	  16C5	22			DB	22H
 5633:	  16C6	75			DB	75H
 5634:	  16C7	17			DB	17H
 5635:					;
 5636:	  16C8	80			DB	80H
 5637:	  16C9	00			DB	00H
 5638:	  16CA	52			DB	52H
 5639:	  16CB	35			DB	35H
 5640:	  16CC	93			DB	93H
 5641:	  16CD	28			DB	28H
 5642:					;
 5643:	  16CE	80			DB	80H
 5644:	  16CF	00			DB	00H
 5645:	  16D0	71			DB	71H
 5646:	  16D1	91			DB	91H
 5647:	  16D2	85			DB	85H
 5648:	  16D3	86			DB	86H
 5649:					;
 5650:	  16D4	FF			DB	0FFH
 5651:					;
 5652:	  16D5	81			DB	81H
 5653:	  16D6	00			DB	00H
 5654:	  16D7	51			DB	51H
 5655:	  16D8	58			DB	58H
 5656:	  16D9	02			DB	02H
 5657:	  16DA	23			DB	23H
 5658:					;
 5659:					;SINSINSINSINSINSINSINSINSINSINSINSINSINSINSINSINSIN
 5660:					;
 5661:	  16DB			SINTAB: ; Sin lookup table
 5662:					;
 5663:					;SINSINSINSINSINSINSINSINSINSINSINSINSINSINSINSINSIN
 5664:					;
 5665:	  16DB	77			DB	128-9
 5666:	  16DC	00			DB	00H
 5667:	  16DD	44			DB	44H
 5668:	  16DE	90			DB	90H
 5669:	  16DF	05			DB	05H
 5670:	  16E0	16			DB	16H
 5671:					;
 5672:	  16E1	79			DB	128-7
 5673:	  16E2	01			DB	01H
 5674:	  16E3	08			DB	08H
 5675:	  16E4	21			DB	21H
 5676:	  16E5	05			DB	05H
 5677:	  16E6	25			DB	25H
 5678:					;
 5679:	  16E7	7B			DB	128-5
 5680:	  16E8	00			DB	00H
 5681:	  16E9	19			DB	19H
 5682:	  16EA	73			DB	73H
 5683:	  16EB	55			DB	55H
 5684:	  16EC	27			DB	27H
 5685:	  16ED	7D			DB	128-3
 5686:	  16EE	01			DB	01H
 5687:	  16EF	70			DB	70H
 5688:	  16F0	12			DB	12H
 5689:	  16F1	84			DB	84H
 5690:	  16F2	19			DB	19H
 5691:					;
 5692:	  16F3	7E			DB	128-2
 5693:	  16F4	00			DB	00H
 5694:	  16F5	33			DB	33H
 5695:	  16F6	33			DB	33H
 5696:	  16F7	33			DB	33H
 5697:	  16F8	83			DB	83H
 5698:					;
 5699:	  16F9	80			DB	128
 5700:	  16FA	01			DB	01H
 5701:	  16FB	67			DB	67H
 5702:	  16FC	66			DB	66H
 5703:	  16FD	66			DB	66H
 5704:	  16FE	16			DB	16H
 5705:					;
 5706:	  16FF	81		FPONE:	DB	128+1
 5707:	  1700	00			DB	00H
 5708:	  1701	00			DB	00H
 5709:	  1702	00			DB	00H
 5710:	  1703	00			DB	00H
 5711:	  1704	10			DB	10H
 5712:					;
 5713:	  1705	FF			DB	0FFH		;END OF TABLE
 5714:					;
 5715:	  1706	12 0F E4	SBAUD:	CALL	AXTAL		;PUT CRYSTAL ON THE STACK
 5716:	  1709	12 0F 4E		CALL	EXPRB		;PUT THE NUMBER AFTER BAUD ON STACK
 5717:	  170C	74 0C			MOV	A,#12
 5718:	  170E	91 BE			ACALL	TWO_R2		;TOS = 12
 5719:	  1710	31 BD			ACALL	AMUL		;TOS = 12*BAUD
 5720:	  1712	91 17			ACALL	ADIV		;TOS = XTAL/(12*BAUD)
 5721:	  1714	51 30			ACALL	IFIX
 5722:	  1716	D1 88			ACALL	CBIAS
 5723:	  1718	90 01 24		MOV	DPTR,#SPV
 5724:					;
 5725:	  171B	02 06 0F	S31L:	JMP	S31DP
 5726:					;
 5727:	  171E	D1 5C		AFREE:	CALL	PMTOP		;PUT MTOP ON STACK
 5728:	  1720	12 05 B3		CALL	G4		;GET END ADDRESS
 5729:	  1723	A8 82			MOV	R0,DPL
 5730:	  1725	AA 83			MOV	R2,DPH
 5731:	  1727	91 C1			ACALL	TWO_EY
 5732:					;
 5733:	  1729	12 19 7E	ASUB:	LCALL	FP_BASE1	;DO FP SUB
 5734:	  172C	01 45			AJMP	FPTST
 5735:					;
 5736:	  172E	12 05 26	ALEN:	CALL	CCAL		;CALCULATE THE LEN OF THE SELECTED PROGRAM
 5737:	  1731	AA 07			MOV	R2,R7B0 	;SAVE THE HIGH BYTE
 5738:	  1733	EE			MOV	A,R6		;SAVE THE LOW BYTE
 5739:	  1734	81 C0			AJMP	TWO_EX		;PUT IT ON THE STACK
 5740:					;
 5741:	  1736	A2 AF		ATIME:	MOV	C,EA		;SAVE INTERRUTS
 5742:	  1738	C2 AF			CLR	EA
 5743:	  173A	C0 47			PUSH	MILLIV		;SAVE MILLI VALUE
 5744:	  173C	AA 48			MOV	R2,TVH		;GET THE TIMER
 5745:	  173E	E5 49			MOV	A,TVL
 5746:	  1740	92 AF			MOV	EA,C		;SAVE INTERRUPTS
 5747:	  1742	91 C0			ACALL	TWO_EX		;PUT TIMER ON THE STACK
 5748:	  1744	D0 E0			POP	ACC		;GET MILLI
 5749:	  1746	91 BE			ACALL	TWO_R2		;PUT MILLI ON STACK
 5750:	  1748	74 C8			MOV	A,#200
 5751:	  174A	91 BE			ACALL	TWO_R2		;DIVIDE MILLI BY 200
 5752:	  174C	91 17			ACALL	ADIV
 5753:					;
 5754:	  174E	12 19 7C	AADD:	LCALL	FP_BASE 	;DO FP ADDITION
 5755:	  1751	01 45			AJMP	FPTST		;CHECK FOR ERRORS
 5756:					;
 5757:					;**************************************************************
 5758:					;
 5759:					; Here are some error messages that were moved
 5760:					;
 5761:					;**************************************************************
 5762:					;
 5763:					;
 5764:	  1753	42 41 44 20	E1X:	DB	'BAD SYNTAX"'
	  1757	53 59 4E 54
	  175B	41 58 22
 5765:	  175E	8A		E2X:	DB	128+10
 5766:	  175F	44 49 56 49		DB	'DIVIDE BY ZERO"'
	  1763	44 45 20 42
	  1767	59 20 5A 45
	  176B	52 4F 22
 5767:					;
 5768:	  176E	41 52 52 41	E6X:	DB	'ARRAY SIZE"'
	  1772	59 20 53 49
	  1776	5A 45 22
 5769:					;
 5770:					;**************************************************************
 5771:					;
 5772:	  1779			T_BUF:	; TXA gets IBUF
 5773:					;
 5774:					;**************************************************************
 5775:					;
 5776:	  1779	75 0A 00		MOV	TXAH,#HIGH IBUF
 5777:	  177C	75 08 07		MOV	TXAL,#LOW IBUF
 5778:	  177F	22			RET
 5779:					;
 5780:					;
 5781:					;***************************************************************
 5782:					;
 5783:	  1780			CXFER:	; Transfer a program from rom to ram
 5784:					;
 5785:					;***************************************************************
 5786:					;
 5787:	  1780	12 05 26		CALL	CCAL		;GET EVERYTHING SET UP
 5788:	  1783	7A 02			MOV	R2,#HIGH PSTART
 5789:	  1785	78 00			MOV	R0,#LOW PSTART
 5790:	  1787	B1 7A			ACALL	LMOV		;DO THE TRANSFER
 5791:	  1789	12 06 6E		CALL	RCLEAR		;CLEAR THE MEMORY
 5792:					;
 5793:					; Fall thru to CRAM
 5794:					;
 5795:					;***************************************************************
 5796:					;
 5797:	  178C			CRAM:	; The command action routine - RAM - Run out of ram
 5798:					;
 5799:					;***************************************************************
 5800:					;
 5801:	  178C	C2 17			CLR	CONB		;CAN'T CONTINUE IF MODE CHANGE
 5802:	  178E	75 13 02		MOV	BOFAH,#HIGH PSTART
 5803:	  1791	75 14 00		MOV	BOFAL,#LOW PSTART
 5804:					;
 5805:					; Fall thru to Command Processor
 5806:					;
 5807:					;***************************************************************
 5808:					;
 5809:	  1794			CMND1:	; The entry point for the command processor
 5810:					;
 5811:					;***************************************************************
 5812:					;
 5813:	  1794	12 0C 3B		LCALL	SPRINT1 	;WASTE AT AND HEX
 5814:	  1797	C2 2D			CLR	XBIT		;TO RESET IF NEEDED
 5815:				;
 5816:				;*****************************************************************************
 5817:				;****** Karmann 1 Bugfix *****************************************************
 5818:				;
 5819:	  1799	F1 ED			acall	TEST_USER	;check for user command extensions
 5820:				;
 5821:				;****** continue with original code: *****************************************
 5822:				;
 5823:	  179B	90 00 FD		MOV	DPTR,#RDYS	;PRINT THE READY MESSAGE
 5824:	  179E	12 06 B7		CALL	CRP		;DO A CR, THEN, PRINT FROM THE ROM
 5825:					;
 5826:	  17A1	D2 2F		CMNDR:	SETB	DIRF		;SET THE DIRECT INPUT BIT
 5827:	  17A3	85 3E 81		MOV	SP,SPSAV	;LOAD THE STACK
 5828:	  17A6	11 AA			ACALL	CL7		;DO A CRLF
 5829:					;
 5830:	  17A8	C2 18		CMNX:	CLR	GTRD		;CLEAR BREAK
 5831:	  17AA	90 00 5E		MOV	DPTR,#5EH	;DO RUN TRAP
 5832:	  17AD	E0			MOVX	A,@DPTR
 5833:	  17AE	64 34			XRL	A,#52
 5834:	  17B0	70 03			JNZ	CMNX1
 5835:	  17B2	02 08 0C		LJMP	CRUN
 5836:	  17B5	7D 3E		CMNX1:	MOV	R5,#'>'         ;OUTPUT A PROMPT
 5837:	  17B7	12 07 1B		LCALL	TEROT
 5838:	  17BA	12 06 E2		CALL	INLINE		;INPUT A LINE INTO IBUF
 5839:	  17BD	B1 C7			CALL	PP		;PRE-PROCESS THE LINE
 5840:	  17BF	20 D5 0F		JB	F0,CMND3	;NO LINE NUMBER
 5841:	  17C2	91 FD			CALL	LINE		;PROCESS THE LINE
 5842:	  17C4	12 05 F1		LCALL	LCLR
 5843:	  17C7	20 15 DE		JB	LINEB,CMNX	;DON'T CLEAR MEMORY IF NO NEED
 5844:	  17CA	D2 15			SETB	LINEB
 5845:	  17CC	12 06 6E		LCALL	RCLEAR		;CLEAR THE MEMORY
 5846:	  17CF	80 D7			SJMP	CMNX		;LOOP BACK
 5847:					;
 5848:	  17D1	F1 79		CMND3:	CALL	T_BUF		;SET UP THE TEXT POINTER
 5849:	  17D3	12 0E EC		CALL	DELTST		;GET THE CHARACTER
 5850:	  17D6	60 C9			JZ	CMNDR		;IF CR, EXIT
 5851:	  17D8	90 01 0F		MOV	DPTR,#CMNDD	;POINT AT THE COMMAND LOOKUP
 5852:	  17DB	B4 F0 00		CJNE	A,#T_CMND,CMND31;PROCESS STATEMENT IF NOT A COMMAND
 5853:	  17DE	40 0A		CMND31: JC	CMND5
 5854:	  17E0	12 0E E2		CALL	GCI1		;BUMP TXA
 5855:	  17E3	54 0F			ANL	A,#0FH		;STRIP MSB'S FOR LOOKUP
 5856:	  17E5	12 09 66		LCALL	ISTA1		;PROCESS COMMAND
 5857:	  17E8	80 B7			SJMP	CMNDR
 5858:					;
 5859:	  17EA	02 08 1D	CMND5:	LJMP	ILOOP		;CHECK FOR A POSSIBLE BREAK
 5860:				;
 5861:				;*****************************************************************************
 5862:				;****** Karmann 1 Bugfix *****************************************************
 5863:				;
 5864:	  17ED			TEST_USER:			;check for user command extensions
 5865:	  17ED	E4			CLR	A
 5866:	  17EE	90 20 02		MOV	DPTR,#2002H	;CHECK FOR EXTERNAL TRAP PACKAGE
 5867:	  17F1	93			MOVC	A,@A+DPTR
 5868:	  17F2	B4 5A 03		CJNE	A,#5AH,CMND11	;test for user commands
 5869:	  17F5	12 20 48		LCALL	2048H		;IF PRESENT JUMP TO LOCATION 200BH
 5870:	  17F8	22		CMND11: ret
 5871:				;
 5872:				;****** continue with original code: *****************************************
 5873:				;
 5874:					;CONSTANTS
 5875:					;
 5876:	  17F9	88		XTALV:	DB	128+8		; DEFAULT CRYSTAL VALUE
 5877:	  17FA	00			DB	00H
 5878:	  17FB	00			DB	00H
 5879:	  17FC	92			DB	92H
 5880:	  17FD	05			DB	05H
 5881:	  17FE	11			DB	11H
 5882:					;
 5883:	  17FF	85		EXP11:	DB	85H
 5884:	  1800	00			DB	00H
 5885:	  1801	42			DB	42H
 5886:	  1802	41			DB	41H
 5887:	  1803	87			DB	87H
 5888:	  1804	59			DB	59H
 5889:					;
 5890:	  1805	81		EXP1:	DB	128+1		; EXP(1)
 5891:	  1806	00			DB	00H
 5892:	  1807	18			DB	18H
 5893:	  1808	28			DB	28H
 5894:	  1809	18			DB	18H
 5895:	  180A	27			DB	27H
 5896:				;
 5897:				;*****************************************************************************
 5898:				;****** Disable Intel programming for to get room ****************************
 5899:				;
 5900:				;IPTIME: DB	128-4		;FPROG TIMING
 5901:				;	DB	00H
 5902:				;	DB	00H
 5903:				;	DB	00H
 5904:				;	DB	75H
 5905:				;	DB	83H
 5906:				;
 5907:				;*****************************************************************************
 5908:				;
 5909:	  180B	81		PIE:	DB	128+1		;PI
 5910:	  180C	00			DB	00H
 5911:	  180D	26			DB	26H
 5912:	  180E	59			DB	59H
 5913:	  180F	41			DB	41H
 5914:	  1810	31			DB	31H		; 3.1415926
 5915:					;
 5916:					;***************************************************************
 5917:					;
 5918:					; The error messages, some have been moved
 5919:					;
 5920:					;***************************************************************
 5921:					;
 5922:	  1811	9E		E7X:	DB	128+30
 5923:	  1812	41 52 49 54		DB	'ARITH. UNDERFLOW"'
	  1816	48 2E 20 55
	  181A	4E 44 45 52
	  181E	46 4C 4F 57
	  1822	22
 5924:					;
 5925:	  1823	4D 45 4D 4F	E5X:	DB	'MEMORY ALLOCATION"'
	  1827	52 59 20 41
	  182B	4C 4C 4F 43
	  182F	41 54 49 4F
	  1833	4E 22
 5926:					;
 5927:	  1835	A8		E3X:	DB	128+40
 5928:	  1836	42 41 44 20		DB	'BAD ARGUMENT"'
	  183A	41 52 47 55
	  183E	4D 45 4E 54
	  1842	22
 5929:					;
 5930:	  1843	49 2D 53 54	EXI:	DB	'I-STACK"'
	  1847	41 43 4B 22
 5931:					;
 5932:					;***************************************************************
 5933:					;
 5934:					; The command action routine - CONTINUE
 5935:					;
 5936:					;***************************************************************
 5937:					;
 5938:	  184B	90 1F A6	CCONT:	MOV	DPTR,#E15X
 5939:	  184E	30 17 4B		JNB	CONB,ERROR	;ERROR IF CONTINUE IS NOT SET
 5940:					;
 5941:	  1851			CC1:	;used for input statement entry
 5942:					;
 5943:	  1851	85 42 0A		MOV	TXAH,INTXAH	;RESTORE TXA
 5944:	  1854	85 43 08		MOV	TXAL,INTXAL
 5945:	  1857	02 08 19		JMP	CILOOP		;EXECUTE
 5946:					;
 5947:	  185A	85 0F 83	DTEMP:	MOV	DPH,TEMP5	;RESTORE DPTR
 5948:	  185D	85 0E 82		MOV	DPL,TEMP4
 5949:	  1860	22			RET
 5950:					;
 5951:	  1861	85 83 0F	TEMPD:	MOV	TEMP5,DPH
 5952:	  1864	85 82 0E		MOV	TEMP4,DPL
 5953:	  1867	22			RET
 5954:					;
 5955:					;**************************************************************
 5956:					;
 5957:	  1868			I_DL:	; IDLE
 5958:					;
 5959:					;**************************************************************
 5960:					;
 5961:	  1868	20 2F 27		JB	DIRF,E1XX	;SYNTAX ERROR IN DIRECT INPUT
 5962:	  186B	C2 96			CLR	DACK		;ACK IDLE
 5963:					;
 5964:	  186D	43 87 01	U_ID1:	ORL	PCON,#01H
 5965:				;	DB	01000011B	;ORL DIRECT OP CODE
 5966:				;	DB	87H		;PCON ADDRESS
 5967:				;	DB	01H		;SET IDLE BIT
 5968:	  1870	20 16 0B		JB	INTPEN,I_RET	;EXIT IF EXTERNAL INTERRUPT
 5969:	  1873	10 21 08		JBC	U_IDL,I_RET	;EXIT IF USER WANTS TO
 5970:	  1876	30 10 F4		JNB	OTS,U_ID1	;LOOP IF TIMER NOT ENABLED
 5971:	  1879	12 07 ED		LCALL	T_CMP		;CHECK THE TIMER
 5972:	  187C	40 EF			JC	U_ID1		;LOOP IF TIME NOT BIG ENOUGH
 5973:					;
 5974:	  187E	D2 96		I_RET:	SETB	DACK		;RESTORE EXECUTION
 5975:	  1880	22			RET			;EXIT IF IT IS
 5976:					;
 5977:					;
 5978:					;
 5979:	  1881	A3		ER0:	INC	DPTR		;BUMP TO TEXT
 5980:	  1882	20 2F 23		JB	DIRF,ERROR0	;CAN'T GET OUT OF DIRECT MODE
 5981:	  1885	30 13 20		JNB	ON_ERR,ERROR0	;IF ON ERROR ISN'T SET, GO BACK
 5982:	  1888	90 01 01		MOV	DPTR,#ERRLOC	;SAVE THE ERROR CODE
 5983:	  188B	12 06 7D		CALL	RC2		;SAVE ERROR AND SET UP THE STACKS
 5984:	  188E	A3			INC	DPTR		;POINT AT ERRNUM
 5985:	  188F	02 08 4E		JMP	ERL4		;LOAD ERR NUM AND EXIT
 5986:					;
 5987:					; Syntax error
 5988:					;
 5989:	  1892	A2 2F		E1XX:	MOV	C,DIRF		;SEE IF IN DIRECT MODE
 5990:	  1894	90 17 53	E1XX1:	MOV	DPTR,#E1X	;ERROR MESSAGE
 5991:	  1897	80 04			SJMP	ERROR1		;TRAP ON SET DIRF
 5992:					;
 5993:	  1899	90 18 43	E1XX2:	MOV	DPTR,#EXI	;STACK ERROR
 5994:					;
 5995:					; Falls through
 5996:					;
 5997:					;***************************************************************
 5998:					;
 5999:					;ERROR PROCESSOR - PRINT OUT THE ERROR TYPE, CHECK TO SEE IF IN
 6000:					;		   RUN OR COMMAND MODE, FIND AND PRINT OUT THE
 6001:					;		   LINE NUMBER IF IN RUN MODE
 6002:					;
 6003:					;***************************************************************
 6004:					;
 6005:	  189C	C3		ERROR:	CLR	C		;RESET STACK
 6006:	  189D	85 3E 81	ERROR1: MOV	SP,SPSAV	;RESET THE STACK
 6007:	  18A0	12 0C 3B		LCALL	SPRINT1 	;CLEAR LINE AND AT MODE
 6008:	  18A3	E4			CLR	A		;SET UP TO GET ERROR CODE
 6009:	  18A4	93			MOVC	A,@A+DPTR
 6010:	  18A5	10 E7 D9		JBC	ACC.7,ER0	;PROCESS ERROR
 6011:					;
 6012:	  18A8	11 61		ERROR0: ACALL	TEMPD		;SAVE THE DATA POINTER
 6013:	  18AA	40 03			JC	ERROR01 	;NO RESET IF CARRY IS SET
 6014:	  18AC	12 06 79		LCALL	RC1		;RESET THE STACKS
 6015:	  18AF	12 06 AD	ERROR01:CALL	CRLF2		;DO TWO CARRIAGE RET - LINE FEED
 6016:	  18B2	90 1F F8		MOV	DPTR,#ERS	;OUTPUT ERROR MESSAGE
 6017:	  18B5	12 06 B9		CALL	ROM_P
 6018:	  18B8	11 5A			CALL	DTEMP		;GET THE ERROR MESSAGE BACK
 6019:					;
 6020:	  18BA	12 06 B9	ERRS:	CALL	ROM_P		;PRINT ERROR TYPE
 6021:	  18BD	30 2F 05		JNB	DIRF,ER1	;DO NOT PRINT IN LINE IF DIRF=1
 6022:					;
 6023:	  18C0	C2 20		SERR1:	CLR	STOPBIT 	;PRINT STOP THEN EXIT, FOR LIST
 6024:	  18C2	02 17 94		JMP	CMND1
 6025:					;
 6026:	  18C5	90 01 03	ER1:	MOV	DPTR,#INS	;OUTPUT IN LINE
 6027:	  18C8	12 06 B9		CALL	ROM_P
 6028:					;
 6029:					;NOW, FIND THE LINE NUMBER
 6030:					;
 6031:					;
 6032:	  18CB	12 0E A6		CALL	DP_B		;GET THE FIRST ADDRESS OF THE PROGRAM
 6033:	  18CE	E4			CLR	A		;FOR INITIALIZATION
 6034:					;
 6035:	  18CF	11 61		ER2:	ACALL	TEMPD		;SAVE THE DPTR
 6036:	  18D1	12 05 E8		CALL	ADDPTR		;ADD ACC TO DPTR
 6037:	  18D4	31 08			ACALL	ER4		;R3:R1 = TXA-DPTR
 6038:	  18D6	40 06			JC	ER3		;EXIT IF DPTR>TXA
 6039:	  18D8	60 04			JZ	ER3		;EXIT IF DPTR=TXA
 6040:	  18DA	E0			MOVX	A,@DPTR 	;GET LENGTH
 6041:	  18DB	B4 01 F1		CJNE	A,#EOF,ER2	;SEE IF AT THE END
 6042:					;
 6043:	  18DE	11 5A		ER3:	ACALL	DTEMP		;PUT THE LINE IN THE DPTR
 6044:	  18E0	31 08			ACALL	ER4		;R3:R1 = TXA - BEGINNING OF LINE
 6045:	  18E2	E9			MOV	A,R1		;GET LENGTH
 6046:	  18E3	24 0A			ADD	A,#10		;ADD 10 TO LENGTH, DPTR STILL HAS ADR
 6047:	  18E5	F5 45			MOV	MT1,A		;SAVE THE COUNT
 6048:	  18E7	A3			INC	DPTR		;POINT AT LINE NUMBER HIGH BYTE
 6049:	  18E8	12 16 5F		CALL	PMTOP1		;LOAD R2:R0, PUT IT ON THE STACK
 6050:	  18EB	31 8A			ACALL	FP_BASE7	;OUTPUT IT
 6051:	  18ED	20 20 D0		JB	STOPBIT,SERR1	;EXIT IF STOP BIT SET
 6052:	  18F0	12 06 AD		CALL	CRLF2		;DO SOME CRLF'S
 6053:	  18F3	11 5A			CALL	DTEMP
 6054:	  18F5	12 10 B0		CALL	UPPL		;UNPROCESS THE LINE
 6055:	  18F8	12 10 A1		CALL	CL6		;PRINT IT
 6056:	  18FB	7D 2D		ER31:	MOV	R5,#'-'         ;OUTPUT DASHES, THEN AN X
 6057:	  18FD	31 79			ACALL	T_L		;PRINT AN X IF ERROR CHARACTER FOUND
 6058:	  18FF	D5 45 F9		DJNZ	MT1,ER31	;LOOP UNTIL DONE
 6059:	  1902	7D 58			MOV	R5,#'X'
 6060:	  1904	31 79			ACALL	T_L
 6061:	  1906	01 C0			AJMP	SERR1
 6062:					;
 6063:	  1908	AB 0A		ER4:	MOV	R3,TXAH 	;GET TEXT POINTER AND PERFORM SUBTRACTION
 6064:	  190A	A9 08			MOV	R1,TXAL
 6065:	  190C	02 0A 0C		JMP	DUBSUB
 6066:					;
 6067:					;**************************************************************
 6068:					;
 6069:					; Interrupt driven timer
 6070:					;
 6071:					;**************************************************************
 6072:					;
 6073:	  190F	85 4A 8C	I_DR:	MOV	TH0,SAVE_T	;LOAD THE TIMER
 6074:	  1912	C5 47			XCH	A,MILLIV	;SAVE A, GET MILLI COUNTER
 6075:	  1914	04			INC	A		;BUMP COUNTER
 6076:	  1915	B4 C8 08		CJNE	A,#200,TR	;CHECK OUT TIMER VALUE
 6077:	  1918	E4			CLR	A		;FORCE ACC TO BE ZERO
 6078:	  1919	05 49			INC	TVL		;INCREMENT LOW TIMER
 6079:	  191B	B5 49 02		CJNE	A,TVL,TR	;CHECK LOW VALUE
 6080:	  191E	05 48			INC	TVH		;BUMP TIMER HIGH
 6081:					;
 6082:	  1920	C5 47		TR:	XCH	A,MILLIV
 6083:	  1922	D0 D0			POP	PSW
 6084:	  1924	32			RETI
 6085:					;
 6086:					;**************************************************************
 6087:					;
 6088:					; The statement action routine - CLOCK
 6089:					;
 6090:					;**************************************************************
 6091:					;
 6092:	  1925	31 45		SCLOCK: ACALL	OTST		;GET CHARACTER AFTER CLOCK TOKEN
 6093:	  1927	C2 A9			CLR	ET0
 6094:	  1929	C2 2E			CLR	C_BIT
 6095:	  192B	50 0D			JNC	SC_R		;EXIT IF A ZERO
 6096:				;
 6097:				;*****************************************************************************
 6098:				;****** Use XTAL up to 47 MHz ************************************************
 6099:				;****** Wulf 2 ***************************************************************
 6100:				;
 6101:				;	ANL	TMOD,#0F0H	;SET UP THE MODE
 6102:				;
 6103:	  192D	53 89 F1		anl	TMOD,#0F1H	;Set up 16 bit mode for timer 0
 6104:	  1930	43 89 01		orl	TMOD,#01H
 6105:				;
 6106:				;*****************************************************************************
 6107:				;
 6108:	  1933	D2 2E			SETB	C_BIT		;USER INTERRUPTS
 6109:	  1935	43 A8 82		ORL	IE,#82H 	;ENABLE ET0 AND EA
 6110:	  1938	D2 8C			SETB	TR0		;TURN ON THE TIMER
 6111:					;
 6112:	  193A	22		SC_R:	RET
 6113:					;
 6114:					;***************************************************************
 6115:					;
 6116:	  193B			SUI:	; Statement USER IN action routine
 6117:					;
 6118:					;***************************************************************
 6119:					;
 6120:	  193B	31 45			ACALL	OTST
 6121:	  193D	92 1E			MOV	CIUB,C		;SET OR CLEAR CIUB
 6122:	  193F	22			RET
 6123:					;
 6124:					;***************************************************************
 6125:					;
 6126:	  1940			SUO:	; Statement USER OUT action routine
 6127:					;
 6128:					;***************************************************************
 6129:					;
 6130:	  1940	31 45			ACALL	OTST
 6131:	  1942	92 1C			MOV	COUB,C
 6132:	  1944	22			RET
 6133:					;
 6134:	  1945			OTST:	; Check for a one
 6135:					;
 6136:	  1945	12 0E E0		LCALL	GCI		;GET THE CHARACTER, CLEARS CARRY
 6137:	  1948	94 31			SUBB	A,#'1'          ;SEE IF A ONE
 6138:	  194A	B3			CPL	C		;SETS CARRY IF ONE, CLEARS IT IF ZERO
 6139:	  194B	22		OTST1:	RET
 6140:					;
 6141:					;**************************************************************
 6142:					;
 6143:					; IBLK - EXECUTE USER SUPPLIED TOKEN
 6144:					;
 6145:					;**************************************************************
 6146:					;
 6147:	  194C	20 D4 FC	IBLK:	JB	PSW.4,OTST1	;EXIT IF REGISTER BANK <> 0
 6148:	  194F	20 D3 F9		JB	PSW.3,OTST1
 6149:	  1952	10 E7 06		JBC	ACC.7,IBLK1	;SEE IF BIT SEVEN IS SET
 6150:	  1955	90 00 47		MOV	DPTR,#USENT	;USER ENTRY LOCATION
 6151:	  1958	02 09 66		LJMP	ISTA1
 6152:					;
 6153:	  195B	20 E0 2A	IBLK1:	JB	ACC.0,FP_BASE6	;FLOATING POINT INPUT
 6154:	  195E	60 19			JZ	T_L		;DO OUTPUT ON 80H
 6155:	  1960	90 19 7A		MOV	DPTR,#FP_BASE-2
 6156:	  1963	73			JMP	@A+DPTR
 6157:					;
 6158:					;
 6159:					;**************************************************************
 6160:					;
 6161:					; GET_NUM - GET A NUMBER, EITHER HEX OR FLOAT
 6162:					;
 6163:					;**************************************************************
 6164:					;
 6165:	  1964	31 86		GET_NUM:ACALL	FP_BASE5	;SCAN FOR HEX
 6166:	  1966	50 20			JNC	FP_BASE6	;DO FP INPUT
 6167:					;
 6168:	  1968	31 8E			ACALL	FP_BASE9	;ASCII STRING TO R2:R0
 6169:	  196A	70 0C			JNZ	H_RET
 6170:	  196C	C0 83			PUSH	DPH		;SAVE THE DATA_POINTER
 6171:	  196E	C0 82			PUSH	DPL
 6172:	  1970	31 94			ACALL	FP_BASE12	;PUT R2:R0 ON THE STACK
 6173:	  1972	D0 82			POP	DPL		;RESTORE THE DATA_POINTER
 6174:	  1974	D0 83			POP	DPH
 6175:	  1976	E4			CLR	A		;NO ERRORS
 6176:	  1977	22			RET			;EXIT
 6177:					;
 6178:					;**************************************************************
 6179:					;
 6180:					; WB - THE EGO MESSAGE
 6181:					;
 6182:					;**************************************************************
 6183:				;
 6184:				;*****************************************************************************
 6185:				;****** Sorry - but the ego message had to be disabled ***********************
 6186:				;
 6187:				;WB:
 6188:				;
 6189:				;	DB	'W'+80H,'R'+80H
 6190:				;	DB	'I'+80H,'T'+80H,'T','E'+80H,'N'+80H
 6191:				;	DB	' ','B'+80H,'Y'+80H,' '
 6192:				;	DB	'J'+80H,'O'+80H,'H'+80H,'N'+80H,' '+80H
 6193:				;	DB	'K','A'+80H,'T'+80H,'A'+80H,'U'+80H
 6194:				;	DB	'S','K'+80H,'Y'+80H
 6195:				;	DB	', I','N'+80H,'T'+80H,'E'+80H,'L'+80H
 6196:				;	DB	' '+80H,'C'+80H,'O'+80H,'R'+80H,'P'+80H
 6197:				;	DB	'. 1','9'+80H,'85'
 6198:				;
 6199:				;*****************************************************************************
 6200:					;
 6201:	  1978	22		H_RET:	RET
 6202:					;
 6203:				;************************************************************
 6204:				;
 6205:				; This is a complete BCD floating point package for the 8051 micro-
 6206:				; controller. It provides 8 digits of accuracy with exponents that
 6207:				; range from +127 to -127. The mantissa is in packed BCD, while the
 6208:				; exponent is expressed in pseudo-twos complement. A ZERO exponent
 6209:				; is used to express the number ZERO. An exponent value of 80H or
 6210:				; greater than means the exponent is positive, i.e. 80H = E 0,
 6211:				; 81H = E+1, 82H = E+2 and so on. If the exponent is 7FH or less,
 6212:				; the exponent is negative, 7FH = E-1, 7EH = E-2, and so on.
 6213:				; ALL NUMBERS ARE ASSUMED TO BE NORMALIZED and all results are
 6214:				; normalized after calculation. A normalized mantissa is >=.10 and
 6215:				; <=.99999999.
 6216:				;
 6217:				; The numbers in memory assumed to be stored as follows:
 6218:				;
 6219:				; EXPONENT OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE
 6220:				; SIGN OF ARGUMENT 2	   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-1
 6221:				; DIGIT 78 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-2
 6222:				; DIGIT 56 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-3
 6223:				; DIGIT 34 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-4
 6224:				; DIGIT 12 OF ARGUMENT 2   =   VALUE OF ARG_STACK+FP_NUMBER_SIZE-5
 6225:				;
 6226:				; EXPONENT OF ARGUMENT 1   =   VALUE OF ARG_STACK
 6227:				; SIGN OF ARGUMENT 1	   =   VALUE OF ARG_STACK-1
 6228:				; DIGIT 78 OF ARGUMENT 1   =   VALUE OF ARG_STACK-2
 6229:				; DIGIT 56 OF ARGUMENT 1   =   VALUE OF ARG_STACK-3
 6230:				; DIGIT 34 OF ARGUMENT 1   =   VALUE OF ARG_STACK-4
 6231:				; DIGIT 12 OF ARGUMENT 1   =   VALUE OF ARG_STACK-5
 6232:				;
 6233:				; The operations are performed thusly:
 6234:				;
 6235:				; ARG_STACK+FP_NUMBER_SIZE = ARG_STACK+FP_NUMBER_SIZE # ARG_STACK
 6236:				;
 6237:				; Which is ARGUMENT 2 = ARGUMENT 2 # ARGUMENT 1
 6238:				;
 6239:				; Where # can be ADD, SUBTRACT, MULTIPLY OR DIVIDE.
 6240:				;
 6241:				; Note that the stack gets popped after an operation.
 6242:				;
 6243:				; The FP_COMP instruction POPS the ARG_STACK TWICE and returns status.
 6244:				;
 6245:				;**********************************************************************
 6246:				;
 6247:				;**********************************************************************
 6248:				;
 6249:				; STATUS ON RETURN - After performing an operation (+, -, *, /)
 6250:				;		     the accumulator contains the following status
 6251:				;
 6252:				; ACCUMULATOR - BIT 0 - FLOATING POINT UNDERFLOW OCCURED
 6253:				;
 6254:				;	      - BIT 1 - FLOATING POINT OVERFLOW OCCURED
 6255:				;
 6256:				;	      - BIT 2 - RESULT WAS ZER0
 6257:				;
 6258:				;	      - BIT 3 - DIVIDE BY ZERO ATTEMPTED
 6259:				;
 6260:				;	      - BIT 4 - NOT USED, 0 RETURNED
 6261:				;
 6262:				;	      - BIT 5 - NOT USED, 0 RETURNED
 6263:				;
 6264:				;	      - BIT 6 - NOT USED, 0 RETURNED
 6265:				;
 6266:				;	      - BIT 7 - NOT USED, 0 RETURNED
 6267:				;
 6268:				; NOTE: When underflow occures, a ZERO result is returned.
 6269:				;	When overflow or divide by zero occures, a result of
 6270:				;	.99999999 E+127 is returned and it is up to the user
 6271:				;	to handle these conditions as needed in the program.
 6272:				;
 6273:				; NOTE: The Compare instruction returns F0 = 0 if ARG 1 = ARG 2
 6274:				;	and returns a CARRY FLAG = 1 if ARG 1 is > ARG 2
 6275:				;
 6276:				;***********************************************************************
 6277:				;
 6278:				;***********************************************************************
 6279:				;
 6280:				; The following values MUST be provided by the user
 6281:				;
 6282:				;***********************************************************************
 6283:				;
 6284:		N      0009	ARG_STACK	EQU	9	;ARGUMENT STACK POINTER
 6285:		N      0001	ARG_STACK_PAGE	EQU	1
 6286:				;OUTPUT 	 EQU	 1990H	 ;CALL LOCATION TO OUTPUT A CHARACTER
 6287:		N      0058	CONVERT 	EQU	58H	;LOCATION TO CONVERT NUMBERS
 6288:		N	 19	INTGRC		BIT	25	;BIT SET IF INTGER ERROR
 6289:				;
 6290:				;***********************************************************************
 6291:				;
 6292:				; The following equates are used internally
 6293:				;
 6294:				;***********************************************************************
 6295:				;
 6296:		N      0006	FP_NUMBER_SIZE	EQU	6
 6297:		N      0000	UNDERFLOW	EQU	0
 6298:		N      0001	OVERFLOW	EQU	1
 6299:		N      0002	ZERO		EQU	2
 6300:		N      0003	ZERO_DIVIDE	EQU	3
 6301:				;
 6302:				;***********************************************************************
 6303:				;
 6304:					;**************************************************************
 6305:					;
 6306:					; The following internal locations are used by the math pack
 6307:					; ordering is important and the FP_DIGITS must be bit
 6308:					; addressable
 6309:					;
 6310:					;***************************************************************
 6311:					;
 6312:		N      0028	FP_STATUS	EQU	28H		;NOT USED
 6313:		N      0029	FP_TEMP 	EQU	FP_STATUS+1	;NOT USED
 6314:		N      002A	FP_CARRY	EQU	FP_STATUS+2	;USED FOR BITS
 6315:		N	 23	ADD_IN		BIT	35		;DCMPXZ IN BASIC BACKAGE
 6316:		B	 50	XSIGN		BIT	FP_CARRY.0
 6317:		B	 51	FOUND_RADIX	BIT	FP_CARRY.1
 6318:		B	 52	FIRST_RADIX	BIT	FP_CARRY.2
 6319:		B	 53	DONE_LOAD	BIT	FP_CARRY.3
 6320:		N      002B	FP_DIG12	EQU	FP_CARRY+1
 6321:		N      002C	FP_DIG34	EQU	FP_CARRY+2
 6322:		N      002D	FP_DIG56	EQU	FP_CARRY+3
 6323:		N      002E	FP_DIG78	EQU	FP_CARRY+4
 6324:		N      002F	FP_SIGN 	EQU	FP_CARRY+5
 6325:		B	 78	MSIGN		BIT	FP_SIGN.0
 6326:		N      0030	FP_EXP		EQU	FP_CARRY+6
 6327:		N      002B	FP_NIB1 	EQU	FP_DIG12
 6328:		N      002C	FP_NIB2 	EQU	FP_NIB1+1
 6329:		N      002D	FP_NIB3 	EQU	FP_NIB1+2
 6330:		N      002E	FP_NIB4 	EQU	FP_NIB1+3
 6331:		N      002F	FP_NIB5 	EQU	FP_NIB1+4
 6332:		N      0030	FP_NIB6 	EQU	FP_NIB1+5
 6333:		N      0031	FP_NIB7 	EQU	FP_NIB1+6
 6334:		N      0032	FP_NIB8 	EQU	FP_NIB1+7
 6335:		N      0033	FP_ACCX 	EQU	FP_NIB1+8
 6336:		N      0034	FP_ACCC 	EQU	FP_NIB1+9
 6337:		N      0035	FP_ACC1 	EQU	FP_NIB1+10
 6338:		N      0036	FP_ACC2 	EQU	FP_NIB1+11
 6339:		N      0037	FP_ACC3 	EQU	FP_NIB1+12
 6340:		N      0038	FP_ACC4 	EQU	FP_NIB1+13
 6341:		N      0039	FP_ACC5 	EQU	FP_NIB1+14
 6342:		N      003A	FP_ACC6 	EQU	FP_NIB1+15
 6343:		N      003B	FP_ACC7 	EQU	FP_NIB1+16
 6344:		N      003C	FP_ACC8 	EQU	FP_NIB1+17
 6345:		N      003D	FP_ACCS 	EQU	FP_NIB1+18
 6346:					;
 6347:				;	 ORG	 1990H
 6348:					;
 6349:	  1979			OUTPUT:
 6350:	  1979	02 07 1B	T_L:	LJMP	TEROT
 6351:					;
 6352:					;
 6353:					;**************************************************************
 6354:					;
 6355:					; The floating point entry points and jump table
 6356:					;
 6357:					;**************************************************************
 6358:					;
 6359:	  197C	21 A0		FP_BASE:	AJMP	FLOATING_ADD
 6360:	  197E	21 96		FP_BASE1:	AJMP	FLOATING_SUB
 6361:	  1980	41 50		FP_BASE2:	AJMP	FLOATING_COMP
 6362:	  1982	41 80		FP_BASE3:	AJMP	FLOATING_MUL
 6363:	  1984	41 BD		FP_BASE4:	AJMP	FLOATING_DIV
 6364:	  1986	81 96		FP_BASE5:	AJMP	HEXSCAN
 6365:	  1988	81 CF		FP_BASE6:	AJMP	FLOATING_POINT_INPUT
 6366:	  198A	A1 87		FP_BASE7:	AJMP	FLOATING_POINT_OUTPUT
 6367:	  198C	E1 04		FP_BASE8:	AJMP	CONVERT_BINARY_TO_ASCII_STRING
 6368:	  198E	C1 AB		FP_BASE9:	AJMP	CONVERT_ASCII_STRING_TO_BINARY
 6369:	  1990	C1 E0		FP_BASE10:	AJMP	MULNUM10
 6370:	  1992	E1 3D		FP_BASE11:	AJMP	HEXOUT
 6371:	  1994	81 C3		FP_BASE12:	AJMP	PUSHR2R0
 6372:					;
 6373:					;
 6374:	  1996			FLOATING_SUB:
 6375:					;
 6376:	  1996	75 A0 01		MOV	P2,#ARG_STACK_PAGE
 6377:	  1999	A8 09			MOV	R0,ARG_STACK
 6378:	  199B	18			DEC	R0		;POINT TO SIGN
 6379:	  199C	E2			MOVX	A,@R0		;READ SIGN
 6380:	  199D	B2 E0			CPL	ACC.0
 6381:	  199F	F2			MOVX	@R0,A
 6382:					;
 6383:					;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 6384:					;
 6385:	  19A0			FLOATING_ADD:
 6386:					;
 6387:					;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 6388:					;
 6389:					;
 6390:	  19A0	91 77			ACALL	MDES1		;R7=TOS EXP, R6=TOS-1 EXP, R4=TOS SIGN
 6391:								;R3=TOS-1 SIGN, OPERATION IS R1 # R0
 6392:					;
 6393:	  19A2	EF			MOV	A,R7		;GET TOS EXPONENT
 6394:	  19A3	60 0D			JZ	POP_AND_EXIT	;IF TOS=0 THEN POP AND EXIT
 6395:	  19A5	BE 00 12		CJNE	R6,#0,LOAD1	;CLEAR CARRY EXIT IF ZERO
 6396:					;
 6397:					;**************************************************************
 6398:					;
 6399:	  19A8			SWAP_AND_EXIT:	; Swap external args and return
 6400:					;
 6401:					;**************************************************************
 6402:					;
 6403:	  19A8	91 6B			ACALL	LOAD_POINTERS
 6404:	  19AA	7F 06			MOV	R7,#FP_NUMBER_SIZE
 6405:					;
 6406:	  19AC	E2		SE1:	MOVX	A,@R0		;SWAP THE ARGUMENTS
 6407:	  19AD	F3			MOVX	@R1,A
 6408:	  19AE	18			DEC	R0
 6409:	  19AF	19			DEC	R1
 6410:	  19B0	DF FA			DJNZ	R7,SE1
 6411:					;
 6412:	  19B2			POP_AND_EXIT:
 6413:					;
 6414:	  19B2	E5 09			MOV	A,ARG_STACK	;POP THE STACK
 6415:	  19B4	24 06			ADD	A,#FP_NUMBER_SIZE
 6416:	  19B6	F5 09			MOV	ARG_STACK,A
 6417:	  19B8	E4			CLR	A
 6418:	  19B9	22			RET
 6419:					;
 6420:					;
 6421:	  19BA	9E		LOAD1:	SUBB	A,R6		;A = ARG 1 EXP - ARG 2 EXP
 6422:	  19BB	8F 30			MOV	FP_EXP,R7	;SAVE EXPONENT AND SIGN
 6423:	  19BD	8C 2F			MOV	FP_SIGN,R4
 6424:	  19BF	50 09			JNC	LOAD2		;ARG1 EXPONENT IS LARGER OR SAME
 6425:	  19C1	8E 30			MOV	FP_EXP,R6
 6426:	  19C3	8B 2F			MOV	FP_SIGN,R3
 6427:	  19C5	F4			CPL	A
 6428:	  19C6	04			INC	A		;COMPENSATE FOR EXP DELTA
 6429:	  19C7	C8			XCH	A,R0		;FORCE R0 TO POINT AT THE LARGEST
 6430:	  19C8	C9			XCH	A,R1		;EXPONENT
 6431:	  19C9	C8			XCH	A,R0
 6432:					;
 6433:	  19CA	FF		LOAD2:	MOV	R7,A		;SAVE THE EXPONENT DELTA IN R7
 6434:	  19CB	C2 23			CLR	ADD_IN
 6435:	  19CD	BD 00 02		CJNE	R5,#0,LOAD21
 6436:	  19D0	D2 23			SETB	ADD_IN
 6437:					;
 6438:					; Load the R1 mantissa
 6439:					;
 6440:	  19D2	91 88		LOAD21: ACALL	LOADR1_MANTISSA ;LOAD THE SMALLEST NUMBER
 6441:					;
 6442:					; Now align the number to the delta exponent
 6443:					; R4 points to the string of the last digits lost
 6444:					;
 6445:	  19D4	BF 0B 00		CJNE	R7,#DIGIT+DIGIT+3,LOAD22
 6446:	  19D7	40 02		LOAD22: JC	LOAD23
 6447:	  19D9	7F 0A			MOV	R7,#DIGIT+DIGIT+2
 6448:					;
 6449:	  19DB	75 2A 00	LOAD23: MOV	FP_CARRY,#00	;CLEAR THE CARRY
 6450:	  19DE	71 C8			ACALL	RIGHT		;SHIFT THE NUMBER
 6451:					;
 6452:					; Set up for addition and subtraction
 6453:					;
 6454:	  19E0	7F 04			MOV	R7,#DIGIT	;LOOP COUNT
 6455:	  19E2	79 2E			MOV	R1,#FP_DIG78
 6456:				;
 6457:				;*****************************************************************************
 6458:				;****** Elektor 2 Patch ******************************************************
 6459:				;****** Floting Point Error, found by D. Mudric and Z. Stojsavljevic *********
 6460:				;
 6461:				;	MOV	A,#9EH
 6462:				;****** Error Number 1
 6463:				;
 6464:				;****** Value in R4 must be complemented with 100D (#9AH), it must be the
 6465:				;****** first complement
 6466:				;
 6467:				;	CLR	C
 6468:				;	SUBB	A,R4
 6469:				;	DA	A
 6470:				;	XCH	A,R4
 6471:				;	JNZ	LOAD24
 6472:				;	MOV	R4,A
 6473:				;****** Error Number 2
 6474:				;
 6475:				;****** With substraction, after reducing both the minuend and the
 6476:				;****** subtrahend to the same exponents, when R4 <> 0, it is obvious
 6477:				;****** that one always has to make a borrowing from the first higher
 6478:				;****** position of the minuend, not as it is stated by the original
 6479:				;****** were it is made only when R4 = 50H
 6480:				;
 6481:				;LOAD24: CJNE	 A,#50H,LOAD25	 ;TEST FOR SUBTRACTION
 6482:				;LOAD25: JNB	 ADD_IN,SUBLP	 ;DO SUBTRACTION IF NO ADD_IN
 6483:				;
 6484:				;*****************************************************************************
 6485:				;****** Proper code starts here: *********************************************
 6486:				;
 6487:	  19E4	74 9A			mov	A,#9AH
 6488:	  19E6	C3			clr	C
 6489:	  19E7	9C			subb	A,R4
 6490:	  19E8	D4			da	A
 6491:	  19E9	CC			xch	A,R4
 6492:	  19EA	30 23 1B		jnb	ADD_IN,SUBLP
 6493:	  19ED	B4 50 00		cjne	A,#50H,LOAD25
 6494:				;
 6495:				;****** continue with original code: *****************************************
 6496:				;
 6497:	  19F0	B3		LOAD25: CPL	C		;FLIP CARRY FOR ADDITION
 6498:	  19F1	31 FF			ACALL	ADDLP		;DO ADDITION
 6499:					;
 6500:	  19F3	50 08			JNC	ADD_R
 6501:	  19F5	05 2A			INC	FP_CARRY
 6502:	  19F7	7F 01			MOV	R7,#1
 6503:	  19F9	71 C8			ACALL	RIGHT
 6504:	  19FB	71 7F			ACALL	INC_FP_EXP	;SHIFT AND BUMP EXPONENT
 6505:					;
 6506:	  19FD	61 70		ADD_R:	AJMP	STORE_ALIGN_TEST_AND_EXIT
 6507:					;
 6508:	  19FF	E2		ADDLP:	MOVX	A,@R0
 6509:	  1A00	37			ADDC	A,@R1
 6510:	  1A01	D4			DA	A
 6511:	  1A02	F7			MOV	@R1,A
 6512:	  1A03	18			DEC	R0
 6513:	  1A04	19			DEC	R1
 6514:	  1A05	DF F8			DJNZ	R7,ADDLP	;LOOP UNTIL DONE
 6515:	  1A07	22			RET
 6516:					;
 6517:	  1A08	E2		SUBLP:	MOVX	A,@R0		;NOW DO SUBTRACTION
 6518:	  1A09	FE			MOV	R6,A
 6519:	  1A0A	E4			CLR	A
 6520:	  1A0B	34 99			ADDC	A,#99H
 6521:	  1A0D	97			SUBB	A,@R1
 6522:	  1A0E	2E			ADD	A,R6
 6523:	  1A0F	D4			DA	A
 6524:	  1A10	F7			MOV	@R1,A
 6525:	  1A11	18			DEC	R0
 6526:	  1A12	19			DEC	R1
 6527:	  1A13	DF F3			DJNZ	R7,SUBLP
 6528:	  1A15	40 11			JC	FSUB6
 6529:					;
 6530:					; Need to complement the result and sign because the floating
 6531:					; point accumulator mantissa was larger than the external
 6532:					; memory and their signs were equal.
 6533:					;
 6534:	  1A17	B2 78			CPL	FP_SIGN.0
 6535:	  1A19	79 2E			MOV	R1,#FP_DIG78
 6536:	  1A1B	7F 04			MOV	R7,#DIGIT	;LOOP COUNT
 6537:					;
 6538:	  1A1D	74 9A		FSUB5:	MOV	A,#9AH
 6539:	  1A1F	97			SUBB	A,@R1
 6540:	  1A20	24 00			ADD	A,#0
 6541:	  1A22	D4			DA	A
 6542:	  1A23	F7			MOV	@R1,A
 6543:	  1A24	19			DEC	R1
 6544:	  1A25	B3			CPL	C
 6545:	  1A26	DF F5			DJNZ	R7,FSUB5	;LOOP
 6546:					;
 6547:					; Now see how many zeros their are
 6548:					;
 6549:	  1A28	78 2B		FSUB6:	MOV	R0,#FP_DIG12
 6550:	  1A2A	7F 00			MOV	R7,#0
 6551:					;
 6552:	  1A2C	E6		FSUB7:	MOV	A,@R0
 6553:	  1A2D	70 08			JNZ	FSUB8
 6554:	  1A2F	0F			INC	R7
 6555:	  1A30	0F			INC	R7
 6556:	  1A31	08			INC	R0
 6557:	  1A32	B8 2F F7		CJNE	R0,#FP_SIGN,FSUB7
 6558:	  1A35	61 B8			AJMP	ZERO_AND_EXIT
 6559:					;
 6560:	  1A37	B4 10 00	FSUB8:	CJNE	A,#10H,FSUB81
 6561:	  1A3A	50 01		FSUB81: JNC	FSUB9
 6562:	  1A3C	0F			INC	R7
 6563:					;
 6564:					; Now R7 has the number of leading zeros in the FP ACC
 6565:					;
 6566:	  1A3D	E5 30		FSUB9:	MOV	A,FP_EXP	;GET THE OLD EXPONENT
 6567:	  1A3F	C3			CLR	C
 6568:	  1A40	9F			SUBB	A,R7		;SUBTRACT FROM THE NUMBER OF ZEROS
 6569:	  1A41	60 0B			JZ	FSUB10
 6570:	  1A43	40 09			JC	FSUB10
 6571:					;
 6572:	  1A45	F5 30			MOV	FP_EXP,A	;SAVE THE NEW EXPONENT
 6573:					;
 6574:	  1A47	91 02			ACALL	LEFT1		;SHIFT THE FP ACC
 6575:	  1A49	75 2A 00		MOV	FP_CARRY,#0
 6576:	  1A4C	61 70			AJMP	STORE_ALIGN_TEST_AND_EXIT
 6577:					;
 6578:	  1A4E	61 B2		FSUB10: AJMP	UNDERFLOW_AND_EXIT
 6579:					;
 6580:					;***************************************************************
 6581:					;
 6582:	  1A50			FLOATING_COMP:	; Compare two floating point numbers
 6583:						; used for relational operations and is faster
 6584:						; than subtraction. ON RETURN, The carry is set
 6585:						; if ARG1 is > ARG2, else carry is not set
 6586:						; if ARG1 = ARG2, F0 gets set
 6587:					;
 6588:					;***************************************************************
 6589:					;
 6590:	  1A50	91 77			ACALL	MDES1		;SET UP THE REGISTERS
 6591:	  1A52	E5 09			MOV	A,ARG_STACK
 6592:	  1A54	24 0C			ADD	A,#FP_NUMBER_SIZE+FP_NUMBER_SIZE
 6593:	  1A56	F5 09			MOV	ARG_STACK,A	;POP THE STACK TWICE, CLEAR THE CARRY
 6594:	  1A58	EE			MOV	A,R6		;CHECK OUT EXPONENTS
 6595:	  1A59	C2 D5			CLR	F0
 6596:	  1A5B	9F			SUBB	A,R7
 6597:	  1A5C	60 0A			JZ	EXPONENTS_EQUAL
 6598:	  1A5E	40 03			JC	ARG1_EXP_IS_LARGER
 6599:					;
 6600:					; Now the ARG2 EXPONENT is > ARG1 EXPONENT
 6601:					;
 6602:	  1A60			SIGNS_DIFFERENT:
 6603:					;
 6604:	  1A60	EB			MOV	A,R3		;SEE IF SIGN OF ARG2 IS POSITIVE
 6605:	  1A61	80 01			SJMP	ARG1_EXP_IS_LARGER1
 6606:					;
 6607:	  1A63			ARG1_EXP_IS_LARGER:
 6608:					;
 6609:	  1A63	EC			MOV	A,R4		;GET THE SIGN OF ARG1 EXPONENT
 6610:	  1A64			ARG1_EXP_IS_LARGER1:
 6611:	  1A64	60 01			JZ	ARG1_EXP_IS_LARGER2
 6612:	  1A66	B3			CPL	C
 6613:	  1A67			ARG1_EXP_IS_LARGER2:
 6614:	  1A67	22			RET
 6615:					;
 6616:	  1A68			EXPONENTS_EQUAL:
 6617:					;
 6618:					; First, test the sign, then the mantissa
 6619:					;
 6620:	  1A68	BD 00 F5		CJNE	R5,#0,SIGNS_DIFFERENT
 6621:					;
 6622:	  1A6B			BOTH_PLUS:
 6623:					;
 6624:	  1A6B	7F 04			MOV	R7,#DIGIT	;POINT AT MS DIGIT
 6625:	  1A6D	18			DEC	R0
 6626:	  1A6E	18			DEC	R0
 6627:	  1A6F	18			DEC	R0
 6628:	  1A70	19			DEC	R1
 6629:	  1A71	19			DEC	R1
 6630:	  1A72	19			DEC	R1
 6631:					;
 6632:					; Now do the compare
 6633:					;
 6634:	  1A73	E2		CLOOP:	MOVX	A,@R0
 6635:	  1A74	FE			MOV	R6,A
 6636:	  1A75	E3			MOVX	A,@R1
 6637:	  1A76	9E			SUBB	A,R6
 6638:	  1A77	70 EA			JNZ	ARG1_EXP_IS_LARGER
 6639:	  1A79	08			INC	R0
 6640:	  1A7A	09			INC	R1
 6641:	  1A7B	DF F6			DJNZ	R7,CLOOP
 6642:					;
 6643:					; If here, the numbers are the same, the carry is cleared
 6644:					;
 6645:	  1A7D	D2 D5			SETB	F0
 6646:	  1A7F	22			RET			;EXIT WITH EQUAL
 6647:					;
 6648:				;MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 6649:				;
 6650:	  1A80			FLOATING_MUL:	; Floating point multiply
 6651:				;
 6652:				;MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 6653:				;
 6654:	  1A80	91 75			ACALL	MUL_DIV_EXP_AND_SIGN
 6655:					;
 6656:					; check for zero exponents
 6657:					;
 6658:	  1A82	BE 00 02		CJNE	R6,#00,FMUL1	;ARG 2 EXP ZERO?
 6659:	  1A85	61 B8		FMUL0:	AJMP	ZERO_AND_EXIT
 6660:					;
 6661:					; calculate the exponent
 6662:					;
 6663:	  1A87	8D 2F		FMUL1:	MOV	FP_SIGN,R5	;SAVE THE SIGN, IN CASE OF FAILURE
 6664:					;
 6665:	  1A89	EF			MOV	A,R7
 6666:	  1A8A	60 F9			JZ	FMUL0
 6667:	  1A8C	2E			ADD	A,R6		;ADD THE EXPONENTS
 6668:	  1A8D	20 E7 05		JB	ACC.7,FMUL_OVER
 6669:	  1A90	10 D7 08		JBC	CY,FMUL21	;SEE IF CARRY IS SET
 6670:					;
 6671:	  1A93	61 B2			AJMP	UNDERFLOW_AND_EXIT
 6672:					;
 6673:	  1A95			FMUL_OVER:
 6674:					;
 6675:	  1A95	50 02			JNC	FMUL2		;OK IF SET
 6676:					;
 6677:	  1A97	61 A1		FOV:	AJMP	OVERFLOW_AND_EXIT
 6678:				;*****************************************************************************
 6679:				;****** Wulf 1 Bugfix 1 ******************************************************
 6680:				;****** Multiplication Error, found by D. Wulf *******************************
 6681:				;
 6682:				; FMUL2: SUBB	 A,#129 	 ;SUBTRACT THE EXPONENT BIAS
 6683:				;
 6684:				;*****************************************************************************
 6685:				;****** Proper code starts here: *********************************************
 6686:				;
 6687:	  1A99	D2 28		FMUL2:	setb	mul_underflow	;Flag of multiplication limit case
 6688:	  1A9B	94 83		FMUL21: subb	A,#83H		;exp. multipl. results are within the limits
 6689:	  1A9D	04			inc	A		;Correct SUBB 83H
 6690:	  1A9E	04			inc	A		;to original SUBB 81H
 6691:	  1A9F	40 02			jc     NMARK_L		;Limit case
 6692:	  1AA1	C2 28			clr	mul_underflow	;No limit case
 6693:	  1AA3			NMARK_L:
 6694:				;
 6695:				;****** continue with original code: *****************************************
 6696:				;
 6697:	  1AA3	FE			MOV	R6,A		;SAVE IT FOR LATER
 6698:					;
 6699:					; Unpack and load R0
 6700:					;
 6701:	  1AA4	71 8B			ACALL	UNPACK_R0
 6702:					;
 6703:					; Now set up for loop multiply
 6704:					;
 6705:	  1AA6	7B 04			MOV	R3,#DIGIT
 6706:	  1AA8	AC 01			MOV	R4,R1B0
 6707:					;
 6708:					; Now, do the multiply and accumulate the product
 6709:					;
 6710:	  1AAA	8C 01		FMUL3:	MOV	R1B0,R4
 6711:	  1AAC	E3			MOVX	A,@R1
 6712:	  1AAD	FA			MOV	R2,A
 6713:	  1AAE	91 38			ACALL	MUL_NIBBLE
 6714:					;
 6715:	  1AB0	EA			MOV	A,R2
 6716:	  1AB1	C4			SWAP	A
 6717:	  1AB2	91 38			ACALL	MUL_NIBBLE
 6718:	  1AB4	1C			DEC	R4
 6719:	  1AB5	DB F3			DJNZ	R3,FMUL3
 6720:					;
 6721:					; Now, pack and restore the sign
 6722:					;
 6723:	  1AB7	8E 30			MOV	FP_EXP,R6
 6724:	  1AB9	8D 2F			MOV	FP_SIGN,R5
 6725:	  1ABB	61 1E			AJMP	PACK		;FINISH IT OFF
 6726:					;
 6727:					;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
 6728:					;
 6729:	  1ABD			FLOATING_DIV:
 6730:					;
 6731:					;DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
 6732:					;
 6733:	  1ABD	91 77			ACALL	MDES1
 6734:					;
 6735:					; Check the exponents
 6736:					;
 6737:	  1ABF	8D 2F			MOV	FP_SIGN,R5	;SAVE THE SIGN
 6738:	  1AC1	BF 00 06		CJNE	R7,#0,DIV0	;CLEARS THE CARRY
 6739:	  1AC4	71 A1			ACALL	OVERFLOW_AND_EXIT
 6740:	  1AC6	E4			CLR	A
 6741:	  1AC7	D2 E3			SETB	ACC.ZERO_DIVIDE
 6742:	  1AC9	22			RET
 6743:					;
 6744:	  1ACA	EE		DIV0:	MOV	A,R6		;GET EXPONENT
 6745:	  1ACB	60 B8			JZ	FMUL0		;EXIT IF ZERO
 6746:	  1ACD	9F			SUBB	A,R7		;DELTA EXPONENT
 6747:	  1ACE	20 E7 04		JB	ACC.7,D_UNDER
 6748:	  1AD1	50 04			JNC	DIV3
 6749:	  1AD3	61 B2			AJMP	UNDERFLOW_AND_EXIT
 6750:					;
 6751:	  1AD5	50 C0		D_UNDER:JNC	FOV
 6752:					;
 6753:	  1AD7	24 81		DIV3:	ADD	A,#129		;CORRECTLY BIAS THE EXPONENT
 6754:	  1AD9	F5 30			MOV	FP_EXP,A	;SAVE THE EXPONENT
 6755:	  1ADB	91 88			ACALL	LOADR1_MANTISSA ;LOAD THE DIVIDED
 6756:					;
 6757:	  1ADD	7A 34			MOV	R2,#FP_ACCC	;SAVE LOCATION
 6758:	  1ADF	AB 00			MOV	R3,R0B0 	;SAVE POINTER IN R3
 6759:	  1AE1	75 2A 00		MOV	FP_CARRY,#0	;ZERO CARRY BYTE
 6760:					;
 6761:	  1AE4	7D FF		DIV4:	MOV	R5,#0FFH	;LOOP COUNT
 6762:	  1AE6	D3			SETB	C
 6763:					;
 6764:	  1AE7	8B 00		DIV5:	MOV	R0B0,R3 	;RESTORE THE EXTERNAL POINTER
 6765:	  1AE9	79 2E			MOV	R1,#FP_DIG78	;SET UP INTERNAL POINTER
 6766:	  1AEB	7F 04			MOV	R7,#DIGIT	;LOOP COUNT
 6767:	  1AED	50 17			JNC	DIV7		;EXIT IF NO CARRY
 6768:					;
 6769:	  1AEF	E2		DIV6:	MOVX	A,@R0		;DO ACCUMLATION
 6770:	  1AF0	FE			MOV	R6,A
 6771:	  1AF1	E4			CLR	A
 6772:	  1AF2	34 99			ADDC	A,#99H
 6773:	  1AF4	9E			SUBB	A,R6
 6774:	  1AF5	27			ADD	A,@R1
 6775:	  1AF6	D4			DA	A
 6776:	  1AF7	F7			MOV	@R1,A
 6777:	  1AF8	18			DEC	R0
 6778:	  1AF9	19			DEC	R1
 6779:	  1AFA	DF F3			DJNZ	R7,DIV6 	;LOOP
 6780:					;
 6781:	  1AFC	0D			INC	R5		;SUBTRACT COUNTER
 6782:	  1AFD	40 E8			JC	DIV5		;KEEP LOOPING IF CARRY
 6783:	  1AFF	E7			MOV	A,@R1		;GET CARRY
 6784:	  1B00	94 01			SUBB	A,#1		;CARRY IS CLEARED
 6785:	  1B02	F7			MOV	@R1,A		;SAVE CARRY DIGIT
 6786:	  1B03	B3			CPL	C
 6787:	  1B04	80 E1			SJMP	DIV5		;LOOP
 6788:					;
 6789:					; Restore the result if carry was found
 6790:					;
 6791:	  1B06	31 FF		DIV7:	ACALL	ADDLP		;ADD NUMBER BACK
 6792:	  1B08	77 00			MOV	@R1,#0		;CLEAR CARRY
 6793:	  1B0A	8A 00			MOV	R0B0,R2 	;GET SAVE COUNTER
 6794:	  1B0C	A6 05			MOV	@R0,5		;SAVE COUNT BYTE
 6795:					;
 6796:	  1B0E	0A			INC	R2		;ADJUST SAVE COUNTER
 6797:	  1B0F	7F 01			MOV	R7,#1		;BUMP DIVIDEND
 6798:	  1B11	91 00			ACALL	LEFT
 6799:	  1B13	BA 3E CE		CJNE	R2,#FP_ACC8+2,DIV4
 6800:					;
 6801:	  1B16	D5 30 02		DJNZ	FP_EXP,DIV8
 6802:	  1B19	61 B2			AJMP	UNDERFLOW_AND_EXIT
 6803:					;
 6804:	  1B1B	75 2A 00	DIV8:	MOV	FP_CARRY,#0
 6805:					;
 6806:					;***************************************************************
 6807:					;
 6808:	  1B1E			PACK:	; Pack the mantissa
 6809:					;
 6810:					;***************************************************************
 6811:					;
 6812:					; First, set up the pointers
 6813:					;
 6814:	  1B1E	78 34			MOV	R0,#FP_ACCC
 6815:	  1B20	E6			MOV	A,@R0		;GET FP_ACCC
 6816:	  1B21	FE			MOV	R6,A		;SAVE FOR ZERO COUNT
 6817:	  1B22	60 03			JZ	PACK0		;JUMP OVER IF ZERO
 6818:	  1B24	71 7F			ACALL	INC_FP_EXP	;BUMP THE EXPONENT
 6819:	  1B26	18			DEC	R0
 6820:					;
 6821:	  1B27	08		PACK0:	INC	R0		;POINT AT FP_ACC1
 6822:					;
 6823:	  1B28	74 08		PACK1:	MOV	A,#8		;ADJUST NIBBLE POINTER
 6824:	  1B2A	F9			MOV	R1,A
 6825:	  1B2B	28			ADD	A,R0
 6826:	  1B2C	F8			MOV	R0,A
 6827:	  1B2D	B6 05 00		CJNE	@R0,#5,PACK11	;SEE IF ADJUSTING NEEDED
 6828:	  1B30	40 13		PACK11: JC	PACK31
 6829:					;
 6830:	  1B32	D3		PACK2:	SETB	C
 6831:	  1B33	E4			CLR	A
 6832:	  1B34	18			DEC	R0
 6833:	  1B35	36			ADDC	A,@R0
 6834:	  1B36	D4			DA	A
 6835:	  1B37	D6			XCHD	A,@R0		;SAVE THE VALUE
 6836:	  1B38	30 E4 09		JNB	ACC.4,PACK3
 6837:	  1B3B	D9 F5			DJNZ	R1,PACK2
 6838:					;
 6839:	  1B3D	18			DEC	R0
 6840:	  1B3E	76 01			MOV	@R0,#1
 6841:	  1B40	71 7F			ACALL	INC_FP_EXP
 6842:	  1B42	80 18			SJMP	PACK4
 6843:					;
 6844:	  1B44	19		PACK3:	DEC	R1
 6845:	  1B45	E9		PACK31: MOV	A,R1
 6846:	  1B46	C3			CLR	C
 6847:	  1B47	C8			XCH	A,R0
 6848:	  1B48	98			SUBB	A,R0
 6849:	  1B49	F8			MOV	R0,A
 6850:				;
 6851:				;*****************************************************************************
 6852:				;****** Wulf 1 Bugfix 2 ******************************************************
 6853:				;****** Multiplication Error, found by D. Wulf *******************************
 6854:				;
 6855:	  1B4A	30 28 0F		jnb	mul_underflow,PACK4
 6856:	  1B4D	C2 28			clr	mul_underflow
 6857:	  1B4F	E5 30			mov	A,FP_EXP	;test of exceeding in limit case
 6858:	  1B51	60 07			jz	UNDER_MD	;message about underflow
 6859:	  1B53	F4			cpl	a		;test of exceeding in limit case
 6860:	  1B54	60 04			jz	UNDER_MD	;message about underflow
 6861:	  1B56	F4			cpl	a		;restore original exp
 6862:	  1B57	B4 01 02		cjne	a,#1,pack4	;jump if not outer limit
 6863:	  1B5A			UNDER_MD:
 6864:	  1B5A	61 B2			ajmp	UNDERFLOW_AND_EXIT
 6865:				;
 6866:				;****** continue with original code: *****************************************
 6867:				;
 6868:	  1B5C	79 2B		PACK4:	MOV	R1,#FP_DIG12
 6869:					;
 6870:					; Now, pack
 6871:					;
 6872:	  1B5E	E6		PLOOP:	MOV	A,@R0
 6873:	  1B5F	C4			SWAP	A		;FLIP THE DIGITS
 6874:	  1B60	08			INC	R0
 6875:	  1B61	D6			XCHD	A,@R0
 6876:	  1B62	42 06			ORL	6,A		;ACCUMULATE THE OR'ED DIGITS
 6877:	  1B64	F7			MOV	@R1,A
 6878:	  1B65	08			INC	R0
 6879:	  1B66	09			INC	R1
 6880:	  1B67	B9 2F F4		CJNE	R1,#FP_SIGN,PLOOP
 6881:	  1B6A	EE			MOV	A,R6
 6882:	  1B6B	70 03			JNZ	STORE_ALIGN_TEST_AND_EXIT
 6883:	  1B6D	75 30 00		MOV	FP_EXP,#0	;ZERO EXPONENT
 6884:					;
 6885:					;**************************************************************
 6886:					;
 6887:	  1B70			STORE_ALIGN_TEST_AND_EXIT:	;Save the number align carry and exit
 6888:					;
 6889:					;**************************************************************
 6890:					;
 6891:	  1B70	91 6B			ACALL	LOAD_POINTERS
 6892:	  1B72	89 09			MOV	ARG_STACK,R1	;SET UP THE NEW STACK
 6893:	  1B74	78 30			MOV	R0,#FP_EXP
 6894:					;
 6895:					; Now load the numbers
 6896:					;
 6897:	  1B76	E6		STORE2: MOV	A,@R0
 6898:	  1B77	F3			MOVX	@R1,A		;SAVE THE NUMBER
 6899:	  1B78	18			DEC	R0
 6900:	  1B79	19			DEC	R1
 6901:	  1B7A	B8 2A F9		CJNE	R0,#FP_CARRY,STORE2
 6902:					;
 6903:	  1B7D	E4			CLR	A		;NO ERRORS
 6904:					;
 6905:	  1B7E	22		PRET:	RET			;EXIT
 6906:					;
 6907:	  1B7F			INC_FP_EXP:
 6908:					;
 6909:	  1B7F	05 30			INC	FP_EXP
 6910:	  1B81	E5 30			MOV	A,FP_EXP
 6911:	  1B83	70 F9			JNZ	PRET		;EXIT IF NOT ZERO
 6912:	  1B85	D0 E0			POP	ACC		;WASTE THE CALLING STACK
 6913:	  1B87	D0 E0			POP	ACC
 6914:	  1B89	61 A1			AJMP	OVERFLOW_AND_EXIT
 6915:				;
 6916:				;***********************************************************************
 6917:				;
 6918:	  1B8B			UNPACK_R0:	; Unpack BCD digits and load into nibble locations
 6919:				;
 6920:				;***********************************************************************
 6921:					;
 6922:	  1B8B	C0 01			PUSH	R1B0
 6923:	  1B8D	79 32			MOV	R1,#FP_NIB8
 6924:					;
 6925:	  1B8F	E2		ULOOP:	MOVX	A,@R0
 6926:	  1B90	54 0F			ANL	A,#0FH
 6927:	  1B92	F7			MOV	@R1,A		;SAVE THE NIBBLE
 6928:	  1B93	E2			MOVX	A,@R0
 6929:	  1B94	C4			SWAP	A
 6930:	  1B95	54 0F			ANL	A,#0FH
 6931:	  1B97	19			DEC	R1
 6932:	  1B98	F7			MOV	@R1,A		;SAVE THE NIBBLE AGAIN
 6933:	  1B99	18			DEC	R0
 6934:	  1B9A	19			DEC	R1
 6935:	  1B9B	B9 2A F1		CJNE	R1,#FP_NIB1-1,ULOOP
 6936:					;
 6937:	  1B9E	D0 01			POP	R1B0
 6938:					;
 6939:	  1BA0	22		LOAD7:	RET
 6940:					;
 6941:					;**************************************************************
 6942:					;
 6943:	  1BA1			OVERFLOW_AND_EXIT:	;LOAD 99999999 E+127,  SET OV BIT, AND EXIT
 6944:					;
 6945:					;**************************************************************
 6946:					;
 6947:	  1BA1	78 2E			MOV	R0,#FP_DIG78
 6948:	  1BA3	74 99			MOV	A,#99H
 6949:					;
 6950:	  1BA5	F6		OVE1:	MOV	@R0,A
 6951:	  1BA6	18			DEC	R0
 6952:	  1BA7	B8 2A FB		CJNE	R0,#FP_CARRY,OVE1
 6953:					;
 6954:	  1BAA	75 30 FF		MOV	FP_EXP,#0FFH
 6955:	  1BAD	71 70			ACALL	STORE_ALIGN_TEST_AND_EXIT
 6956:					;
 6957:	  1BAF	D2 E1			SETB	ACC.OVERFLOW
 6958:	  1BB1	22			RET
 6959:					;
 6960:					;**************************************************************
 6961:					;
 6962:	  1BB2			UNDERFLOW_AND_EXIT:	;LOAD 0, SET UF BIT, AND EXIT
 6963:					;
 6964:					;**************************************************************
 6965:					;
 6966:	  1BB2	71 B8			ACALL	ZERO_AND_EXIT
 6967:	  1BB4	E4			CLR	A
 6968:	  1BB5	D2 E0			SETB	ACC.UNDERFLOW
 6969:	  1BB7	22			RET
 6970:					;
 6971:					;**************************************************************
 6972:					;
 6973:	  1BB8			ZERO_AND_EXIT:		;LOAD 0, SET ZERO BIT, AND EXIT
 6974:					;
 6975:					;**************************************************************
 6976:					;
 6977:	  1BB8	71 BF			ACALL	FP_CLEAR
 6978:	  1BBA	71 70			ACALL	STORE_ALIGN_TEST_AND_EXIT
 6979:	  1BBC	D2 E2			SETB	ACC.ZERO
 6980:	  1BBE	22			RET			;EXIT
 6981:					;
 6982:					;**************************************************************
 6983:					;
 6984:	  1BBF			FP_CLEAR:
 6985:					;
 6986:					; Clear internal storage
 6987:					;
 6988:					;**************************************************************
 6989:					;
 6990:	  1BBF	E4			CLR	A
 6991:	  1BC0	78 3D			MOV	R0,#FP_ACC8+1
 6992:					;
 6993:	  1BC2	F6		FPC1:	MOV	@R0,A
 6994:	  1BC3	18			DEC	R0
 6995:	  1BC4	B8 29 FB		CJNE	R0,#FP_TEMP,FPC1
 6996:	  1BC7	22			RET
 6997:					;
 6998:					;**************************************************************
 6999:					;
 7000:	  1BC8			RIGHT:	; Shift ACCUMULATOR RIGHT the number of nibbles in R7
 7001:					; Save the shifted values in R4 if SAVE_ROUND is set
 7002:					;
 7003:					;**************************************************************
 7004:					;
 7005:	  1BC8	7C 00			MOV	R4,#0		;IN CASE OF NO SHIFT
 7006:					;
 7007:	  1BCA	C3		RIGHT1: CLR	C
 7008:	  1BCB	EF		RIGHT2: MOV	A,R7		;GET THE DIGITS TO SHIFT
 7009:	  1BCC	60 22			JZ	RIGHTL1 	;EXIT IF ZERO
 7010:	  1BCE	94 02			SUBB	A,#2		;TWO TO DO?
 7011:	  1BD0	50 1F			JNC	RIGHT5		;SHIFT TWO NIBBLES
 7012:					;
 7013:					; Swap one nibble then exit
 7014:					;
 7015:	  1BD2	C0 00		RIGHT3: PUSH	R0B0		;SAVE POINTER REGISTER
 7016:	  1BD4	C0 01			PUSH	R1B0
 7017:					;
 7018:	  1BD6	79 2E			MOV	R1,#FP_DIG78	;LOAD THE POINTERS
 7019:	  1BD8	78 2D			MOV	R0,#FP_DIG56
 7020:	  1BDA	EC			MOV	A,R4		;GET THE OVERFLOW REGISTER
 7021:	  1BDB	D7			XCHD	A,@R1		;GET DIGIT 8
 7022:	  1BDC	C4			SWAP	A		;FLIP FOR LOAD
 7023:	  1BDD	FC			MOV	R4,A
 7024:					;
 7025:	  1BDE	E7		RIGHTL: MOV	A,@R1		;GET THE LOW ORDER BYTE
 7026:	  1BDF	D6			XCHD	A,@R0		;SWAP NIBBLES
 7027:	  1BE0	C4			SWAP	A		;FLIP FOR STORE
 7028:	  1BE1	F7			MOV	@R1,A		;SAVE THE DIGITS
 7029:	  1BE2	18			DEC	R0		;BUMP THE POINTERS
 7030:	  1BE3	19			DEC	R1
 7031:	  1BE4	B9 2A F7		CJNE	R1,#FP_DIG12-1,RIGHTL	;LOOP
 7032:					;
 7033:	  1BE7	E7			MOV	A,@R1		;ACC = CH8
 7034:	  1BE8	C4			SWAP	A		;ACC = 8CH
 7035:	  1BE9	54 0F			ANL	A,#0FH		;ACC = 0CH
 7036:	  1BEB	F7			MOV	@R1,A		;CARRY DONE
 7037:	  1BEC	D0 01			POP	R1B0		;EXIT
 7038:	  1BEE	D0 00			POP	R0B0		;RESTORE REGISTER
 7039:	  1BF0	22		RIGHTL1:RET
 7040:					;
 7041:	  1BF1	FF		RIGHT5: MOV	R7,A		;SAVE THE NEW SHIFT NUMBER
 7042:	  1BF2	E4			CLR	A
 7043:	  1BF3	C5 2A			XCH	A,FP_CARRY	;SWAP THE NIBBLES
 7044:	  1BF5	C5 2B			XCH	A,FP_DIG12
 7045:	  1BF7	C5 2C			XCH	A,FP_DIG34
 7046:	  1BF9	C5 2D			XCH	A,FP_DIG56
 7047:	  1BFB	C5 2E			XCH	A,FP_DIG78
 7048:	  1BFD	FC			MOV	R4,A		;SAVE THE LAST DIGIT SHIFTED
 7049:	  1BFE	80 CB			SJMP	RIGHT2
 7050:					;
 7051:					;***************************************************************
 7052:					;
 7053:	  1C00			LEFT:	; Shift ACCUMULATOR LEFT the number of nibbles in R7
 7054:					;
 7055:					;***************************************************************
 7056:					;
 7057:	  1C00	7C 00			MOV	R4,#00H 	;CLEAR FOR SOME ENTRYS
 7058:					;
 7059:	  1C02	C3		LEFT1:	CLR	C
 7060:	  1C03	EF		LEFT2:	MOV	A,R7		;GET SHIFT VALUE
 7061:	  1C04	60 22			JZ	LEFTL1		;EXIT IF ZERO
 7062:	  1C06	94 02			SUBB	A,#2		;SEE HOW MANY BYTES TO SHIFT
 7063:	  1C08	50 1F			JNC	LEFT5
 7064:					;
 7065:	  1C0A	C0 00		LEFT3:	PUSH	R0B0		;SAVE POINTER
 7066:	  1C0C	C0 01			PUSH	R1B0
 7067:	  1C0E	78 2A			MOV	R0,#FP_CARRY
 7068:	  1C10	79 2B			MOV	R1,#FP_DIG12
 7069:					;
 7070:	  1C12	E6			MOV	A,@R0		;ACC=CHCL
 7071:	  1C13	C4			SWAP	A		;ACC = CLCH
 7072:	  1C14	F6			MOV	@R0,A		;ACC = CLCH, @R0 = CLCH
 7073:					;
 7074:	  1C15	E7		LEFTL:	MOV	A,@R1		;DIG 12
 7075:	  1C16	C4			SWAP	A		;DIG 21
 7076:	  1C17	D6			XCHD	A,@R0
 7077:	  1C18	F7			MOV	@R1,A		;SAVE IT
 7078:	  1C19	08			INC	R0		;BUMP POINTERS
 7079:	  1C1A	09			INC	R1
 7080:	  1C1B	B8 2E F7		CJNE	R0,#FP_DIG78,LEFTL
 7081:					;
 7082:	  1C1E	EC			MOV	A,R4
 7083:	  1C1F	C4			SWAP	A
 7084:	  1C20	D6			XCHD	A,@R0
 7085:	  1C21	54 F0			ANL	A,#0F0H
 7086:	  1C23	FC			MOV	R4,A
 7087:					;
 7088:	  1C24	D0 01			POP	R1B0
 7089:	  1C26	D0 00			POP	R0B0		;RESTORE
 7090:	  1C28	22		LEFTL1: RET			;DONE
 7091:					;
 7092:	  1C29	FF		LEFT5:	MOV	R7,A		;RESTORE COUNT
 7093:	  1C2A	E4			CLR	A
 7094:	  1C2B	CC			XCH	A,R4		;GET THE RESTORATION BYTE
 7095:	  1C2C	C5 2E			XCH	A,FP_DIG78	;DO THE SWAP
 7096:	  1C2E	C5 2D			XCH	A,FP_DIG56
 7097:	  1C30	C5 2C			XCH	A,FP_DIG34
 7098:	  1C32	C5 2B			XCH	A,FP_DIG12
 7099:	  1C34	C5 2A			XCH	A,FP_CARRY
 7100:	  1C36	80 CB			SJMP	LEFT2
 7101:					;
 7102:	  1C38			MUL_NIBBLE:
 7103:					;
 7104:					; Multiply the nibble in R7 by the FP_NIB locations
 7105:					; accumulate the product in FP_ACC
 7106:					;
 7107:					; Set up the pointers for multiplication
 7108:					;
 7109:	  1C38	54 0F			ANL	A,#0FH		;STRIP OFF MS NIBBLE
 7110:	  1C3A	FF			MOV	R7,A
 7111:	  1C3B	78 3C			MOV	R0,#FP_ACC8
 7112:	  1C3D	79 32			MOV	R1,#FP_NIB8
 7113:	  1C3F	E4			CLR	A
 7114:	  1C40	F5 33			MOV	FP_ACCX,A
 7115:					;
 7116:	  1C42	18		MNLOOP: DEC	R0		;BUMP POINTER TO PROPAGATE CARRY
 7117:	  1C43	26			ADD	A,@R0		;ATTEMPT TO FORCE CARRY
 7118:	  1C44	D4			DA	A		;BCD ADJUST
 7119:	  1C45	30 E4 03		JNB	ACC.4,MNL0	;DON'T ADJUST IF NO NEED
 7120:	  1C48	18			DEC	R0		;PROPAGATE CARRY TO THE NEXT DIGIT
 7121:	  1C49	06			INC	@R0		;DO THE ADJUSTING
 7122:	  1C4A	08			INC	R0		;RESTORE R0
 7123:					;
 7124:	  1C4B	D6		MNL0:	XCHD	A,@R0		;RESTORE INITIAL NUMBER
 7125:	  1C4C	8F F0			MOV	B,R7		;GET THE NUBBLE TO MULTIPLY
 7126:	  1C4E	E7			MOV	A,@R1		;GET THE OTHER NIBBLE
 7127:	  1C4F	A4			MUL	AB		;DO THE MULTIPLY
 7128:	  1C50	75 F0 0A		MOV	B,#10		;NOW BCD ADJUST
 7129:	  1C53	84			DIV	AB
 7130:	  1C54	C5 F0			XCH	A,B		;GET THE REMAINDER
 7131:	  1C56	26			ADD	A,@R0		;PROPAGATE THE PARTIAL PRODUCTS
 7132:	  1C57	D4			DA	A		;BCD ADJUST
 7133:	  1C58	30 E4 02		JNB	ACC.4,MNL1	;PROPAGATE PARTIAL PRODUCT CARRY
 7134:	  1C5B	05 F0			INC	B
 7135:					;
 7136:	  1C5D	08		MNL1:	INC	R0
 7137:	  1C5E	D6			XCHD	A,@R0		;SAVE THE NEW PRODUCT
 7138:	  1C5F	18			DEC	R0
 7139:	  1C60	E5 F0			MOV	A,B		;GET BACK THE QUOTIENT
 7140:	  1C62	19			DEC	R1
 7141:	  1C63	B9 2A DC		CJNE	R1,#FP_NIB1-1,MNLOOP
 7142:					;
 7143:	  1C66	25 33			ADD	A,FP_ACCX	;GET THE OVERFLOW
 7144:	  1C68	D4			DA	A		;ADJUST
 7145:	  1C69	F6			MOV	@R0,A		;SAVE IT
 7146:	  1C6A	22			RET			;EXIT
 7147:					;
 7148:					;***************************************************************
 7149:					;
 7150:	  1C6B			LOAD_POINTERS:	; Load the ARG_STACK into R0 and bump R1
 7151:					;
 7152:					;***************************************************************
 7153:					;
 7154:	  1C6B	75 A0 01		MOV	P2,#ARG_STACK_PAGE
 7155:	  1C6E	A8 09			MOV	R0,ARG_STACK
 7156:	  1C70	74 06			MOV	A,#FP_NUMBER_SIZE
 7157:	  1C72	28			ADD	A,R0
 7158:	  1C73	F9			MOV	R1,A
 7159:	  1C74	22			RET
 7160:					;
 7161:					;***************************************************************
 7162:					;
 7163:	  1C75			MUL_DIV_EXP_AND_SIGN:
 7164:					;
 7165:					; Load the sign into R7, R6. R5 gets the sign for
 7166:					; multiply and divide.
 7167:					;
 7168:					;***************************************************************
 7169:					;
 7170:	  1C75	71 BF			ACALL	FP_CLEAR	;CLEAR INTERNAL MEMORY
 7171:					;
 7172:	  1C77	91 6B		MDES1:	ACALL	LOAD_POINTERS	;LOAD REGISTERS
 7173:	  1C79	E2			MOVX	A,@R0		;ARG 1 EXP
 7174:	  1C7A	FF			MOV	R7,A		;SAVED IN R7
 7175:	  1C7B	E3			MOVX	A,@R1		;ARG 2 EXP
 7176:	  1C7C	FE			MOV	R6,A		;SAVED IN R6
 7177:	  1C7D	18			DEC	R0		;BUMP POINTERS TO SIGN
 7178:	  1C7E	19			DEC	R1
 7179:	  1C7F	E2			MOVX	A,@R0		;GET THE SIGN
 7180:	  1C80	FC			MOV	R4,A		;SIGN OF ARG1
 7181:	  1C81	E3			MOVX	A,@R1		;GET SIGN OF NEXT ARG
 7182:	  1C82	FB			MOV	R3,A		;SIGN OF ARG2
 7183:	  1C83	6C			XRL	A,R4		;ACC GETS THE NEW SIGN
 7184:	  1C84	FD			MOV	R5,A		;R5 GETS THE NEW SIGN
 7185:					;
 7186:					; Bump the pointers to point at the LS digit
 7187:					;
 7188:	  1C85	18			DEC	R0
 7189:	  1C86	19			DEC	R1
 7190:					;
 7191:	  1C87	22			RET
 7192:					;
 7193:					;***************************************************************
 7194:					;
 7195:	  1C88			LOADR1_MANTISSA:
 7196:					;
 7197:					; Load the mantissa of R0 into FP_Digits
 7198:					;
 7199:					;***************************************************************
 7200:					;
 7201:	  1C88	C0 00			PUSH	R0B0		;SAVE REGISTER 1
 7202:	  1C8A	78 2E			MOV	R0,#FP_DIG78	;SET UP THE POINTER
 7203:					;
 7204:	  1C8C	E3		LOADR1: MOVX	A,@R1
 7205:	  1C8D	F6			MOV	@R0,A
 7206:	  1C8E	19			DEC	R1
 7207:	  1C8F	18			DEC	R0
 7208:	  1C90	B8 2A F9		CJNE	R0,#FP_CARRY,LOADR1
 7209:					;
 7210:	  1C93	D0 00			POP	R0B0
 7211:	  1C95	22			RET
 7212:					;
 7213:					;***************************************************************
 7214:					;
 7215:	  1C96			HEXSCAN:	; Scan a string to determine if it is a hex number
 7216:						; set carry if hex, else carry = 0
 7217:					;
 7218:					;***************************************************************
 7219:					;
 7220:	  1C96	B1 6C			ACALL	GET_DPTR_CHARACTER
 7221:	  1C98	C0 83			PUSH	DPH
 7222:	  1C9A	C0 82			PUSH	DPL		;SAVE THE POINTER
 7223:					;
 7224:	  1C9C	E0		HEXSC1: MOVX	A,@DPTR 	;GET THE CHARACTER
 7225:	  1C9D	F1 ED			ACALL	DIGIT_CHECK	;SEE IF A DIGIT
 7226:	  1C9F	40 12			JC	HS1		;CONTINUE IF A DIGIT
 7227:	  1CA1	91 B6			ACALL	HEX_CHECK	;SEE IF HEX
 7228:	  1CA3	40 0E			JC	HS1
 7229:					;
 7230:	  1CA5	C2 E5			CLR	ACC.5		;NO LOWER CASE
 7231:	  1CA7	B4 48 03		CJNE	A,#'H',HEXDON
 7232:	  1CAA	D3			SETB	C
 7233:	  1CAB	80 01			SJMP	HEXDO1		;NUMBER IS VALID HEX, MAYBE
 7234:					;
 7235:	  1CAD	C3		HEXDON: CLR	C
 7236:					;
 7237:	  1CAE	D0 82		HEXDO1: POP	DPL		;RESTORE POINTER
 7238:	  1CB0	D0 83			POP	DPH
 7239:	  1CB2	22			RET
 7240:					;
 7241:	  1CB3	A3		HS1:	INC	DPTR		;BUMP TO NEXT CHARACTER
 7242:	  1CB4	80 E6			SJMP	HEXSC1		;LOOP
 7243:					;
 7244:	  1CB6			HEX_CHECK:	;CHECK FOR A VALID ASCII HEX, SET CARRY IF FOUND
 7245:					;
 7246:	  1CB6	C2 E5			CLR	ACC.5		;WASTE LOWER CASE
 7247:	  1CB8	B4 47 00		CJNE	A,#'F'+1,HEX_CHECK1     ;SEE IF F OR LESS
 7248:	  1CBB			HEX_CHECK1:
 7249:	  1CBB	40 01			JC	HC1
 7250:	  1CBD	22			RET
 7251:					;
 7252:	  1CBE	B4 41 00	HC1:	CJNE	A,#'A',HC11     ;SEE IF A OR GREATER
 7253:	  1CC1	B3		HC11:	CPL	C
 7254:	  1CC2	22			RET
 7255:					;
 7256:	  1CC3			PUSHR2R0:
 7257:					;
 7258:	  1CC3	7B 00			MOV	R3,#HIGH CONVERT;CONVERSION LOCATION
 7259:	  1CC5	79 58			MOV	R1,#LOW CONVERT
 7260:	  1CC7	F1 04			ACALL	CONVERT_BINARY_TO_ASCII_STRING
 7261:	  1CC9	74 0D			MOV	A,#0DH		;A CR TO TERMINATE
 7262:	  1CCB	F3			MOVX	@R1,A		;SAVE THE CR
 7263:	  1CCC	90 00 58		MOV	DPTR,#CONVERT
 7264:					;
 7265:					; Falls thru to FLOATING INPUT
 7266:					;
 7267:					;***************************************************************
 7268:					;
 7269:	  1CCF			FLOATING_POINT_INPUT:	; Input a floating point number pointed to by
 7270:							; the DPTR
 7271:					;
 7272:					;***************************************************************
 7273:					;
 7274:	  1CCF	71 BF			ACALL	FP_CLEAR	;CLEAR EVERYTHING
 7275:	  1CD1	B1 6C			ACALL	GET_DPTR_CHARACTER
 7276:	  1CD3	B1 72			ACALL	PLUS_MINUS_TEST
 7277:	  1CD5	92 78			MOV	MSIGN,C 	;SAVE THE MANTISSA SIGN
 7278:					;
 7279:					; Now, set up for input loop
 7280:					;
 7281:	  1CD7	78 34			MOV	R0,#FP_ACCC
 7282:	  1CD9	7E 7F			MOV	R6,#7FH 	;BASE EXPONENT
 7283:	  1CDB	D2 D5			SETB	F0		;SET INITIAL FLAG
 7284:					;
 7285:	  1CDD	F1 EB		INLOOP: ACALL	GET_DIGIT_CHECK
 7286:	  1CDF	50 07			JNC	GTEST		;IF NOT A CHARACTER, WHAT IS IT?
 7287:	  1CE1	54 0F			ANL	A,#0FH		;STRIP ASCII
 7288:	  1CE3	B1 45			ACALL	STDIG		;STORE THE DIGITS
 7289:					;
 7290:	  1CE5	A3		INLPIK: INC	DPTR		;BUMP POINTER FOR LOOP
 7291:	  1CE6	80 F5			SJMP	INLOOP		;LOOP FOR INPUT
 7292:					;
 7293:	  1CE8	B4 2E 0C	GTEST:	CJNE	A,#'.',GT1      ;SEE IF A RADIX
 7294:	  1CEB	20 51 63		JB	FOUND_RADIX,INERR
 7295:	  1CEE	D2 51			SETB	FOUND_RADIX
 7296:	  1CF0	B8 34 F2		CJNE	R0,#FP_ACCC,INLPIK
 7297:	  1CF3	D2 52			SETB	FIRST_RADIX	;SET IF FIRST RADIX
 7298:	  1CF5	80 EE			SJMP	INLPIK		;GET ADDITIONAL DIGITS
 7299:					;
 7300:	  1CF7	20 D5 57	GT1:	JB	F0,INERR	;ERROR IF NOT CLEARED
 7301:	  1CFA	B4 65 02		CJNE	A,#'e',GT11     ;CHECK FOR LOWER CASE
 7302:	  1CFD	80 03			SJMP	GT12
 7303:	  1CFF	B4 45 33	GT11:	CJNE	A,#'E',FINISH_UP
 7304:	  1D02	B1 6B		GT12:	ACALL	INC_AND_GET_DPTR_CHARACTER
 7305:	  1D04	B1 72			ACALL	PLUS_MINUS_TEST
 7306:	  1D06	92 50			MOV	XSIGN,C 	;SAVE SIGN STATUS
 7307:	  1D08	F1 EB			ACALL	GET_DIGIT_CHECK
 7308:	  1D0A	50 45			JNC	INERR
 7309:					;
 7310:	  1D0C	54 0F			ANL	A,#0FH		;STRIP ASCII BIAS OFF THE CHARACTER
 7311:	  1D0E	FD			MOV	R5,A		;SAVE THE CHARACTER IN R5
 7312:					;
 7313:	  1D0F	A3		GT2:	INC	DPTR
 7314:	  1D10	F1 EB			ACALL	GET_DIGIT_CHECK
 7315:	  1D12	50 0D			JNC	FINISH1
 7316:	  1D14	54 0F			ANL	A,#0FH		;STRIP OFF BIAS
 7317:	  1D16	CD			XCH	A,R5		;GET THE LAST DIGIT
 7318:	  1D17	75 F0 0A		MOV	B,#10		;MULTIPLY BY TEN
 7319:	  1D1A	A4			MUL	AB
 7320:	  1D1B	2D			ADD	A,R5		;ADD TO ORIGINAL VALUE
 7321:	  1D1C	FD			MOV	R5,A		;SAVE IN R5
 7322:	  1D1D	50 F0			JNC	GT2		;LOOP IF NO CARRY
 7323:	  1D1F	7D FF			MOV	R5,#0FFH	;FORCE AN ERROR
 7324:					;
 7325:	  1D21	ED		FINISH1:MOV	A,R5		;GET THE SIGN
 7326:	  1D22	30 50 09		JNB	XSIGN,POSNUM	;SEE IF EXPONENT IS POS OR NEG
 7327:	  1D25	C3			CLR	C
 7328:	  1D26	9E			SUBB	A,R6
 7329:	  1D27	F4			CPL	A
 7330:	  1D28	04			INC	A
 7331:	  1D29	40 09			JC	FINISH2
 7332:	  1D2B	74 01			MOV	A,#01H
 7333:	  1D2D	22			RET
 7334:					;
 7335:	  1D2E	2E		POSNUM: ADD	A,R6		;ADD TO EXPONENT
 7336:	  1D2F	50 03			JNC	FINISH2
 7337:					;
 7338:	  1D31	74 02		POSNM1: MOV	A,#02H
 7339:	  1D33	22			RET
 7340:					;
 7341:	  1D34	CE		FINISH2:XCH	A,R6		;SAVE THE EXPONENT
 7342:					;
 7343:	  1D35			FINISH_UP:
 7344:					;
 7345:	  1D35	8E 30			MOV	FP_EXP,R6	;SAVE EXPONENT
 7346:	  1D37	B8 34 02		CJNE	R0,#FP_ACCC,FINISH_UP1
 7347:	  1D3A	71 BF			ACALL	FP_CLEAR	;CLEAR THE MEMORY IF 0
 7348:	  1D3C			FINISH_UP1:
 7349:	  1D3C	E5 09			MOV	A,ARG_STACK	;GET THE ARG STACK
 7350:	  1D3E	C3			CLR	C
 7351:	  1D3F	94 0C			SUBB	A,#FP_NUMBER_SIZE+FP_NUMBER_SIZE
 7352:	  1D41	F5 09			MOV	ARG_STACK,A	;ADJUST FOR STORE
 7353:	  1D43	61 1E			AJMP	PACK
 7354:					;
 7355:	  1D45	C2 D5		STDIG:	CLR	F0		;CLEAR INITIAL DESIGNATOR
 7356:	  1D47	70 0B			JNZ	STDIG1		;CONTINUE IF NOT ZERO
 7357:	  1D49	B8 34 08		CJNE	R0,#FP_ACCC,STDIG1
 7358:	  1D4C	30 52 04		JNB	FIRST_RADIX,RET_X
 7359:					;
 7360:	  1D4F	DE 02		DECX:	DJNZ	R6,RET_X
 7361:					;
 7362:	  1D51	74 FF		INERR:	MOV	A,#0FFH
 7363:					;
 7364:	  1D53	22		RET_X:	RET
 7365:					;
 7366:	  1D54	20 53 02	STDIG1: JB	DONE_LOAD,FRTEST
 7367:	  1D57	C2 52			CLR	FIRST_RADIX
 7368:					;
 7369:	  1D59	20 52 F3	FRTEST: JB	FIRST_RADIX,DECX
 7370:					;
 7371:	  1D5C	20 51 01	FDTEST: JB	FOUND_RADIX,FDT1
 7372:	  1D5F	0E			INC	R6
 7373:					;
 7374:	  1D60	20 53 F0	FDT1:	JB	DONE_LOAD,RET_X
 7375:	  1D63	B8 3D 02		CJNE	R0,#FP_ACC8+1,FDT2
 7376:	  1D66	D2 53			SETB	DONE_LOAD
 7377:					;
 7378:	  1D68	F6		FDT2:	MOV	@R0,A		;SAVE THE STRIPPED ACCUMULATOR
 7379:	  1D69	08			INC	R0		;BUMP THE POINTER
 7380:	  1D6A	22			RET			;EXIT
 7381:					;
 7382:					;***************************************************************
 7383:					;
 7384:					; I/O utilities
 7385:					;
 7386:					;***************************************************************
 7387:					;
 7388:	  1D6B			INC_AND_GET_DPTR_CHARACTER:
 7389:					;
 7390:	  1D6B	A3			INC	DPTR
 7391:					;
 7392:	  1D6C			GET_DPTR_CHARACTER:
 7393:					;
 7394:	  1D6C	E0			MOVX	A,@DPTR 	;GET THE CHARACTER
 7395:	  1D6D	B4 20 16		CJNE	A,#' ',PMT1     ;SEE IF A SPACE
 7396:					;
 7397:					; Kill spaces
 7398:					;
 7399:	  1D70	80 F9			SJMP	INC_AND_GET_DPTR_CHARACTER
 7400:					;
 7401:	  1D72			PLUS_MINUS_TEST:
 7402:					;
 7403:	  1D72	B4 E3 02		CJNE	A,#0E3H,PMT11	;SEE IF A PLUS, PLUS TOKEN FROM BASIC
 7404:	  1D75	80 0E			SJMP	PMT3
 7405:	  1D77	B4 2B 02	PMT11:	CJNE	A,#'+',PMT12
 7406:	  1D7A	80 09			SJMP	PMT3
 7407:	  1D7C	B4 E5 02	PMT12:	CJNE	A,#0E5H,PMT13	;SEE IF MINUS, MINUS TOKEN FROM BASIC
 7408:	  1D7F	80 03			SJMP	PMT2
 7409:	  1D81	B4 2D 02	PMT13:	CJNE	A,#'-',PMT1
 7410:					;
 7411:	  1D84	D3		PMT2:	SETB	C
 7412:					;
 7413:	  1D85	A3		PMT3:	INC	DPTR
 7414:					;
 7415:	  1D86	22		PMT1:	RET
 7416:					;
 7417:					;***************************************************************
 7418:					;
 7419:	  1D87			FLOATING_POINT_OUTPUT:	; Output the number, format is in location 23
 7420:					;
 7421:					; IF FORMAT = 00 - FREE FLOATING
 7422:					;	    = FX - EXPONENTIAL (X IS THE NUMBER OF SIG DIGITS)
 7423:					;	    = NX - N = NUM BEFORE RADIX, X = NUM AFTER RADIX
 7424:					;		   N + X = 8 MAX
 7425:					;
 7426:					;***************************************************************
 7427:					;
 7428:	  1D87	91 77			ACALL	MDES1		;GET THE NUMBER TO OUTPUT, R0 IS POINTER
 7429:	  1D89	31 B2			ACALL	POP_AND_EXIT	;OUTPUT POPS THE STACK
 7430:	  1D8B	EF			MOV	A,R7
 7431:	  1D8C	FE			MOV	R6,A		;PUT THE EXPONENT IN R6
 7432:	  1D8D	71 8B			ACALL	UNPACK_R0	;UNPACK THE NUMBER
 7433:	  1D8F	78 2B			MOV	R0,#FP_NIB1	;POINT AT THE NUMBER
 7434:	  1D91	E5 17			MOV	A,FORMAT	;GET THE FORMAT
 7435:	  1D93	FB			MOV	R3,A		;SAVE IN CASE OF EXP FORMAT
 7436:	  1D94	60 49			JZ	FREE		;FREE FLOATING?
 7437:	  1D96	B4 F0 00		CJNE	A,#0F0H,FPO1	;SEE IF EXPONENTIAL
 7438:	  1D99	50 73		FPO1:	JNC	EXPOUT
 7439:					;
 7440:					; If here, must be integer USING format
 7441:					;
 7442:	  1D9B	EE			MOV	A,R6		;GET THE EXPONENT
 7443:	  1D9C	70 02			JNZ	FPO2
 7444:	  1D9E	7E 80			MOV	R6,#80H
 7445:	  1DA0	EB		FPO2:	MOV	A,R3		;GET THE FORMAT
 7446:	  1DA1	C4			SWAP	A		;SPLIT INTEGER AND FRACTION
 7447:	  1DA2	54 0F			ANL	A,#0FH
 7448:	  1DA4	FA			MOV	R2,A		;SAVE INTEGER
 7449:	  1DA5	D1 74			ACALL	NUM_LT		;GET THE NUMBER OF INTEGERS
 7450:	  1DA7	CA			XCH	A,R2		;FLIP FOR SUBB
 7451:	  1DA8	C3			CLR	C
 7452:	  1DA9	9A			SUBB	A,R2
 7453:	  1DAA	FF			MOV	R7,A
 7454:	  1DAB	50 06			JNC	FPO3
 7455:	  1DAD	7D 3F			MOV	R5,#'?'         ;OUTPUT A QUESTION MARK
 7456:	  1DAF	D1 A9			ACALL	SOUT1		;NUMBER IS TOO LARGE FOR FORMAT
 7457:	  1DB1	A1 DF			AJMP	FREE
 7458:	  1DB3	BA 00 07	FPO3:	CJNE	R2,#00,USING0	;SEE IF ZERO
 7459:	  1DB6	1F			DEC	R7
 7460:	  1DB7	D1 96			ACALL	SS7
 7461:	  1DB9	D1 A3			ACALL	ZOUT		;OUTPUT A ZERO
 7462:	  1DBB	80 06			SJMP	USING1
 7463:					;
 7464:	  1DBD	D1 96		USING0: ACALL	SS7		;OUTPUT SPACES, IF NEED TO
 7465:	  1DBF	EA			MOV	A,R2		;OUTPUT DIGITS
 7466:	  1DC0	FF			MOV	R7,A
 7467:	  1DC1	D1 58			ACALL	OUTR0
 7468:					;
 7469:	  1DC3	EB		USING1: MOV	A,R3
 7470:	  1DC4	54 0F			ANL	A,#0FH		;GET THE NUMBER RIGHT OF DP
 7471:	  1DC6	FA			MOV	R2,A		;SAVE IT
 7472:	  1DC7	60 BD			JZ	PMT1		;EXIT IF ZERO
 7473:	  1DC9	D1 9F			ACALL	ROUT		;OUTPUT DP
 7474:	  1DCB	D1 7D			ACALL	NUM_RT
 7475:	  1DCD	B5 02 03		CJNE	A,2,USINGX	;COMPARE A TO R2
 7476:					;
 7477:	  1DD0	EA		USINGY: MOV	A,R2
 7478:	  1DD1	C1 8D			AJMP	Z7R7
 7479:					;
 7480:	  1DD3	50 FB		USINGX: JNC	USINGY
 7481:					;
 7482:	  1DD5	CA		USING2: XCH	A,R2
 7483:	  1DD6	C3			CLR	C
 7484:	  1DD7	9A			SUBB	A,R2
 7485:	  1DD8	CA			XCH	A,R2
 7486:	  1DD9	D1 8D			ACALL	Z7R7		;OUTPUT ZEROS IF NEED TO
 7487:	  1DDB	EA			MOV	A,R2
 7488:	  1DDC	FF			MOV	R7,A
 7489:	  1DDD	C1 58			AJMP	OUTR0
 7490:					;
 7491:					; First, force exponential output, if need to
 7492:					;
 7493:	  1DDF	EE		FREE:	MOV	A,R6		;GET THE EXPONENT
 7494:	  1DE0	70 04			JNZ	FREE1		;IF ZERO, PRINT IT
 7495:	  1DE2	D1 A7			ACALL	SOUT
 7496:	  1DE4	C1 A3			AJMP	ZOUT
 7497:					;
 7498:	  1DE6	7B F0		FREE1:	MOV	R3,#0F0H	;IN CASE EXP NEEDED
 7499:	  1DE8	74 77			MOV	A,#80H-DIGIT-DIGIT-1
 7500:	  1DEA	2E			ADD	A,R6
 7501:	  1DEB	40 21			JC	EXPOUT
 7502:	  1DED	94 F7			SUBB	A,#0F7H
 7503:	  1DEF	40 1D			JC	EXPOUT
 7504:					;
 7505:					; Now, just print the number
 7506:					;
 7507:	  1DF1	D1 98			ACALL	SINOUT		;PRINT THE SIGN OF THE NUMBER
 7508:	  1DF3	D1 74			ACALL	NUM_LT		;GET THE NUMBER LEFT OF DP
 7509:	  1DF5	B4 08 02		CJNE	A,#8,FREE4
 7510:	  1DF8	C1 58			AJMP	OUTR0
 7511:					;
 7512:	  1DFA	D1 58		FREE4:	ACALL	OUTR0
 7513:	  1DFC	D1 6A			ACALL	ZTEST		;TEST FOR TRAILING ZEROS
 7514:	  1DFE	60 57			JZ	U_RET		;DONE IF ALL TRAILING ZEROS
 7515:	  1E00	D1 9F			ACALL	ROUT		;OUTPUT RADIX
 7516:					;
 7517:	  1E02	7F 01		FREE2:	MOV	R7,#1		;OUTPUT ONE DIGIT
 7518:	  1E04	D1 58			ACALL	OUTR0
 7519:	  1E06	70 4F			JNZ	U_RET
 7520:	  1E08	D1 6A			ACALL	ZTEST
 7521:	  1E0A	60 4B			JZ	U_RET
 7522:	  1E0C	80 F4			SJMP	FREE2		;LOOP
 7523:					;
 7524:	  1E0E	D1 98		EXPOUT: ACALL	SINOUT		;PRINT THE SIGN
 7525:	  1E10	7F 01			MOV	R7,#1		;OUTPUT ONE CHARACTER
 7526:	  1E12	D1 58			ACALL	OUTR0
 7527:	  1E14	D1 9F			ACALL	ROUT		;OUTPUT RADIX
 7528:	  1E16	EB			MOV	A,R3		;GET FORMAT
 7529:	  1E17	54 0F			ANL	A,#0FH		;STRIP INDICATOR
 7530:	  1E19	60 06			JZ	EXPOTX
 7531:					;
 7532:	  1E1B	FF			MOV	R7,A		;OUTPUT THE NUMBER OF DIGITS
 7533:	  1E1C	1F			DEC	R7		;ADJUST BECAUSE ONE CHAR ALREADY OUT
 7534:	  1E1D	D1 58			ACALL	OUTR0
 7535:	  1E1F	80 02			SJMP	EXPOT4
 7536:					;
 7537:	  1E21	D1 02		EXPOTX: ACALL	FREE2		;OUTPUT UNTIL TRAILING ZEROS
 7538:					;
 7539:	  1E23	D1 A7		EXPOT4: ACALL	SOUT		;OUTPUT A SPACE
 7540:	  1E25	7D 45			MOV	R5,#'E'
 7541:	  1E27	D1 A9			ACALL	SOUT1		;OUTPUT AN E
 7542:	  1E29	EE			MOV	A,R6		;GET THE EXPONENT
 7543:	  1E2A	60 04			JZ	XOUT0		;EXIT IF ZERO
 7544:	  1E2C	14			DEC	A		;ADJUST FOR THE DIGIT ALREADY OUTPUT
 7545:	  1E2D	B4 80 05		CJNE	A,#80H,XOUT2	;SEE WHAT IT IS
 7546:					;
 7547:	  1E30	D1 A7		XOUT0:	ACALL	SOUT
 7548:	  1E32	E4			CLR	A
 7549:	  1E33	80 0C			SJMP	XOUT4
 7550:					;
 7551:	  1E35	40 06		XOUT2:	JC	XOUT3		;NEGATIVE EXPONENT
 7552:	  1E37	7D 2B			MOV	R5,#'+'         ;OUTPUT A PLUS SIGN
 7553:	  1E39	D1 A9			ACALL	SOUT1
 7554:	  1E3B	80 04			SJMP	XOUT4
 7555:					;
 7556:	  1E3D	D1 9B		XOUT3:	ACALL	MOUT
 7557:	  1E3F	F4			CPL	A		;FLIP BITS
 7558:	  1E40	04			INC	A		;BUMP
 7559:					;
 7560:	  1E41	C2 E7		XOUT4:	CLR	ACC.7
 7561:	  1E43	F8			MOV	R0,A
 7562:	  1E44	7A 00			MOV	R2,#0
 7563:	  1E46	79 58			MOV	R1,#LOW CONVERT ;CONVERSION LOCATION
 7564:	  1E48	7B 00			MOV	R3,#HIGH CONVERT
 7565:	  1E4A	F1 04			ACALL	CONVERT_BINARY_TO_ASCII_STRING
 7566:	  1E4C	78 58			MOV	R0,#LOW CONVERT ;NOW, OUTPUT EXPONENT
 7567:					;
 7568:	  1E4E	E2		EXPOT5: MOVX	A,@R0		;GET THE CHARACTER
 7569:	  1E4F	FD			MOV	R5,A		;OUTPUT IT
 7570:	  1E50	D1 A9			ACALL	SOUT1
 7571:	  1E52	08			INC	R0		;BUMP THE POINTER
 7572:	  1E53	E8			MOV	A,R0		;GET THE POINTER
 7573:	  1E54	B5 01 F7		CJNE	A,R1B0,EXPOT5	;LOOP
 7574:					;
 7575:	  1E57	22		U_RET:	RET			;EXIT
 7576:					;
 7577:	  1E58			OUTR0:	; Output the characters pointed to by R0, also bias ascii
 7578:					;
 7579:	  1E58	EF			MOV	A,R7		;GET THE COUNTER
 7580:	  1E59	60 0E			JZ	OUTR		;EXIT IF DONE
 7581:	  1E5B	E6			MOV	A,@R0		;GET THE NUMBER
 7582:	  1E5C	44 30			ORL	A,#30H		;ASCII BIAS
 7583:	  1E5E	08			INC	R0		;BUMP POINTER AND COUNTER
 7584:	  1E5F	1F			DEC	R7
 7585:	  1E60	FD			MOV	R5,A		;PUT CHARACTER IN OUTPUT REGISTER
 7586:	  1E61	D1 A9			ACALL	SOUT1		;OUTPUT THE CHARACTER
 7587:	  1E63	E4			CLR	A		;JUST FOR TEST
 7588:	  1E64	B8 33 F1		CJNE	R0,#FP_NIB8+1,OUTR0
 7589:	  1E67	74 55			MOV	A,#55H		;KNOW WHERE EXIT OCCURED
 7590:					;
 7591:	  1E69	22		OUTR:	RET
 7592:					;
 7593:	  1E6A	A9 00		ZTEST:	MOV	R1,R0B0 	;GET POINTER REGISTER
 7594:					;
 7595:	  1E6C	E7		ZT0:	MOV	A,@R1		;GET THE VALUE
 7596:	  1E6D	70 04			JNZ	ZT1
 7597:	  1E6F	09			INC	R1		;BUMP POINTER
 7598:	  1E70	B9 33 F9		CJNE	R1,#FP_NIB8+1,ZT0
 7599:					;
 7600:	  1E73	22		ZT1:	RET
 7601:					;
 7602:	  1E74	EE		NUM_LT: MOV	A,R6		;GET EXPONENT
 7603:	  1E75	C3			CLR	C		;GET READY FOR SUBB
 7604:	  1E76	94 80			SUBB	A,#80H		;SUB EXPONENT BIAS
 7605:	  1E78	50 01			JNC	NL1		;OK IF NO CARRY
 7606:	  1E7A	E4			CLR	A		;NO DIGITS LEFT
 7607:					;
 7608:	  1E7B	FF		NL1:	MOV	R7,A		;SAVE THE COUNT
 7609:	  1E7C	22			RET
 7610:					;
 7611:	  1E7D	C3		NUM_RT: CLR	C		;SUBB AGAIN
 7612:	  1E7E	74 80			MOV	A,#80H		;EXPONENT BIAS
 7613:	  1E80	9E			SUBB	A,R6		;GET THE BIASED EXPONENT
 7614:	  1E81	50 01			JNC	NR1
 7615:	  1E83	E4			CLR	A
 7616:					;
 7617:	  1E84	22		NR1:	RET			;EXIT
 7618:					;
 7619:	  1E85	EF		SPACE7: MOV	A,R7		;GET THE NUMBER OF SPACES
 7620:	  1E86	60 FC			JZ	NR1		;EXIT IF ZERO
 7621:	  1E88	D1 A7			ACALL	SOUT		;OUTPUT A SPACE
 7622:	  1E8A	1F			DEC	R7		;BUMP COUNTER
 7623:	  1E8B	80 F8			SJMP	SPACE7		;LOOP
 7624:					;
 7625:	  1E8D	FF		Z7R7:	MOV	R7,A
 7626:					;
 7627:	  1E8E	EF		ZERO7:	MOV	A,R7		;GET COUNTER
 7628:	  1E8F	60 F3			JZ	NR1		;EXIT IF ZERO
 7629:	  1E91	D1 A3			ACALL	ZOUT		;OUTPUT A ZERO
 7630:	  1E93	1F			DEC	R7		;BUMP COUNTER
 7631:	  1E94	80 F8			SJMP	ZERO7		;LOOP
 7632:					;
 7633:	  1E96	D1 85		SS7:	ACALL	SPACE7
 7634:					;
 7635:	  1E98	EC		SINOUT: MOV	A,R4		;GET THE SIGN
 7636:	  1E99	60 0C			JZ	SOUT		;OUTPUT A SPACE IF ZERO
 7637:					;
 7638:	  1E9B	7D 2D		MOUT:	MOV	R5,#'-'
 7639:	  1E9D	80 0A			SJMP	SOUT1		;OUTPUT A MINUS IF NOT
 7640:					;
 7641:	  1E9F	7D 2E		ROUT:	MOV	R5,#'.'         ;OUTPUT A RADIX
 7642:	  1EA1	80 06			SJMP	SOUT1
 7643:					;
 7644:	  1EA3	7D 30		ZOUT:	MOV	R5,#'0'         ;OUTPUT A ZERO
 7645:	  1EA5	80 02			SJMP	SOUT1
 7646:					;
 7647:	  1EA7	7D 20		SOUT:	MOV	R5,#' '         ;OUTPUT A SPACE
 7648:					;
 7649:	  1EA9	21 79		SOUT1:	AJMP	OUTPUT
 7650:					;
 7651:					;***************************************************************
 7652:					;
 7653:	  1EAB			CONVERT_ASCII_STRING_TO_BINARY:
 7654:					;
 7655:					;DPTR POINTS TO ASCII STRING
 7656:					;PUT THE BINARY NUMBER IN R2:R0, ERROR IF >64K
 7657:					;
 7658:					;***************************************************************
 7659:					;
 7660:	  1EAB	91 96		CASB:	ACALL	HEXSCAN 	;SEE IF HEX NUMBER
 7661:	  1EAD	92 23			MOV	ADD_IN,C	;IF ADD_IN IS SET, THE NUMBER IS HEX
 7662:	  1EAF	F1 EB			ACALL	GET_DIGIT_CHECK
 7663:	  1EB1	B3			CPL	C		;FLIP FOR EXIT
 7664:	  1EB2	40 28			JC	RCASB
 7665:	  1EB4	7B 00			MOV	R3,#00H 	;ZERO R3:R1 FOR LOOP
 7666:	  1EB6	79 00			MOV	R1,#00H
 7667:	  1EB8	80 15			SJMP	CASB5
 7668:					;
 7669:	  1EBA	A3		CASB2:	INC	DPTR
 7670:	  1EBB	89 00			MOV	R0B0,R1 	;SAVE THE PRESENT CONVERTED VALUE
 7671:	  1EBD	8B 02			MOV	R2B0,R3 	;IN R2:R0
 7672:	  1EBF	F1 EB			ACALL	GET_DIGIT_CHECK
 7673:	  1EC1	40 0C			JC	CASB5
 7674:	  1EC3	30 23 16		JNB	ADD_IN,RCASB	;CONVERSION COMPLETE
 7675:	  1EC6	91 B6			ACALL	HEX_CHECK	;SEE IF HEX NUMBER
 7676:	  1EC8	40 03			JC	CASB4		;PROCEED IF GOOD
 7677:	  1ECA	A3			INC	DPTR		;BUMP PAST H
 7678:	  1ECB	80 0F			SJMP	RCASB
 7679:					;
 7680:	  1ECD	24 09		CASB4:	ADD	A,#9		;ADJUST HEX ASCII BIAS
 7681:					;
 7682:	  1ECF	75 F0 0A	CASB5:	MOV	B,#10
 7683:	  1ED2	30 23 03		JNB	ADD_IN,CASB6
 7684:	  1ED5	75 F0 10		MOV	B,#16		;HEX MODE
 7685:					;
 7686:	  1ED8	D1 E3		CASB6:	ACALL	MULNUM		;ACCUMULATE THE DIGITS
 7687:	  1EDA	50 DE			JNC	CASB2		;LOOP IF NO CARRY
 7688:					;
 7689:	  1EDC	E4		RCASB:	CLR	A		;RESET ACC
 7690:	  1EDD	92 E1			MOV	ACC.OVERFLOW,C	;IF OVERFLOW, SAY SO
 7691:	  1EDF	22			RET			;EXIT
 7692:					;
 7693:	  1EE0	75 F0 0A	MULNUM10:MOV	B,#10
 7694:					;
 7695:					;***************************************************************
 7696:					;
 7697:	  1EE3			MULNUM: ; Take the next digit in the acc (masked to 0FH)
 7698:					; accumulate in R3:R1
 7699:					;
 7700:					;***************************************************************
 7701:					;
 7702:	  1EE3	C0 E0			PUSH	ACC		;SAVE ACC
 7703:	  1EE5	C0 F0			PUSH	B		;SAVE MULTIPLIER
 7704:	  1EE7	E9			MOV	A,R1		;PUT LOW ORDER BITS IN ACC
 7705:	  1EE8	A4			MUL	AB		;DO THE MULTIPLY
 7706:	  1EE9	F9			MOV	R1,A		;PUT THE RESULT BACK
 7707:	  1EEA	EB			MOV	A,R3		;GET THE HIGH ORDER BYTE
 7708:	  1EEB	AB F0			MOV	R3,B		;SAVE THE OVERFLOW
 7709:	  1EED	D0 F0			POP	B		;GET THE MULTIPLIER
 7710:	  1EEF	A4			MUL	AB		;DO IT
 7711:	  1EF0	A2 D2			MOV	C,OV		;SAVE OVERFLOW IN F0
 7712:	  1EF2	92 D5			MOV	F0,C
 7713:	  1EF4	2B			ADD	A,R3		;ADD OVERFLOW TO HIGH RESULT
 7714:	  1EF5	FB			MOV	R3,A		;PUT IT BACK
 7715:	  1EF6	D0 E0			POP	ACC		;GET THE ORIGINAL ACC BACK
 7716:	  1EF8	72 D5			ORL	C,F0		;OR CARRY AND OVERFLOW
 7717:	  1EFA	40 07			JC	MULX		;NO GOOD IF THE CARRY IS SET
 7718:					;
 7719:	  1EFC	54 0F		MUL11:	ANL	A,#0FH		;MASK OFF HIGH ORDER BITS
 7720:	  1EFE	29			ADD	A,R1		;NOW ADD THE ACC
 7721:	  1EFF	F9			MOV	R1,A		;PUT IT BACK
 7722:	  1F00	E4			CLR	A		;PROPAGATE THE CARRY
 7723:	  1F01	3B			ADDC	A,R3
 7724:	  1F02	FB			MOV	R3,A		;PUT IT BACK
 7725:					;
 7726:	  1F03	22		MULX:	RET			;EXIT WITH OR WITHOUT CARRY
 7727:					;
 7728:	  1F04			CONVERT_BINARY_TO_ASCII_STRING:
 7729:				;
 7730:				;*****************************************************************************
 7731:				;****** Elektor 3 Patch ******************************************************
 7732:				;****** Performance improvements *********************************************
 7733:				;
 7734:				;
 7735:				;R3:R1 contains the address of the string
 7736:				;R2:R0 contains the value to convert
 7737:				;DPTR, R7, R6, and ACC gets clobbered
 7738:				;
 7739:				;***************************************************************
 7740:				;
 7741:				;	CLR	A		;NO LEADING ZEROS
 7742:				;	MOV	DPTR,#10000	;SUBTRACT 10000
 7743:				;	ACALL	RSUB		;DO THE SUBTRACTION
 7744:				;	MOV	DPTR,#1000	;NOW 1000
 7745:				;	ACALL	RSUB
 7746:				;	MOV	DPTR,#100	;NOW 100
 7747:				;	ACALL	RSUB
 7748:				;	MOV	DPTR,#10	;NOW 10
 7749:				;	ACALL	RSUB
 7750:				;	MOV	DPTR,#1 	;NOW 1
 7751:				;	ACALL	RSUB
 7752:				;	JZ	RSUB2		;JUMP OVER RET
 7753:				;
 7754:				;RSUB_R:	RET
 7755:				;
 7756:				;RSUB:	MOV	R6,#-1		;SET UP THE COUNTER
 7757:				;
 7758:				;RSUB1: INC	R6		;BUMP THE COUNTER
 7759:				;	XCH	A,R2		;DO A FAST COMPARE
 7760:				;	CJNE	A,DPH,RSUB11
 7761:				;RSUB11: XCH	 A,R2
 7762:				;	JC	FAST_DONE
 7763:				;	XCH	A,R0		;GET LOW BYTE
 7764:				;	SUBB	A,DPL		;SUBTRACT, CARRY IS CLEARED
 7765:				;	XCH	A,R0		;PUT IT BACK
 7766:				;	XCH	A,R2		;GET THE HIGH BYTE
 7767:				;	SUBB	A,DPH		;ADD THE HIGH BYTE
 7768:				;	XCH	A,R2		;PUT IT BACK
 7769:				;	JNC	RSUB1		;LOOP UNTIL CARRY
 7770:				;
 7771:				;	XCH	A,R0
 7772:				;	ADD	A,DPL		;RESTORE R2:R0
 7773:				;	XCH	A,R0
 7774:				;	XCH	A,R2
 7775:				;	ADDC	A,DPH
 7776:				;	XCH	A,R2
 7777:				;
 7778:				;FAST_DONE:
 7779:				;
 7780:				;	ORL	A,R6		;OR THE COUNT VALUE
 7781:				;	JZ	RSUB_R		;RETURN IF ZERO
 7782:				;
 7783:				;RSUB2: MOV	A,#'0'          ;GET THE ASCII BIAS
 7784:				;	ADD	A,R6		;ADD THE COUNT
 7785:				;
 7786:				;RSUB4: MOV	P2,R3		;SET UP P2
 7787:				;	MOVX	@R1,A		;PLACE THE VALUE IN MEMORY
 7788:				;	INC	R1
 7789:				;	CJNE	R1,#00H,RSUB3	;SEE IF RAPPED AROUND
 7790:				;	INC	R3		;BUMP HIGH BYTE
 7791:				;
 7792:				;RSUB3: RET			;EXIT
 7793:				;
 7794:				;****** Faster code starts here: *********************************************
 7795:				;
 7796:	  1F04	7D 00			mov	R5,#0
 7797:				;
 7798:	  1F06	EA		RSUB1:	mov	A, R2
 7799:	  1F07	75 F0 0A		mov	B,#0AH
 7800:	  1F0A	84			div	AB
 7801:	  1F0B	FA			mov	R2,A
 7802:	  1F0C	E8			mov	A,R0
 7803:	  1F0D	54 F0			anl	A,#0F0H
 7804:	  1F0F	45 F0			orl	A,B
 7805:	  1F11	C4			swap	A
 7806:	  1F12	75 F0 0A		mov	B,#0AH
 7807:	  1F15	84			div	AB
 7808:	  1F16	C4			swap	A
 7809:	  1F17	FE			mov	R6,A
 7810:	  1F18	E8			mov	A,R0
 7811:	  1F19	54 0F			anl	A,#0FH
 7812:	  1F1B	C4			swap	A
 7813:	  1F1C	45 F0			orl	A,B
 7814:	  1F1E	C4			swap	A
 7815:	  1F1F	75 F0 0A		mov	B,#0AH
 7816:	  1F22	84			div	AB
 7817:	  1F23	4E			orl	A,R6
 7818:	  1F24	F8			mov	R0,A
 7819:	  1F25	E5 F0			mov	A,B
 7820:	  1F27	24 30			add	A,#30H
 7821:	  1F29	0D			inc	R5
 7822:	  1F2A	C0 E0			push	ACC
 7823:	  1F2C	EA			mov	A,R2
 7824:	  1F2D	48			orl	A,R0
 7825:	  1F2E	70 D6			jnz	RSUB1
 7826:				;
 7827:	  1F30	D0 E0		RSUB2:	pop	ACC
 7828:	  1F32	8B A0			mov	P2,R3
 7829:	  1F34	F3			movx	@R1,A
 7830:	  1F35	09			inc	R1
 7831:	  1F36	B9 00 01		cjne	R1,#0,RSUB3
 7832:	  1F39	0B			inc	R3
 7833:				;
 7834:	  1F3A	DD F4		RSUB3:	djnz	R5,RSUB2
 7835:	  1F3C	22			ret
 7836:				;
 7837:				;****** continue with original code: *****************************************
 7838:				;
 7839:					;***************************************************************
 7840:					;
 7841:	  1F3D			HEXOUT: ; Output the hex number in R3:R1, supress leading zeros, if set
 7842:					;
 7843:					;***************************************************************
 7844:					;
 7845:	  1F3D	D1 A7			ACALL	SOUT		;OUTPUT A SPACE
 7846:	  1F3F	A2 36			MOV	C,ZSURP 	;GET ZERO SUPPRESSION BIT
 7847:	  1F41	92 23			MOV	ADD_IN,C
 7848:	  1F43	EB			MOV	A,R3		;GET HIGH NIBBLE AND PRINT IT
 7849:	  1F44	F1 60			ACALL	HOUTHI
 7850:	  1F46	EB			MOV	A,R3
 7851:	  1F47	F1 61			ACALL	HOUTLO
 7852:					;
 7853:	  1F49	C2 23		HEX2X:	CLR	ADD_IN		;DON'T SUPPRESS ZEROS
 7854:	  1F4B	E9			MOV	A,R1		;GET LOW NIBBLE AND PRINT IT
 7855:	  1F4C	F1 60			ACALL	HOUTHI
 7856:	  1F4E	E9			MOV	A,R1
 7857:	  1F4F	F1 61			ACALL	HOUTLO
 7858:	  1F51	7D 48			MOV	R5,#'H'         ;OUTPUT H TO INDICATE HEX MODE
 7859:					;
 7860:	  1F53	C1 A9		SOUT_1: AJMP	SOUT1
 7861:					;
 7862:	  1F55	C2 23		HOUT1:	CLR	ADD_IN		;PRINTED SOMETHING, SO CLEAR ADD_IN
 7863:	  1F57	24 90			ADD	A,#90H		;CONVERT TO ASCII
 7864:	  1F59	D4			DA	A
 7865:	  1F5A	34 40			ADDC	A,#40H
 7866:	  1F5C	D4			DA	A		;GOT IT HERE
 7867:	  1F5D	FD			MOV	R5,A		;OUTPUT THE BYTE
 7868:	  1F5E	80 F3			SJMP	SOUT_1
 7869:					;
 7870:	  1F60	C4		HOUTHI: SWAP	A		;SWAP TO OUTPUT HIGH NIBBLE
 7871:					;
 7872:	  1F61	54 0F		HOUTLO: ANL	A,#0FH		;STRIP
 7873:	  1F63	70 F0			JNZ	HOUT1		;PRINT IF NOT ZERO
 7874:	  1F65	30 23 ED		JNB	ADD_IN,HOUT1	;OUTPUT A ZERO IF NOT SUPRESSED
 7875:	  1F68	22			RET
 7876:				;
 7877:				;*****************************************************************************
 7878:				;******* New baudrate detection **********************************************
 7879:				;******* calculate r3:r1=-(Timer2 DIV 16) for serial mode ********************
 7880:				;******* Wulf 3 alteration 2 *************************************************
 7881:				;
 7882:	  1F69	74 F0		SERCALC:mov	a,#0F0h
 7883:	  1F6B	FB			mov	r3,a
 7884:	  1F6C	A9 CD			mov	r1,TH2
 7885:	  1F6E	59			anl	a,r1
 7886:	  1F6F	C4			swap	a
 7887:	  1F70	F4			cpl	a
 7888:	  1F71	CB			xch	a,r3
 7889:	  1F72	55 CC			anl	a,TL2
 7890:	  1F74	C9			xch	a,r1
 7891:	  1F75	54 0F			anl	a,#00Fh
 7892:	  1F77	49			orl	a,r1
 7893:	  1F78	C4			swap	a
 7894:	  1F79	F4			cpl	a
 7895:	  1F7A	A9 D8			mov	r1,ADCON	;save BSY bit
 7896:	  1F7C	75 DA 00		mov	DAPR,#0 	;start A/D for 805xx test
 7897:	  1F7F	C9			xch	a,r1
 7898:	  1F80	22			ret
 7899:				;
 7900:				;*****************************************************************************
 7901:				;
 7902:		N      1F78		ORG	1F78H
 7903:					;
 7904:	  1F78	20 1A 03	CKS_I:	JB	CKS_B,CS_I
 7905:	  1F7B	02 40 1B		LJMP	401BH
 7906:					;
 7907:	  1F7E	02 20 88	CS_I:	LJMP	2088H
 7908:					;
 7909:	  1F81	4E 4F 20 44	E14X:	DB	'NO DATA"'
	  1F85	41 54 41 22
 7910:					;
 7911:	  1F89	94		E11X:	DB	128+20
 7912:	  1F8A	41 52 49 54		DB	'ARITH. OVERFLOW"'
	  1F8E	48 2E 20 4F
	  1F92	56 45 52 46
	  1F96	4C 4F 57 22
 7913:					;
 7914:	  1F9A	50 52 4F 47	E16X:	DB	'PROGRAMMING"'
	  1F9E	52 41 4D 4D
	  1FA2	49 4E 47 22
 7915:					;
 7916:	  1FA6	43 41 4E	E15X:	DB	'CAN'
 7917:	  1FA9	27			DB	27H
 7918:	  1FAA	54 20 43 4F		DB	'T CONTINUE"'
	  1FAE	4E 54 49 4E
	  1FB2	55 45 22
 7919:					;
 7920:	  1FB5	49 4E 56 41	E10X:	DB	'INVALID LINE NUMBER"'
	  1FB9	4C 49 44 20
	  1FBD	4C 49 4E 45
	  1FC1	20 4E 55 4D
	  1FC5	42 45 52 22
 7921:					;
 7922:	  1FC9	50 52 4F 4D	NOROM:	DB	'PROM MODE"'
	  1FCD	20 4D 4F 44
	  1FD1	45 22
 7923:					;
 7924:				;*****************************************************************************
 7925:				;****** Set a new version message ********************************************
 7926:				;
 7927:				;S_N:	DB	'*MCS-51(tm) BASIC V1.1*'
 7928:				;
 7929:				;S_N:	DB	'*MCS-BASIC-52 V1.31*"'
 7930:	  1FD3	2A 42 41 53	S_N:    DB      '*BASIC-52 8051 KIT *"'
	  1FD7	49 43 2D 35
	  1FDB	32 20 38 30
	  1FDF	35 31 20 4B
	  1FE3	49 54 20 2A
	  1FE7	22
 7931:				;
 7932:				;*****************************************************************************
 7933:				;
 7934:		N      1FEB		ORG	1FEBH		;FOR LINK COMPATABILITY
 7935:					;
 7936:	  1FEB			GET_DIGIT_CHECK:	; Get a character, then check for digit
 7937:					;
 7938:	  1FEB	B1 6C			ACALL	GET_DPTR_CHARACTER
 7939:					;
 7940:	  1FED			DIGIT_CHECK:	;CHECK FOR A VALID ASCII DIGIT, SET CARRY IF FOUND
 7941:					;
 7942:	  1FED	B4 3A 00		CJNE	A,#'9'+1,DC10   ;SEE IF ASCII 9 OR LESS
 7943:	  1FF0	40 01		DC10:	JC	DC1
 7944:	  1FF2	22			RET
 7945:					;
 7946:	  1FF3	B4 30 00	DC1:	CJNE	A,#'0',DC11     ;SEE IF ASCII 0 OR GREATER
 7947:	  1FF6	B3		DC11:	CPL	C
 7948:	  1FF7	22			RET
 7949:					;
 7950:		N      1FF8		ORG	1FF8H
 7951:					;
 7952:	  1FF8	45 52 52 4F	ERS:	DB	'ERROR: "'
	  1FFC	52 3A 20 22
 7953:					;
 7954:					;***************************************************************
 7955:					;
 7956:					XSEG	;External Ram
 7957:					;
 7958:					;***************************************************************
 7959:					;
 7960:	  0000	N      0004		DS	4
 7961:	  0004	N      0001	IBCNT:	DS	1		;LENGTH OF A LINE
 7962:	  0005	N      0002	IBLN:	DS	2		;THE LINE NUMBER
 7963:	  0007	N      0049	IBUF:	DS	LINLEN		;THE INPUT BUFFER
 7964:	  0050	N      000F	CONVT:	DS	15		;CONVERSION LOCATION FOR FPIN
 7965:					;
 7966:		N      0100		ORG	100H
 7967:					;
 7968:	  0100	N      0001	GTB:	DS	1		;GET LOCATION
 7969:	  0101	N      0001	ERRLOC: DS	1		;ERROR TYPE
 7970:	  0102	N      0002	ERRNUM: DS	2		;WHERE TO GO ON AN ERROR
 7971:	  0104	N      0002	VARTOP: DS	2		;TOP OF VARIABLE STORAGE
 7972:	  0106	N      0002	ST_ALL: DS	2		;STORAGE ALLOCATION
 7973:	  0108	N      0002	MT_ALL: DS	2		;MATRIX ALLOCATION
 7974:	  010A	N      0002	MEMTOP: DS	2		;TOP OF MEMORY
 7975:	  010C	N      0002	RCELL:	DS	2		;RANDOM NUMBER CELL
 7976:	  010E	N      0005		DS	FPSIZ-1
 7977:	  0113	N      0001	CXTAL:	DS	1		;CRYSTAL
 7978:	  0114	N      0005		DS	FPSIZ-1
 7979:	  0119	N      0001	FPT1:	DS	1		;FLOATINP POINT TEMP 1
 7980:	  011A	N      0005		DS	FPSIZ-1
 7981:	  011F	N      0001	FPT2:	DS	1		;FLOATING POINT TEMP 2
 7982:	  0120	N      0002	INTLOC: DS	2		;LOCATION TO GO TO ON INTERRUPT
 7983:	  0122	N      0002	STR_AL: DS	2		;STRING ALLOCATION
 7984:	  0124	N      0002	SPV:	DS	2		;SERIAL PORT BAUD RATE
 7985:	  0126	N      0002	TIV:	DS	2		;TIMER INTERRUPT NUM AND LOC
 7986:	  0128	N      0002	PROGS:	DS	2		;PROGRAM A PROM TIME OUT
 7987:				;
 7988:				;*****************************************************************************
 7989:				;****** Disable Intel programming for to get room ****************************
 7990:				;****** We don't need this, but don't remark it! *****************************
 7991:				;
 7992:	  012A	N      0002	IPROGS: DS	2		;INTELLIGENT PROM PROGRAMMER TIMEOUT
 7993:				;
 7994:				;*****************************************************************************
 7995:				;
 7996:	  012C	N      0001	TM_TOP: DS	1
 7997:				;
 7998:					END
 7999:
 8000:
 8001:





                     register banks used:  ---

                     no errors



	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
AABS				  CODE	    139C	4795
AADD				  CODE	    174E	5754
AANL				  CODE	    1491	5081
AATAN				  CODE	    11ED	4458
AATAN1				  CODE	    11FB	4465
AC				  BIT	      D6
AC1				  CODE	    0976	2659
ACBYTE				  CODE	    13BA	4840
ACC				  DATA	      E0
ACOS				  CODE	    117A	4355
ADBYTE				  CODE	    13C3	4852
ADCON				  NUMBER    00D8	 501
ADDLP				  CODE	    19FF	6508
ADDPTR				  CODE	    05E8	1913
ADDPTR1				  CODE	    05F0	1917
ADD_IN				  BIT	      23	6315
ADD_R				  CODE	    19FD	6506
ADIV				  CODE	    1417	4939
AEL1				  CODE	    128F	4595
AELP				  CODE	    127D	4583
AEQ				  CODE	    13E8	4901
AEQ1				  CODE	    13EA	4902
AETOX				  CODE	    1334	4716
AEXL				  CODE	    135B	4739
AEXP				  CODE	    1338	4719
AEXP1				  CODE	    134A	4730
AFREE				  CODE	    171E	5727
AGE				  CODE	    13F4	4909
AGET				  CODE	    14B6	5114
AGT				  CODE	    13D2	4883
AGT1				  CODE	    13D6	4885
AI1				  CODE	    1387	4774
AI11				  CODE	    138E	4779
AI2				  CODE	    138F	4781
AI21				  CODE	    1397	4787
AI3				  CODE	    139B	4791
AINT				  CODE	    137A	4763
AL				  CODE	    0D5A	3440
AL1				  CODE	    0D5D	3441
AL2				  CODE	    0D62	3443
AL3				  CODE	    0D63	3444
ALE				  CODE	    13F8	4912
ALEN				  CODE	    172E	5736
ALN				  CODE	    12CD	4650
ALN1				  CODE	    12DA	4657
ALN11				  CODE	    12FC	4679
ALNE				  CODE	    12F2	4673
ALNL				  CODE	    12E0	4663
ALNO				  CODE	    1305	4684
ALPAR				  CODE	    13B9	4836
ALT				  CODE	    13E3	4897
ALT1				  CODE	    13E5	4898
AMUL				  CODE	    11BD	4410
ANE				  CODE	    13EE	4905
ANEG				  CODE	    13AE	4824
ANOT				  CODE	    14A3	5097
ANU				  CODE	    0D4F	3434
AORL				  CODE	    149A	5089
AP1				  CODE	    14F2	5179
APCON				  CODE	    14F6	5182
ARCAP2				  CODE	    14EC	5171
ARG1_EXP_IS_LARGER		  CODE	    1A63	6607
ARG1_EXP_IS_LARGER1		  CODE	    1A64	6610
ARG1_EXP_IS_LARGER2		  CODE	    1A67	6613
ARGF				  BIT	      24	 421
ARG_STACK			  NUMBER    0009	6284
ARG_STACK_PAGE			  NUMBER    0001	6285
ARND				  CODE	    13FE	4918
ASGN				  CODE	    13A2	4807
ASIN				  CODE	    117E	4364
ASIN1				  CODE	    1194	4375
ASQR				  CODE	    129A	4608
ASTKA				  NUMBER    0009	 361
ASTKAH				  NUMBER    0001	 526
ASUB				  CODE	    1729	5733
AT2CON				  CODE	    14E0	5160
ATAN				  CODE	    11DD	4442
ATCON				  CODE	    14E4	5165
ATIM0				  CODE	    14CE	5144
ATIM1				  CODE	    14D4	5148
ATIM2				  CODE	    14DA	5152
ATIME				  CODE	    1736	5741
ATMOD				  CODE	    14E8	5168
ATTAB				  CODE	    1137	4257
AXBYTE				  CODE	    13CB	4863
AXBYTE1				  CODE	    13CD	4868
AXRL				  CODE	    14A5	5099
AXTAL				  CODE	    0FE4	3971
AXTAL0				  CODE	    1664	5534
AXTAL1				  CODE	    1669	5537
AXTAL2				  CODE	    1686	5571
AXTAL3				  CODE	    122C	4509
A_D				  CODE	    126D	4567
A_IE				  CODE	    14C6	5138
A_IP				  CODE	    14CA	5141
B				  DATA	      F0
B4800				  NUMBER    00B2	 518
B9600				  NUMBER    00DC	 519
BABC				  NUMBER    0027	 473
BCHR				  CODE	    0839	2441
BCHR1				  CODE	    083F	2443
BCK				  CODE	    0797	2292
BD				  BIT	      DF	 468
BELL				  NUMBER    0007	 510
BG1				  CODE	    042F	1341
BG10				  CODE	    0458	1385
BG11				  CODE	    045F	1392
BG12				  CODE	    0464	1395
BG13				  CODE	    0467	1396
BG14				  CODE	    0458	1376
BG15				  CODE	    046E	1403
BG16				  CODE	    0443	1354
BG2				  CODE	    046B	1402
BG3				  CODE	    0471	1407
BI				  BIT	      32	 445
BO				  BIT	      2C	 439
BOFAH				  NUMBER    0013	 381
BOFAL				  NUMBER    0014	 382
BOTH_PLUS			  CODE	    1A6B	6622
BR0				  CODE	    07FB	2394
BR2				  CODE	    0848	2447
BS				  NUMBER    0008	 511
B_C				  CODE	    0AAE	2898
B_TXA				  CODE	    0F2E	3831
B_TXA1				  CODE	    0F38	3836
C0				  CODE	    0D01	3386
C0C				  CODE	    1032	4057
C0ORX1				  BIT	      34	 454
C1				  CODE	    0D08	3390
C1C				  CODE	    103D	4063
C2				  CODE	    0D11	3395
C2C				  CODE	    103C	4061
C2_T2				  CODE	    1479	5050
C3C				  CODE	    1042	4067
CASB				  CODE	    1EAB	7660
CASB2				  CODE	    1EBA	7669
CASB4				  CODE	    1ECD	7680
CASB5				  CODE	    1ECF	7682
CASB6				  CODE	    1ED8	7686
CBIAS				  CODE	    1688	5573
CC1				  CODE	    1851	5941
CCAL				  CODE	    0526	1673
CCAL1				  CODE	    0536	1690
CCLR3				  CODE	    0696	2093
CCONT				  CODE	    184B	5938
CERASE				  CODE	    050A	1652
CILOOP				  CODE	    0819	2421
CILOOP1				  CODE	    081B	2422
CIUB				  BIT	      1E	 413
CI_RET				  CODE	    07C8	2331
CI_RET1				  CODE	    07C9	2332
CKS_B				  BIT	      1A	 405
CKS_I				  CODE	    1F78	7904
CL1				  CODE	    107C	4105
CL2				  CODE	    1081	4108
CL3				  CODE	    109F	4124
CL6				  CODE	    10A1	4126
CL7				  CODE	    10AA	4130
CLIST				  CODE	    105B	4088
CLIST1				  CODE	    1078	4102
CLN_UP				  CODE	    0F22	3823
CLOOP				  CODE	    1A73	6634
CL_1				  CODE	    0687	2081
CL_2				  CODE	    0695	2091
CMND1				  CODE	    1794	5809
CMND11				  CODE	    17F8	5870
CMND3				  CODE	    17D1	5848
CMND31				  CODE	    17DE	5853
CMND5				  CODE	    17EA	5859
CMNDD				  CODE	    010F	 697
CMNDLK				  CODE	    085F	2460
CMNDR				  CODE	    17A1	5826
CMNDSP				  NUMBER    004D	 495
CMNX				  CODE	    17A8	5830
CMNX1				  CODE	    17B5	5836
CMPLK				  CODE	    1215	4486
CN0				  CODE	    100B	4026
CN0T				  CODE	    1029	4050
CN0T1				  CODE	    1012	4029
CN0T2				  CODE	    101D	4038
CN0T3				  CODE	    101F	4041
CN0T4				  CODE	    1028	4049
CNEW				  CODE	    0666	2046
CNEW1				  CODE	    066C	2058
CNTRLC				  NUMBER    0003	 512
CNTRLD				  NUMBER    0004	 513
CNT_S				  BIT	      35	 455
CNULL				  CODE	    0B12	3005
CNX				  CODE	    1005	4018
COB				  BIT	      1B	 406
CONB				  BIT	      17	 402
CONST				  CODE	    0FFA	4009
CONVERT				  NUMBER    0058	6287
CONVERT_ASCII_STRING_TO_BINARY	  CODE	    1EAB	7653
CONVERT_BINARY_TO_ASCII_STRING	  CODE	    1F04	7728
CONVT				  XDATA	    0050	7964
COUB				  BIT	      1C	 409
CPROG				  CODE	    0494	1560
CPROG1				  CODE	    0497	1562
CPROG2				  CODE	    04BB	1580
CPS				  CODE	    0EB4	3694
CR				  NUMBER    000D	 508
CR0				  CODE	    03F3	1278
CR1				  CODE	    0407	1298
CR11				  CODE	    040A	1299
CR2				  CODE	    0413	1304
CR20				  CODE	    0420	1311
CRAM				  CODE	    178C	5797
CRLF				  CODE	    06AF	2125
CRLF2				  CODE	    06AD	2123
CROM				  CODE	    0546	1709
CRP				  CODE	    06B7	2134
CRS				  CODE	    03E7	1272
CRS1				  CODE	    03EC	1274
CRS2				  CODE	    03EF	1275
CRST				  CODE	    038B	1187
CRST1				  CODE	    03AB	1227
CRST2				  CODE	    03AE	1230
CRUN				  CODE	    080C	2413
CS1				  CODE	    0B51	3074
CSC				  CODE	    0BC7	3158
CSETUP				  CODE	    0B55	3077
CSETUP1				  CODE	    0B60	3083
CSTAKA				  CODE	    1439	4980
CSTAKA2				  CODE	    1437	4978
CSTKA				  NUMBER    0011	 376
CSTKAH				  NUMBER    0000	 527
CSTS				  CODE	    07D2	2347
CSTS1				  CODE	    07D8	2355
CSTS2				  CODE	    07DE	2357
CSY				  CODE	    0A28	2796
CSY1				  CODE	    0A38	2808
CSY2				  CODE	    0A44	2816
CS_I				  CODE	    1F7E	7907
CXFER				  CODE	    1780	5783
CXTAL				  XDATA	    0113	7977
CY				  BIT	      D7
C_1				  CODE	    0F1D	3820
C_2				  CODE	    0F18	3817
C_BIT				  BIT	      2E	 441
C_EX				  CODE	    07E1	2369
C_K				  CODE	    054A	1716
C_TST				  CODE	    0ED1	3721
D1				  CODE	    05E6	1902
DACK				  BIT	      96	 459
DAPR				  NUMBER    00DA	 502
DBTWO				  CODE	    11A1	4385
DC1				  CODE	    1FF3	7946
DC10				  CODE	    1FF0	7943
DC11				  CODE	    1FF6	7947
DCMPX				  CODE	    05D6	1890
DEC3210				  CODE	    1598	5331
DEC3211				  CODE	    159C	5333
DEC3212				  CODE	    159D	5334
DEC76				  CODE	    1654	5511
DEC77				  CODE	    1659	5514
DECDP				  CODE	    05CC	1872
DECDP1				  CODE	    05D2	1875
DECDP2				  CODE	    05CA	1870
DECX				  CODE	    1D4F	7360
DEC_ASTKA			  CODE	    1218	4490
DEC_ASTKA1			  CODE	    121F	4497
DEC_R				  CODE	    1596	5328
DELTST				  CODE	    0EEC	3756
DELTST1				  CODE	    0EEE	3757
DIGIT				  NUMBER    0004	 540
DIGIT_CHECK			  CODE	    1FED	7940
DIRF				  BIT	      2F	 442
DIV0				  CODE	    1ACA	6744
DIV3				  CODE	    1AD7	6753
DIV4				  CODE	    1AE4	6761
DIV5				  CODE	    1AE7	6764
DIV6				  CODE	    1AEF	6769
DIV7				  CODE	    1B06	6791
DIV8				  CODE	    1B1B	6804
DLD				  CODE	    0635	1994
DONE_LOAD			  BIT	      53	6319
DPH				  DATA	      83
DPL				  DATA	      82
DP_B				  CODE	    0EA6	3686
DP_T				  CODE	    0EAD	3690
DRQ				  BIT	      31	 444
DT1				  CODE	    0EF3	3761
DTEMP				  CODE	    185A	5947
DTYPE				  NUMBER    0003	 530
DUBSUB				  CODE	    0A0C	2766
D_CHK				  CODE	    0DD7	3521
D_L1				  CODE	    0B02	2983
D_UNDER				  CODE	    1AD5	6751
E10X				  CODE	    1FB5	7920
E11X				  CODE	    1F89	7911
E14X				  CODE	    1F81	7909
E15X				  CODE	    1FA6	7916
E16X				  CODE	    1F9A	7914
E1X				  CODE	    1753	5764
E1XX				  CODE	    1892	5989
E1XX1				  CODE	    1894	5990
E1XX2				  CODE	    1899	5993
E2X				  CODE	    175E	5765
E3X				  CODE	    1835	5927
E3XX				  CODE	    09C7	2717
E4XX				  CODE	    0BCB	3161
E4YY				  CODE	    1227	4505
E5X				  CODE	    1823	5925
E6X				  CODE	    176E	5768
E7X				  CODE	    1811	5922
EA				  BIT	      AF
EATC				  CODE	    0CF0	3370
EBIAS				  CODE	    126E	4575
EIG				  CODE	    036D	1179
EIGP				  CODE	    0E59	3600
EK				  CODE	    0C18	3224
ENDBIT				  BIT	      29	 436
EOF				  NUMBER    0001	 525
EP1				  CODE	    0F50	3873
EP2				  CODE	    0F54	3876
EP21				  CODE	    0F5D	3880
EP22				  CODE	    0F66	3884
EP3				  CODE	    0F7A	3895
EP4				  CODE	    0F7C	3897
EP41				  CODE	    0F81	3900
EP42				  CODE	    0F86	3902
EP5				  CODE	    0F8D	3906
ER0				  CODE	    1881	5979
ER1				  CODE	    18C5	6026
ER2				  CODE	    18CF	6035
ER3				  CODE	    18DE	6043
ER31				  CODE	    18FB	6056
ER4				  CODE	    1908	6063
ERA1				  CODE	    0517	1659
ERL4				  CODE	    084E	2451
ERPAR				  CODE	    0CEE	3368
ERRLK				  CODE	    04E0	1605
ERRLOC				  XDATA	    0101	7969
ERRNUM				  XDATA	    0102	7970
ERROR				  CODE	    189C	6005
ERROR0				  CODE	    18A8	6012
ERROR01				  CODE	    18AF	6015
ERROR1				  CODE	    189D	6006
ERRS				  CODE	    18BA	6020
ERS				  CODE	    1FF8	7952
ES				  BIT	      AC
ET0				  BIT	      A9
ET1				  BIT	      AB
EX0				  BIT	      A8
EX1				  BIT	      AA
EXA				  CODE	    037B	1181
EXC				  CODE	    0383	1183
EXI				  CODE	    1843	5930
EXP1				  CODE	    1805	5890
EXP11				  CODE	    17FF	5883
EXPONENTS_EQUAL			  CODE	    1A68	6616
EXPOT4				  CODE	    1E23	7539
EXPOT5				  CODE	    1E4E	7568
EXPOTX				  CODE	    1E21	7537
EXPOUT				  CODE	    1E0E	7524
EXPRB				  CODE	    0F4E	3871
EXTI0				  CODE	    0003
EXTI1				  CODE	    0013
E_FIND				  CODE	    0A9D	2888
F0				  BIT	      D5
FCMP				  CODE	    120F	4482
FDT1				  CODE	    1D60	7374
FDT2				  CODE	    1D68	7378
FDTEST				  CODE	    1D5C	7371
FINDC				  CODE	    0EF9	3774
FINDCR				  CODE	    0EF7	3772
FINISH1				  CODE	    1D21	7325
FINISH2				  CODE	    1D34	7341
FINISH_UP			  CODE	    1D35	7343
FINISH_UP1			  CODE	    1D3C	7348
FIRST_RADIX			  BIT	      52	6318
FL1				  CODE	    0ADD	2948
FL11				  CODE	    0AE1	2952
FL2				  CODE	    0AF6	2966
FL3				  CODE	    0AE6	2955
FLOATING_ADD			  CODE	    19A0	6385
FLOATING_COMP			  CODE	    1A50	6582
FLOATING_DIV			  CODE	    1ABD	6729
FLOATING_MUL			  CODE	    1A80	6650
FLOATING_POINT_INPUT		  CODE	    1CCF	7269
FLOATING_POINT_OUTPUT		  CODE	    1D87	7419
FLOATING_SUB			  CODE	    1996	6374
FMUL0				  CODE	    1A85	6659
FMUL1				  CODE	    1A87	6663
FMUL2				  CODE	    1A99	6687
FMUL21				  CODE	    1A9B	6688
FMUL3				  CODE	    1AAA	6710
FMUL_OVER			  CODE	    1A95	6673
FNDCL2				  CODE	    0F01	3780
FNDCL3				  CODE	    0F05	3783
FORMAT				  NUMBER    0017	 385
FOUND_RADIX			  BIT	      51	6317
FOV				  CODE	    1A97	6677
FPC1				  CODE	    1BC2	6993
FPO1				  CODE	    1D99	7438
FPO2				  CODE	    1DA0	7445
FPO3				  CODE	    1DB3	7458
FPONE				  CODE	    16FF	5706
FPSIZ				  NUMBER    0006	 539
FPT1				  XDATA	    0119	7979
FPT2				  XDATA	    011F	7981
FPTS				  CODE	    1058	4080
FPTST				  CODE	    1045	4069
FPTST1				  CODE	    1052	4077
FP_ACC1				  NUMBER    0035	6337
FP_ACC2				  NUMBER    0036	6338
FP_ACC3				  NUMBER    0037	6339
FP_ACC4				  NUMBER    0038	6340
FP_ACC5				  NUMBER    0039	6341
FP_ACC6				  NUMBER    003A	6342
FP_ACC7				  NUMBER    003B	6343
FP_ACC8				  NUMBER    003C	6344
FP_ACCC				  NUMBER    0034	6336
FP_ACCS				  NUMBER    003D	6345
FP_ACCX				  NUMBER    0033	6335
FP_BASE				  CODE	    197C	6359
FP_BASE1			  CODE	    197E	6360
FP_BASE10			  CODE	    1990	6369
FP_BASE11			  CODE	    1992	6370
FP_BASE12			  CODE	    1994	6371
FP_BASE2			  CODE	    1980	6361
FP_BASE3			  CODE	    1982	6362
FP_BASE4			  CODE	    1984	6363
FP_BASE5			  CODE	    1986	6364
FP_BASE6			  CODE	    1988	6365
FP_BASE7			  CODE	    198A	6366
FP_BASE8			  CODE	    198C	6367
FP_BASE9			  CODE	    198E	6368
FP_CARRY			  NUMBER    002A	6314
FP_CLEAR			  CODE	    1BBF	6984
FP_DIG12			  NUMBER    002B	6320
FP_DIG34			  NUMBER    002C	6321
FP_DIG56			  NUMBER    002D	6322
FP_DIG78			  NUMBER    002E	6323
FP_EXP				  NUMBER    0030	6326
FP_NIB1				  NUMBER    002B	6327
FP_NIB2				  NUMBER    002C	6328
FP_NIB3				  NUMBER    002D	6329
FP_NIB4				  NUMBER    002E	6330
FP_NIB5				  NUMBER    002F	6331
FP_NIB6				  NUMBER    0030	6332
FP_NIB7				  NUMBER    0031	6333
FP_NIB8				  NUMBER    0032	6334
FP_NUMBER_SIZE			  NUMBER    0006	6296
FP_SIGN				  NUMBER    002F	6324
FP_STATUS			  NUMBER    0028	6312
FP_TEMP				  NUMBER    0029	6313
FREE				  CODE	    1DDF	7493
FREE1				  CODE	    1DE6	7498
FREE2				  CODE	    1E02	7517
FREE4				  CODE	    1DFA	7512
FRTEST				  CODE	    1D59	7369
FS				  CODE	    13DD	4890
FSIZE				  NUMBER    0011	 544
FSTK				  CODE	    13D8	4887
FSUB10				  CODE	    1A4E	6578
FSUB5				  CODE	    1A1D	6538
FSUB6				  CODE	    1A28	6549
FSUB7				  CODE	    1A2C	6552
FSUB8				  CODE	    1A37	6560
FSUB81				  CODE	    1A3A	6561
FSUB9				  CODE	    1A3D	6566
FTYPE				  NUMBER    0001	 528
FUL1				  CODE	    15BD	5385
FULL				  CODE	    15B5	5378
F_VAR				  CODE	    0623	1981
F_VAR0				  CODE	    062A	1985
F_VAR1				  CODE	    0640	2002
F_VAR2				  CODE	    064D	2013
G1				  CODE	    0599	1811
G2				  CODE	    05AC	1821
G3				  CODE	    05B0	1824
G4				  CODE	    05B3	1827
G5				  CODE	    05B6	1829
GC				  CODE	    0ED8	3733
GCI				  CODE	    0EE0	3739
GCI1				  CODE	    0EE2	3743
GCI11				  CODE	    0EE9	3747
GETEND				  CODE	    0594	1807
GETLIN				  CODE	    0596	1809
GET_DIGIT_CHECK			  CODE	    1FEB	7936
GET_DPTR_CHARACTER		  CODE	    1D6C	7392
GET_NUM				  CODE	    1964	6165
GLN				  CODE	    0ADB	2946
GT1				  CODE	    1CF7	7300
GT11				  CODE	    1CFF	7303
GT12				  CODE	    1D02	7304
GT2				  CODE	    1D0F	7313
GTB				  XDATA	    0100	7968
GTEST				  CODE	    1CE8	7293
GTRD				  BIT	      18	 403
GTX				  CODE	    1554	5257
GTX1				  CODE	    1567	5268
GTYPE				  NUMBER    0002	 529
HC1				  CODE	    1CBE	7252
HC11				  CODE	    1CC1	7253
HEX2X				  CODE	    1F49	7853
HEXDO1				  CODE	    1CAE	7237
HEXDON				  CODE	    1CAD	7235
HEXOUT				  CODE	    1F3D	7841
HEXSC1				  CODE	    1C9C	7224
HEXSCAN				  CODE	    1C96	7215
HEX_CHECK			  CODE	    1CB6	7244
HEX_CHECK1			  CODE	    1CBB	7248
HMODE				  BIT	      37	 457
HOUT1				  CODE	    1F55	7862
HOUTHI				  CODE	    1F60	7870
HOUTLO				  CODE	    1F61	7872
HS1				  CODE	    1CB3	7241
H_RET				  CODE	    1978	6201
I2				  CODE	    1248	4538
I21				  CODE	    1254	4545
IAN				  CODE	    00F3	 685
IAT				  CODE	    0915	2604
IAT1				  CODE	    0918	2605
IBCNT				  XDATA	    0004	7961
IBLK				  CODE	    194C	6147
IBLK1				  CODE	    195B	6153
IBLN				  XDATA	    0005	7962
IBUF				  XDATA	    0007	7963
ICLR				  CODE	    06A4	2108
ICLR1				  CODE	    06A9	2114
IE				  DATA	      A8
IE0				  BIT	      89
IE1				  BIT	      8B
IFIX				  CODE	    1230	4516
IFIXL				  CODE	    0E9B	3668
IGC				  CODE	    0ED6	3731
ILOOP				  CODE	    081D	2426
ILOOP1				  CODE	    0829	2430
IMOV				  CODE	    1573	5282
IN2				  CODE	    0E08	3558
IN2A				  CODE	    0E0D	3561
IN3				  CODE	    0E1A	3567
IN3A				  CODE	    0E2B	3577
IN5				  CODE	    0E4B	3592
IN6				  CODE	    0E54	3596
INBIT				  BIT	      1D	 412
INC3210				  CODE	    1583	5304
INC3211				  CODE	    1588	5308
INC3212				  CODE	    158D	5311
INCH1				  CODE	    07B4	2312
INCH11				  CODE	    07B9	2314
INCH12				  CODE	    07BE	2316
INCH13				  CODE	    07C5	2324
INCHAR				  CODE	    079B	2301
INCHAR1				  CODE	    07A3	2304
INCHAR2				  CODE	    07AB	2307
INC_AND_GET_DPTR_CHARACTER	  CODE	    1D6B	7388
INC_ASTKA			  CODE	    125C	4552
INC_FP_EXP			  CODE	    1B7F	6907
INERR				  CODE	    1D51	7362
INL0				  CODE	    06E0	2168
INL1				  CODE	    06E7	2173
INL11				  CODE	    06F0	2177
INL2				  CODE	    06DD	2166
INL2B				  CODE	    06F6	2182
INL2B1				  CODE	    06FC	2185
INL2B2				  CODE	    06FF	2186
INL6				  CODE	    0708	2192
INLINE				  CODE	    06E2	2170
INLOOP				  CODE	    1CDD	7285
INLPIK				  CODE	    1CE5	7290
INLX				  CODE	    06F2	2179
INPROG				  BIT	      11	 396
INP_B				  BIT	      22	 419
INS				  CODE	    0103	 689
INSR				  CODE	    1524	5225
INSR1				  CODE	    1530	5232
INT0				  BIT	      B2
INT1				  BIT	      B3
INTBIT				  BIT	      12	 397
INTERR				  CODE	    0F3B	3848
INTERR1				  CODE	    0F3D	3849
INTERX				  CODE	    0942	2630
INTERX1				  CODE	    0945	2632
INTERX2				  CODE	    094B	2634
INTERX3				  CODE	    0952	2637
INTERX4				  CODE	    0957	2639
INTGER				  CODE	    0F40	3852
INTGRC				  BIT	      19	6288
INTLOC				  XDATA	    0120	7982
INTPEN				  BIT	      16	 401
INTXAH				  NUMBER    0042	 485
INTXAL				  NUMBER    0043	 486
IP				  DATA	      B8
IPROGS				  XDATA	    012A	7992
IRAMTOP				  NUMBER    00FF	 503
ISAV				  BIT	      2B	 438
ISTA0				  CODE	    095A	2641
ISTA01				  CODE	    0964	2645
ISTA1				  CODE	    0966	2647
ISTAT				  CODE	    0902	2595
ISTAT1				  CODE	    090A	2598
ISTAX				  CODE	    0926	2613
ISTAX1				  CODE	    092B	2616
ISTAY				  CODE	    092F	2620
ISTAY1				  CODE	    0932	2621
ISTAY2				  CODE	    0937	2623
IST_CAL				  CODE	    09F1	2751
IT0				  BIT	      88
IT1				  BIT	      8A
ITRAP				  CODE	    0874	2482
ITRAP1				  CODE	    087C	2487
ITRAP2				  CODE	    0884	2492
ITRAP21				  CODE	    0887	2493
ITRAP3				  CODE	    088C	2501
ITRET				  CODE	    0F4B	3858
I_DL				  CODE	    1868	5957
I_DR				  CODE	    190F	6073
I_L				  CODE	    0853	2454
I_PI				  CODE	    0EA0	3675
I_RET				  CODE	    187E	5974
I_S				  CODE	    093D	2627
I_S1				  CODE	    0940	2628
I_T0				  BIT	      26	 423
L20DPI				  CODE	    057D	1757
L31DPI				  CODE	    05C4	1857
LCLR				  CODE	    05F1	1921
LDPTRI				  CODE	    05BA	1841
LD_A				  CODE	    0FF4	3999
LD_T				  CODE	    058C	1784
LEFT				  CODE	    1C00	7053
LEFT1				  CODE	    1C02	7059
LEFT2				  CODE	    1C03	7060
LEFT3				  CODE	    1C0A	7065
LEFT5				  CODE	    1C29	7092
LEFTL				  CODE	    1C15	7074
LEFTL1				  CODE	    1C28	7090
LF				  NUMBER    000A	 509
LIN1				  CODE	    1569	5270
LINE				  CODE	    14FD	5198
LINE0				  CODE	    14FA	5196
LINE1				  CODE	    1518	5215
LINEB				  BIT	      15	 400
LINLEN				  NUMBER    0049	 524
LMOV				  CODE	    157A	5298
LNTAB				  CODE	    16B6	5611
LN_D				  CODE	    1328	4702
LOAD1				  CODE	    19BA	6421
LOAD2				  CODE	    19CA	6433
LOAD21				  CODE	    19D2	6440
LOAD22				  CODE	    19D7	6446
LOAD23				  CODE	    19DB	6449
LOAD25				  CODE	    19F0	6497
LOAD7				  CODE	    1BA0	6939
LOADR1				  CODE	    1C8C	7204
LOADR1_MANTISSA			  CODE	    1C88	7195
LOAD_POINTERS			  CODE	    1C6B	7150
LP				  BIT	      97	 458
LPB				  BIT	      19	 404
LTOUT1				  CODE	    0754	2255
LTX				  CODE	    1535	5238
LTX1				  CODE	    153C	5243
LTX2				  CODE	    1550	5254
L_RET				  CODE	    0EF6	3763
MDES1				  CODE	    1C77	7172
MEMTOP				  XDATA	    010A	7974
MILLIV				  NUMBER    0047	 489
MNL0				  CODE	    1C4B	7124
MNL1				  CODE	    1C5D	7136
MNLOOP				  CODE	    1C42	7116
MOUT				  CODE	    1E9B	7638
MSIGN				  BIT	      78	6325
MT1				  NUMBER    0045	 487
MT2				  NUMBER    0046	 488
MT_ALL				  XDATA	    0108	7973
MU1				  CODE	    1378	4755
MUL11				  CODE	    1EFC	7719
MULNUM				  CODE	    1EE3	7697
MULNUM10			  CODE	    1EE0	7693
MULX				  CODE	    1F03	7726
MUL_DIV_EXP_AND_SIGN		  CODE	    1C75	7163
MUL_NIBBLE			  CODE	    1C38	7102
MUL_UNDERFLOW			  BIT	      28	 432
N4				  CODE	    0BD0	3164
NCRST				  CODE	    0394	1203
NL1				  CODE	    1E7B	7608
NLC				  CODE	    0784	2282
NLC1				  CODE	    0789	2284
NLC2				  CODE	    078C	2285
NLC3				  CODE	    0790	2287
NMARK_L				  CODE	    1AA3	6693
NMOV				  CODE	    15AA	5360
NMOV1				  CODE	    15B4	5368
NOGO				  CODE	    0578	1752
NOPASS				  CODE	    0F2C	3828
NOROM				  CODE	    1FC9	7922
NO_C				  BIT	      30	 443
NR1				  CODE	    1E84	7617
NTWO				  CODE	    116E	4322
NULL				  NUMBER    0000	 514
NULLCT				  NUMBER    0015	 383
NUMC				  CODE	    0C23	3231
NUMC1				  CODE	    0C2C	3236
NUM_LT				  CODE	    1E74	7602
NUM_RT				  CODE	    1E7D	7611
ONE				  CODE	    0E99	3662
ON_ERR				  BIT	      13	 398
OOPS				  CODE	    0D45	3420
OPBOL				  CODE	    00CF	 643
OPTAB				  CODE	    0057	 567
OTI				  BIT	      14	 399
OTS				  BIT	      10	 395
OTST				  CODE	    1945	6134
OTST1				  CODE	    194B	6139
OUTPUT				  CODE	    1979	6349
OUTR				  CODE	    1E69	7591
OUTR0				  CODE	    1E58	7577
OV				  BIT	      D2
OVE1				  CODE	    1BA5	6950
OVERFLOW			  NUMBER    0001	6298
OVERFLOW_AND_EXIT		  CODE	    1BA1	6943
P				  BIT	      D0
P0				  DATA	      80
P1				  DATA	      90
P2				  DATA	      A0
P3				  DATA	      B0
PACK				  CODE	    1B1E	6808
PACK0				  CODE	    1B27	6821
PACK1				  CODE	    1B28	6823
PACK11				  CODE	    1B30	6828
PACK2				  CODE	    1B32	6830
PACK3				  CODE	    1B44	6844
PACK31				  CODE	    1B45	6845
PACK4				  CODE	    1B5C	6868
PAREN_INT			  CODE	    0EA2	3681
PCL				  CODE	    1446	4995
PCON				  DATA	      87
PCON0				  NUMBER    0087	 496
PG1				  CODE	    04C7	1591
PG10				  CODE	    04C6	1589
PG101				  CODE	    04BF	1584
PG2				  CODE	    04CD	1595
PG31				  CODE	    0501	1636
PG32				  CODE	    04FB	1631
PG4				  CODE	    04CA	1593
PG5				  CODE	    04D5	1600
PG6				  CODE	    04DA	1603
PG7				  CODE	    04E3	1608
PG8				  CODE	    0479	1417
PGR				  CODE	    04BD	1582
PGU				  CODE	    0502	1640
PHEAD				  NUMBER    0016	 384
PIE				  CODE	    180B	5909
PIPI				  CODE	    148C	5072
PLNEXP				  CODE	    143D	4983
PLOOP				  CODE	    1B5E	6872
PLUS_MINUS_TEST			  CODE	    1D72	7401
PMT1				  CODE	    1D86	7415
PMT11				  CODE	    1D77	7405
PMT12				  CODE	    1D7C	7407
PMT13				  CODE	    1D81	7409
PMT2				  CODE	    1D84	7411
PMT3				  CODE	    1D85	7413
PMTOP				  CODE	    165C	5524
PMTOP1				  CODE	    165F	5525
PN0				  CODE	    06CD	2152
PN01				  CODE	    06D6	2156
PN02				  CODE	    06D7	2157
PN1				  CODE	    06C3	2143
POLY1				  CODE	    11B0	4402
POLYC				  CODE	    11A8	4393
POPAS				  CODE	    0FDE	3968
POP_AND_EXIT			  CODE	    19B2	6412
POP_T1				  CODE	    1455	5010
POSNM1				  CODE	    1D31	7338
POSNUM				  CODE	    1D2E	7335
POTWO				  CODE	    119F	4383
PP				  CODE	    15C7	5401
PPL				  CODE	    15DA	5412
PPL1				  CODE	    15DF	5415
PPL2				  CODE	    15E4	5420
PPL21				  CODE	    15E9	5423
PPL22				  CODE	    15EE	5425
PPL3				  CODE	    15FD	5437
PPL4				  CODE	    1602	5443
PPL41				  CODE	    160B	5452
PPL6				  CODE	    162F	5476
PPL61				  CODE	    1638	5481
PPL7				  CODE	    163C	5484
PPL71				  CODE	    163D	5485
PPL9				  CODE	    1650	5497
PPL91				  CODE	    1651	5498
PPLX				  CODE	    1616	5461
PPLY				  CODE	    1623	5467
PPLY1				  CODE	    1628	5472
PPX				  CODE	    15F2	5428
PRET				  CODE	    1B7E	6905
PRNTCR				  CODE	    06CB	2150
PROGS				  XDATA	    0128	7986
PS				  BIT	      BC
PSTART				  NUMBER    0200	 543
PSW				  DATA	      D0
PT0				  BIT	      B9
PT1				  BIT	      BB
PTIME				  CODE	    0713	2210
PUSHAS				  CODE	    0FE8	3978
PUSHC				  CODE	    1440	4991
PUSHCS				  CODE	    0BBB	3149
PUSHCS1				  CODE	    0BC0	3151
PUSHCS2				  CODE	    0BC6	3156
PUSHR2R0			  CODE	    1CC3	7256
PUSH_ONE			  CODE	    1450	5005
PUSH_T1				  CODE	    145C	5016
PUSH_T11			  CODE	    145E	5019
PUSH_T12			  CODE	    1460	5021
PX0				  BIT	      B8
PX1				  BIT	      BA
P_E				  CODE	    0CEA	3365
P_T2				  CODE	    1463	5024
P_Z				  CODE	    1382	4771
R0B0				  NUMBER    0000	 348
R1B0				  NUMBER    0001	 349
R2B0				  NUMBER    0002	 350
R3B0				  NUMBER    0003	 351
R3CK				  CODE	    09DF	2733
R4B0				  NUMBER    0004	 352
R5B0				  NUMBER    0005	 353
R6B0				  NUMBER    0006	 354
R76S				  CODE	    0DFA	3539
R7B0				  NUMBER    0007	 355
RB8				  BIT	      9A
RC1				  CODE	    0679	2066
RC2				  CODE	    067D	2069
RCAPH2				  NUMBER    00CB	 499
RCAPL2				  NUMBER    00CA	 500
RCASB				  CODE	    1EDC	7689
RCELL				  XDATA	    010C	7975
RCL				  CODE	    088F	2502
RCL1				  CODE	    0894	2510
RCL2				  CODE	    089C	2517
RCL3				  CODE	    08A2	2521
RCL4				  CODE	    08A8	2525
RCL5				  CODE	    08AE	2529
RCL6				  CODE	    08B4	2533
RCLEAR				  CODE	    066E	2060
RD				  BIT	      B7
RDYS				  CODE	    00FD	 687
RECIP				  CODE	    1289	4591
REN				  BIT	      9C
RESET				  CODE	    0000
RETBIT				  BIT	      25	 422
RET_X				  CODE	    1D53	7364
RF1				  CODE	    0568	1739
RF2				  CODE	    056F	1745
RF3				  CODE	    0575	1750
RFX				  CODE	    056E	1743
RI				  BIT	      98
RIGHT				  CODE	    1BC8	7000
RIGHT1				  CODE	    1BCA	7007
RIGHT2				  CODE	    1BCB	7008
RIGHT3				  CODE	    1BD2	7015
RIGHT5				  CODE	    1BF1	7041
RIGHTL				  CODE	    1BDE	7025
RIGHTL1				  CODE	    1BF0	7039
RL1				  CODE	    0AFE	2979
RLINE				  CODE	    0AFC	2977
RMOV				  CODE	    158E	5323
RO1				  CODE	    054D	1724
RO11				  CODE	    0558	1730
ROMADR				  NUMBER    5000	 534
ROMFD				  CODE	    0565	1737
ROM_P				  CODE	    06B9	2136
ROM_P1				  CODE	    06C1	2141
ROUT				  CODE	    1E9F	7641
RROM				  CODE	    07CA	2340
RS0				  BIT	      D3
RS1				  BIT	      D4
RSUB1				  CODE	    1F06	7798
RSUB2				  CODE	    1F30	7827
RSUB3				  CODE	    1F3A	7834
RTST				  CODE	    0AD1	2929
RTST1				  CODE	    0ADA	2937
RTXAH				  NUMBER    0012	 377
RTXAL				  NUMBER    0010	 375
RV				  CODE	    11C2	4415
RXD				  BIT	      B0
S0RELH				  NUMBER    00BA	 498
S0RELL				  NUMBER    00AA	 497
S13				  CODE	    0D48	3422
S20DP				  CODE	    1431	4965
S31DP				  CODE	    060F	1950
S31DP2				  CODE	    060D	1948
S31L				  CODE	    171B	5725
SA				  CODE	    0D26	3407
SA1				  CODE	    0D2D	3410
SA2				  CODE	    0D31	3412
SAVE_T				  NUMBER    004A	 492
SBAUD				  CODE	    1706	5715
SBUF				  DATA	      99
SCALL				  CODE	    0E6E	3620
SCLOCK				  CODE	    1925	6092
SCLR				  CODE	    0699	2097
SCON				  DATA	      98
SC_R				  CODE	    193A	6112
SD0				  CODE	    0D67	3448
SD01				  CODE	    0D64	3446
SDI				  CODE	    0DC7	3512
SDIMX				  CODE	    0D6C	3451
SE0				  CODE	    0CC9	3331
SE1				  CODE	    19AC	6406
SERCALC				  CODE	    1F69	7882
SERR1				  CODE	    18C0	6023
SETREG				  CODE	    1260	4559
SETREG1				  CODE	    1261	4560
SF2				  CODE	    0A5D	2836
SF21				  CODE	    0A60	2838
SF3				  CODE	    0A7C	2853
SFOR				  CODE	    0A46	2824
SGOSUB				  CODE	    0B37	3053
SGOTO				  CODE	    0AB4	2909
SGS0				  CODE	    0B39	3055
SGS1				  CODE	    0B3F	3059
SGT1				  CODE	    0AB6	2911
SGT11				  CODE	    0AC1	2917
SGT2				  CODE	    0AC3	2919
SGT21				  CODE	    0ACB	2922
SIF				  CODE	    0A90	2881
SIF1				  CODE	    0A9A	2886
SIGNS_DIFFERENT			  CODE	    1A60	6602
SIN0				  CODE	    1209	4472
SINOUT				  CODE	    1E98	7635
SINPUT				  CODE	    0E00	3552
SINT				  CODE	    0023
SINTAB				  CODE	    16DB	5661
SLET				  CODE	    0978	2668
SLET0				  CODE	    09CC	2720
SLET1				  CODE	    09D0	2723
SLET2				  CODE	    09D2	2725
SM				  CODE	    0C69	3282
SM0				  BIT	      9F
SM01				  CODE	    0C78	3288
SM02				  CODE	    0C7C	3290
SM1				  BIT	      9E
SM2				  BIT	      9D
SNEXT				  CODE	    0B69	3094
SONERR				  CODE	    141C	4944
SONEXT				  CODE	    1426	4956
SOT				  CODE	    0E61	3606
SOUT				  CODE	    1EA7	7647
SOUT1				  CODE	    1EA9	7649
SOUT_1				  CODE	    1F53	7860
SP				  DATA	      81
SP0				  CODE	    0C46	3260
SP1				  CODE	    0C4D	3265
SP2				  CODE	    0C49	3262
SP4				  CODE	    0C51	3268
SP6				  CODE	    0C5C	3274
SP7				  CODE	    0C61	3277
SP8				  CODE	    0C80	3293
SP9				  CODE	    0CE2	3352
SP9A				  CODE	    0CE9	3357
SPACE7				  CODE	    1E85	7619
SPEOP				  CODE	    09E3	2736
SPEOP1				  CODE	    09E7	2738
SPH0				  CODE	    0C33	3246
SPH1				  CODE	    0C35	3248
SPINT				  BIT	      1F	 416
SPOP				  CODE	    0A87	2868
SPOP1				  CODE	    0A8F	2873
SPRINT				  CODE	    0C37	3250
SPRINT1				  CODE	    0C3B	3252
SPRINT2				  CODE	    0C42	3257
SPSAV				  NUMBER    003E	 481
SPUSH				  CODE	    0A80	2862
SPV				  XDATA	    0124	7984
SP_H				  NUMBER    004B	 493
SP_L				  NUMBER    004C	 494
SQ				  CODE	    0C87	3297
SQR1				  CODE	    12B0	4621
SQR2				  CODE	    12B7	4628
SQR4				  CODE	    12BA	4633
SQR41				  CODE	    12CB	4642
SQ_ERR				  CODE	    1297	4600
SR0				  CODE	    0B1E	3030
SR01				  CODE	    0B2E	3040
SRD				  CODE	    0BF3	3202
SRD0				  CODE	    0BEF	3199
SRD1				  CODE	    0BFC	3207
SRD2				  CODE	    0BFE	3209
SRD21				  CODE	    0C08	3214
SRD4				  CODE	    0C09	3216
SRD5				  CODE	    0C10	3220
SRD51				  CODE	    0C13	3221
SRD6				  CODE	    0C1B	3226
SREAD				  CODE	    0BED	3197
SRESTR				  CODE	    0BD8	3174
SRESTR1				  CODE	    0BDA	3175
SRETI				  CODE	    0B18	3019
SRETRN				  CODE	    0B1A	3027
SRT				  CODE	    1226	4503
SS				  CODE	    0D1D	3402
SS7				  CODE	    1E96	7633
SSOOP				  CODE	    09A7	2696
SSTOP				  CODE	    0862	2467
SSTOP0				  CODE	    086A	2471
STACKTP				  NUMBER    00FE	 504
STATD				  CODE	    0123	 722
STDIG				  CODE	    1D45	7355
STDIG1				  CODE	    1D54	7366
STEROT				  CODE	    0719	2226
STESIZ				  NUMBER    0009	 541
STJ				  CODE	    0020	 291
STK				  CODE	    0041	 334
STONE				  CODE	    1693	5587
STONE1				  CODE	    1698	5594
STOPBIT				  BIT	      20	 417
STORE2				  CODE	    1B76	6897
STORE_ALIGN_TEST_AND_EXIT	  CODE	    1B70	6887
STP				  CODE	    00EE	 683
STQ				  CODE	    0033	 326
STRING				  CODE	    0616	1961
STRIP				  CODE	    11E7	4448
STR_AL				  XDATA	    0122	7983
STS				  CODE	    003E	 332
STU				  CODE	    0044	 337
ST_A				  CODE	    0FF0	3989
ST_ALL				  XDATA	    0106	7972
SUBLP				  CODE	    1A08	6517
SUI				  CODE	    193B	6116
SUNTIL				  CODE	    0B0B	2996
SUO				  CODE	    1940	6126
SWAP_AND_EXIT			  CODE	    19A8	6399
SWAP_ASTKA			  CODE	    1467	5029
SWHILE				  CODE	    0B06	2992
SX				  CODE	    0C8C	3300
SX1				  CODE	    0CA2	3309
S_0				  CODE	    098C	2679
S_1				  CODE	    09BC	2710
S_11				  CODE	    09C4	2714
S_3				  CODE	    099B	2689
S_4				  CODE	    09A9	2698
S_41				  CODE	    09B0	2701
S_5				  CODE	    09B7	2707
S_C				  CODE	    0ECA	3709
S_C_1				  CODE	    0E7D	3632
S_DO				  CODE	    0F10	3805
S_E				  CODE	    0996	2685
S_L				  CODE	    146E	5039
S_LEN				  NUMBER    003F	 482
S_N				  CODE	    1FD3	7930
S_ON				  CODE	    0CF6	3376
S_WU				  CODE	    0B0D	2998
T0				  BIT	      B4
T1				  BIT	      B5
T2CON				  NUMBER    00C8	 188
TB				  CODE	    15C2	5388
TB8				  BIT	      9B
TBR				  CODE	    15A6	5348
TBYTE				  CODE	    15A3	5345
TCON				  DATA	      88
TEMP1				  NUMBER    000B	 366
TEMP2				  NUMBER    000C	 367
TEMP3				  NUMBER    000D	 368
TEMP4				  NUMBER    000E	 369
TEMP5				  NUMBER    000F	 370
TEMPD				  CODE	    1861	5951
TEMP_COMP			  CODE	    1329	4706
TEROT				  CODE	    071B	2228
TEROT01				  CODE	    0721	2231
TEROT02				  CODE	    0728	2234
TEROT03				  CODE	    0731	2238
TEROT04				  CODE	    0739	2241
TEROT1				  CODE	    0770	2270
TEROT11				  CODE	    0776	2273
TEROT2				  CODE	    077D	2277
TEST_USER			  CODE	    17ED	5864
TF0				  BIT	      8D
TF1				  BIT	      8F
TH0				  DATA	      8C
TH1				  DATA	      8D
TH2				  NUMBER    00CD	 190
THREE				  CODE	    0E83	3638
TI				  BIT	      99
TIMER0				  CODE	    000B
TIMER1				  CODE	    001B
TIMER_LOAD			  CODE	    0537	1694
TIMER_LOAD1			  CODE	    0539	1699
TIV				  XDATA	    0126	7985
TL0				  DATA	      8A
TL1				  DATA	      8B
TL2				  NUMBER    00CC	 189
TMOD				  DATA	      89
TMR0				  NUMBER    00C8	1072
TMR1				  NUMBER    00C9	1076
TMR2				  NUMBER    00CA	1080
TM_TOP				  XDATA	    012C	7996
TOKTAB				  CODE	    0175	 770
TR				  CODE	    1920	6082
TR0				  BIT	      8C
TR1				  BIT	      8E
TRC2				  NUMBER    00CE	1100
TT2C				  NUMBER    00CB	1088
TTC				  NUMBER    00CC	1092
TTIME				  CODE	    1174	4340
TTM				  NUMBER    00CD	1096
TVH				  NUMBER    0048	 490
TVL				  NUMBER    0049	 491
TWO				  CODE	    0E90	3651
TWOL				  CODE	    14AE	5107
TWO_EX				  CODE	    14C0	5126
TWO_EY				  CODE	    14C1	5129
TWO_R2				  CODE	    14BE	5123
TXAH				  NUMBER    000A	 362
TXAL				  NUMBER    0008	 360
TXD				  BIT	      B1
TXX				  CODE	    0769	2266
T_1				  CODE	    0744	2246
T_ADD				  NUMBER    00E3	 953
T_ASC				  NUMBER    00D1	1112
T_BIT				  BIT	      92	 467
T_BUF				  CODE	    1779	5772
T_CHR				  NUMBER    00D3	1122
T_CMND				  NUMBER    00F0	1126
T_CMP				  CODE	    07ED	2383
T_CR				  NUMBER    00AA	 922
T_DATA				  NUMBER    009C	 870
T_DIR				  NUMBER    0090	 834
T_DP				  CODE	    0EC3	3703
T_ELSE				  NUMBER    00A8	 914
T_EQU				  NUMBER    00EA	 975
T_F1				  CODE	    0AA8	2894
T_GOSB				  NUMBER    009F	 880
T_GOTO				  NUMBER    0083	 785
T_HH				  NUMBER    0040	 483
T_IE				  NUMBER    00C6	1064
T_IP				  NUMBER    00C7	1068
T_L				  CODE	    1979	6350
T_LAST				  NUMBER    00A4	 896
T_LL				  NUMBER    0041	 484
T_LPAR				  NUMBER    00E0	 943
T_MTOP				  NUMBER    00C4	1060
T_NEG				  NUMBER    00E9	 973
T_P1				  NUMBER    00CF	1104
T_PC				  NUMBER    00D0	1108
T_REM				  NUMBER    0096	 851
T_SPC				  NUMBER    00A9	 918
T_STEP				  NUMBER    00A7	 910
T_STOP				  NUMBER    0090	 830
T_SUB				  NUMBER    00E5	 960
T_T				  CODE	    08BA	2543
T_T01				  CODE	    08C8	2550
T_T1				  CODE	    08D8	2557
T_T2				  CODE	    08E9	2574
T_TAB				  NUMBER    00A4	 898
T_THEN				  NUMBER    00A5	 902
T_TIME				  NUMBER    00C5	1084
T_TO				  NUMBER    00A6	 906
T_TRAP				  CODE	    08EF	2580
T_ULAST				  NUMBER    00BE	1039
T_UOP				  NUMBER    00B0	 995
T_USE				  NUMBER    00D2	1116
T_XTAL				  NUMBER    00C3	1056
T_X_S				  CODE	    0B43	3062
U3				  CODE	    0CA6	3312
U4				  CODE	    0CAA	3315
U5				  CODE	    0CB4	3320
U5A				  CODE	    0CCB	3333
U6				  CODE	    0CD8	3345
U7				  CODE	    0CDA	3347
U8				  CODE	    0CD4	3342
U8A				  CODE	    0CCF	3337
U8B				  CODE	    0CD1	3339
UBIT				  BIT	      2A	 437
UE				  CODE	    1520	5220
ULOOP				  CODE	    1B8F	6925
UNDERFLOW			  NUMBER    0000	6297
UNDERFLOW_AND_EXIT		  CODE	    1BB2	6962
UNDER_MD			  CODE	    1B5A	6863
UNPACK_R0			  CODE	    1B8B	6918
UOPBOL				  CODE	    00E0	 662
UPB				  BIT	      27	 424
UPP0				  CODE	    10BB	4161
UPP01				  CODE	    10BE	4162
UPP02				  CODE	    10C9	4168
UPP03				  CODE	    10CE	4170
UPP04				  CODE	    10D3	4172
UPP1				  CODE	    10EA	4186
UPP11				  CODE	    10F0	4189
UPP1A				  CODE	    10E6	4183
UPP2				  CODE	    10F9	4193
UPP3				  CODE	    110E	4206
UPP4				  CODE	    111A	4214
UPP41				  CODE	    1122	4218
UPP42				  CODE	    1126	4220
UPP7				  CODE	    112E	4226
UPP7A				  CODE	    112C	4224
UPP8				  CODE	    1130	4228
UPP81				  CODE	    1132	4230
UPP9				  CODE	    10DA	4176
UPP91				  CODE	    10E2	4180
UPPL				  CODE	    10B0	4141
UPPL0				  CODE	    10AD	4132
UPRNT				  CODE	    06C9	2148
UP_2				  CODE	    1104	4200
UP_3				  CODE	    1107	4202
UP_4				  CODE	    110A	4203
USENT				  CODE	    0047	 548
USING0				  CODE	    1DBD	7464
USING1				  CODE	    1DC3	7469
USING2				  CODE	    1DD5	7482
USINGX				  CODE	    1DD3	7480
USINGY				  CODE	    1DD0	7477
U_ID1				  CODE	    186D	5964
U_IDL				  BIT	      21	 418
U_RET				  CODE	    1E57	7575
V4				  CODE	    0DBF	3507
VAR				  CODE	    0D70	3454
VAR1				  CODE	    0D72	3456
VAR11				  CODE	    0D7C	3461
VAR2				  CODE	    0DA5	3488
VARB				  CODE	    0A17	2782
VARCOP				  CODE	    147F	5062
VARD				  CODE	    0A1A	2784
VARTOP				  XDATA	    0104	7971
VAR_ER				  CODE	    0F0C	3795
VX				  CODE	    0D8B	3475
VY				  CODE	    0D7F	3465
V_C				  CODE	    1481	5064
WCR				  CODE	    0F07	3785
WE				  CODE	    0F4C	3861
WR				  BIT	      B6
X3120				  CODE	    0DB8	3499
X31DP				  CODE	    0583	1770
XBILT				  CODE	    0FC3	3946
XBILT1				  CODE	    0FCD	3950
XBIT				  BIT	      2D	 440
XLPAR				  CODE	    0FCF	3952
XOP				  CODE	    0F91	3911
XOP1				  CODE	    0F9B	3916
XOP11				  CODE	    0FAE	3927
XOP12				  CODE	    0FB8	3935
XOP2				  CODE	    0FBA	3939
XOP3				  CODE	    0FD5	3956
XOUT0				  CODE	    1E30	7547
XOUT2				  CODE	    1E35	7551
XOUT3				  CODE	    1E3D	7556
XOUT4				  CODE	    1E41	7560
XPOP				  CODE	    0FDC	3960
XSIGN				  BIT	      50	6316
XTALV				  CODE	    17F9	5876
XXI				  CODE	    0B71	3099
XXI1				  CODE	    0B80	3109
XXI2				  CODE	    0BB5	3136
XXI3				  CODE	    0BB9	3138
X_TR				  CODE	    0BE0	3181
Z7R7				  CODE	    1E8D	7625
ZERO				  NUMBER    0002	6299
ZERO7				  CODE	    1E8E	7627
ZERO_AND_EXIT			  CODE	    1BB8	6973
ZERO_DIVIDE			  NUMBER    0003	6300
ZOUT				  CODE	    1EA3	7644
ZRO				  CODE	    04EA	1616
ZSURP				  BIT	      36	 456
ZT0				  CODE	    1E6C	7595
ZT1				  CODE	    1E73	7600
ZTEST				  CODE	    1E6A	7593
