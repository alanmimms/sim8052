#!/usr/bin/env node
'use strict';

const _ = require('lodash');
const fs = require('fs');
const vm = require('vm');
const util = require('util');
const PEG = require('pegjs');

const CPU = require('./cpu.js');
const SimUtils = require('./simutils.js');

const GRAMMAR_PATH = './8052.pegjs'
const INSN_PATH = './8052.insn';
const CODE_PATH = './8052-insn.js';


const {toHex2, toHex4} = SimUtils;


const parser = buildParser();
const ast = generateAST(parser);
const code = generateCodeFromAST(ast);

fs.writeFileSync(CODE_PATH, code, {mode: 0o664});


// Build the parser from its PEGJS source file and return the
// resulting parser object.
function buildParser(grammarPath = GRAMMAR_PATH) {
  let grammar, parser;

  try {
    grammar = fs.readFileSync(require.resolve(grammarPath), 'utf8')
  } catch(e) {
    console.error(`FATAL error reading required '${grammarPath}' grammar:\n`, e);
    process.exit(-1);
  }

  const buildParserOptions = {
    output: 'parser',
    allowedStartRules: ['Start'],
    trace: false,
  };

  try {
    parser = PEG.generate(grammar, buildParserOptions);
  } catch(e) {
    console.error(`INTERNAL ERROR Grammar '${grammarPath}' parse failed:\n`, e);
    process.exit(-1);
  }

  return parser;
}


// Initialize the parser for our INSN language.
function generateAST(parser) {
  let insnSrc;
  let ast;

  try {
    insnSrc = fs.readFileSync(INSN_PATH, {encoding: 'utf-8'});
  } catch(e) {
    console.error(`Unable to open ${INSN_PATH}: ${e.code}`);
    process.exit(-1);
  }

  const tracer = require('./tracer');
  tracer.setSrc(insnSrc);

  try {
    ast = parser.parse(insnSrc, {tracer});
  } catch(e) {
    const found = e.found ? `found "${e.found}"` : '';
    const at = e.location ?
          ` at ${util.inspect(e.location.start)}-${util.inspect(e.location.end)}` :
          '';
    console.error(`\
Parsing or runtime error:
${util.inspect(e, {depth: 99})}
  ${found}${at}`);
    process.exit(-1);
  }

  return _.flatten(ast);
}


// Generate the code for the specified opcode `op` for Instruction `h`
// and place that code into `h.handlerSource`.
//
//TODO:
// * Find references to Ri or @Ri and declare `rBase` at top of the
//   handler to avoid the `iram[(SFR[PSW] & 0x18) + i]` mess.
// * Optimize transfers like `X = X + k` to be like `X += k`.
function codegenOpcode(h, op) {

  if (op !== 0 && h.transfers.length === 0) {
    console.error(`Unimplemented opcode ${op}`);
    return 'UNIMPLEMENTED OPCODE ${op}';
  }

  h.pcIsAssigned = h.transfers.find(xfr => isVar(xfr.target, 'PC'));

  // Insert auto-increment of PC if it is not explicitly
  // assigned.
  if (!h.pcIsAssigned) {
    h.transfers.push({
      type: 'Transfer',
      target: {type: 'Var', id: 'PC'},
      e: {type: 'PLUS', l: {type: 'Var', id: 'PC'}, r: h.n},
    });
  }

  return h.transfers.map(xfr => genTransfer(xfr));


  ////////////////////////////////////////////////////////////////
  // Return true if specified item is the named variable.
  function isVar(item, id) {
    return (item && item.type === 'Var' && item.id === id);
  }


  // Returns {w: 'width to mask to, or zero to avoid masking',
  //          code: 'code to access symbol'}.
  function symbolToCode(e, params) {
    const rsMaskCode = toHex2(CPU.pswBits.rs1Mask | CPU.pswBits.rs0Mask, '0x');

    switch (e.id) {
    case 'A':

      if (e.field) {

        switch (e.field) {
        case 'NYBLO':
          return {w: 4, code: `this.sfrNYBLO[this.ACC]`};

        case 'NYBHI':
          return {w: 4, code: `this.sfrNYBHI[this.ACC]`};

        default:
          return {w: 0, code: `UNHANDLED A.field flavor ${e.field}`};
        }
      } else {
        return {w: 8, code: 'this.SFR[this.ACC]'};
      }

    case 'ALU1':        return {w: 8, code: 'this.alu1'};
    case 'ALUC':        return {w: 1, code: 'this.aluC'};
    case 'B':           return {w: 8, code: 'this.SFR[this.B]'};
    case 'SP':          return {w: 8, code: 'this.SFR[this.SP]'};

    case 'TMP':
      if (e.field) {

        switch (e.field) {
        case 'NYBLO':
          return {w: 4, code: `this.tmpNYBLO`};

        case 'NYBHI':
          return {w: 4, code: `this.tmpNYBHI`};

        default:
          return {w: 0, code: `UNHANDLED TMP.field flavor ${e.field}`};
        }
      } else {
        return {w: 0, code: 'this.tmp'};
      }

    case 'PC':
      return {
        w: widthOfField(e.field) || 16, 
        code: `this.pc` + (e.field || ''),
      };

    case 'DPTR':
      return {
        w: widthOfField(e.field) || 16, 
        code: `this.DPTR` + (e.field || ''),
      };

    case 'IMM':
      return {w: 16, code: params.IMM};

    case 'PAGE':
      return {w: 11, code: params.PAGE};

    case 'HILO':
      return {w: 16, code: `${params.HI} << 8 | ${params.LO}`};

    case 'CY':
    case 'OV':
    case 'AC':
      return {w: 1, code: 'this.' + e.id};

    case 'BIT':
      return {w: 1, code: `this.BIT[${params[e.id]}]`};

    case 'DIR':
    case 'DIRSRC':
    case 'DIRDST':
      return {w: 8, code: `this.DIR[${params[e.id]}]`};

    case 'A_PLUS_DPTR':
      return {w: 8, code: `(this.SFR[this.ACC] + this.DPTR) & 0xFFFF`};

    case 'A_PLUS_PC':
      return {w: 8, code: `(this.SFR[this.ACC] + this.pc) & 0xFFFF`};

    case 'RELA':
      return {w: 16, code: `this.toSigned(${params.RELA})`};

    case 'R':
    case 'Ri':
      // We know we can use rsMask bits of PSW without doing a full
      // update of PSW with parity generation, etc., so do that by
      // accessing it directly.
      if (e.field) {

        switch (e.field) {
        case 'NYBLO':
          return {w: 4, code: `\
this.sfrNYBLO[(this.SFR[this.PSW] & ${rsMaskCode}) + \
${params.b1Value & 7}]`};

        case 'NYBHI':
          return {w: 4, code: `\
this.sfrNYBHI[(this.SFR[this.PSW] & ${rsMaskCode}) + \
${params.b1Value & 7}]`};

        default:
          return {w: 0, code: `UNHANDLED R or Ri .field flavor ${e.field}`};
        }
      } else {
        return {
          w: 8,
          code: `\
this.iram[(this.SFR[this.PSW] & ${rsMaskCode}) + \
${params.b1Value & 7}]`,
        };
      }

    default:
      return {w: 0, code: `symbolToCode DEFAULT! (${e.id})`};
    };
  }


  function widthOfField(field) {

    switch (field) {
    case 'PAGE': return 11;

    case 'HI':
    case 'LO':
      return 8;

    case 'NYBLO':
    case 'NYBHI':
      return 4;

    default: return 0;
    }
  }


  // For the current Instruction, create the parameters object
  // containining the values from the instruction's encoding to be
  // used during the codegen and execution of the instruction. For
  // example, for an instruction with an IMM immediate value in its
  // encoding, the `IMM` property will be filled in with the code to
  // fetch that value from the code stream.
  function instructionParams() {
    const b1Value = extractInstructionField();
    const params = {b1Value};

    ['-b1-placeholder-', 'b2', 'b3'].forEach((byte, offset) => {
      let code;

      if (!h[byte] || h[byte].type !== 'SYMBOL') return;

      switch (h[byte].sym) {
      case 'IMM':
      case 'DIR':
      case 'DIRSRC':
      case 'DIRDST':
      case 'HI':
      case 'LO':
      case 'RELA':
      case 'BIT':
        params[h[byte].sym] = `this.code[pc0 + ${offset}]`;
        break;

      case 'PAGE':
        params.PAGE = `${b1Value} << 8 | this.code[pc0 + ${offset}]`;
        break;

      default:
        console.log(`Unhandled Instruction byte symbol ${h[byte].sym}`);
        code = `UNHANDLED ${h[byte].sym}`;
        break;
      }
    });

    return params;
  }


  // Given the current Instruction uses a `b1` encoding like
  // `10111RRR`, extract the value from `op` containing the bits
  // `RRR` and return them or return `null` if there are no embedded
  // letters in the encoding.
  function extractInstructionField() {
    const b1Match = h.b1.bits.match(/([A-Z]+)/);
    if (!b1Match) return null;
    const nBits = b1Match[1].length;
    const topBitNumber = 7 - b1Match.index;
    const mask = ((1 << nBits) - 1) << (topBitNumber - nBits + 1);
    return (op & mask) >> (topBitNumber - nBits + 1);
  }


  function genTransfer(xfr) {
    const t = xfr.target && xfr.target || xfr;

    switch (t.type) {
    case 'Var':
    case 'Slash':
      const {w, code} = genTarget(t);
      const hexForWidth = w <= 8 ? toHex2 : toHex4;
      const targetWidthMask = w === 0 ? '' : ' & 0x' + hexForWidth((1 << w) - 1);
      return `${code} = (${genExpr(xfr.e)})${targetWidthMask}`;

    case 'If':
      const thenTransfers = t.thenPart.map(x => genTransfer(x)).join(';\n      ');
      const elseTransfers = (t.elsePart || []).map(x => genTransfer(x)).join(';\n      ');

      let s = `\
if (${genExpr(xfr.e)}) {
        ${thenTransfers};
      }`;

      if (t.elsePart) s += `\
else {
        ${elseTransfers};
      }`;

      return s;

    case 'Code':
      return t.code.trim();

    default:
      return `\
UNKNOWN target type ${t.type}`;
    }
  }


  function genTarget(t) {

    switch (t.type) {
    case 'Var':
      return symbolToCode(t, instructionParams());

    case 'Slash':
      return {w: 8, code: `this.${t.space.toLowerCase()}[${genExpr(t.addr)}]`};

    default:
      return {w: 0, code: `UNKNOWN target type ${t.type}`};
    }
  }


  function genExpr(e) {
    if (typeof e === 'number') return e.toString(10);

    if (!e) return `OOPS genExpr(null)`;
    if (!e.type) return `OOPS empty type`;

    switch (e.type) {
    case 'Code':
      return e.code.trim();

    case 'Slash':
    case 'Var':
      return genTarget(e).code;

    case 'PLUS':
      return genBinary(e, '+');

    case 'MINUS':
      return genBinary(e, '-');

    case 'EQ':
      return genBinary(e, '===');

    case 'NE':
      return genBinary(e, '!==');

    case 'LT':
      return genBinary(e, '<');

    case 'GT':
      return genBinary(e, '>');

    case 'ANDAND':
      return genBinary(e, '&&');

    case 'OROR':
      return genBinary(e, '||');

    case 'AND':
      return genBinary(e, '&');

    case 'OR':
      return genBinary(e, '|');

    case 'XOR':
      return genBinary(e, '^');

    case 'Not':
      return `!${genExpr(e.e)}`;

    default:
      return `UNKNOWN genExpr(${e.type}, ${op.mnemonic})`;
    }
  }


  function genBinary(e, operator) {
    return `(${genExpr(e.l)}) ${operator} (${genExpr(e.r)})`;
  }
}


// Generate instruction handlers from the `ast` and return the array
// of function pointers to be indexed by opcode. The handlers are
// designed to run in the CPU execution context (i.e., the `cpu`
// object).
function generateCodeFromAST(ast) {
  const handlers = [];

  ast.forEach(insn => {

    if (insn.type !== 'Instruction') {
      console.error('Bad AST array entry=', util.inspect(insn, {depth:999}));
      return;
    }

    // Define number of byte in Instruction by counting bytes
    // defined nonempty in the entry.
    insn.n = 1 + +!!insn.b2 + +!!insn.b3;

    // Build regular expression from the Bits entry (e.g., 11001001
    // or 1100110I or 11001RRR) by replacing each letter with "." to
    // act as a dont-care bit. We then match this number against a
    // binary representation of the opcode including all
    // leading-zeroes in the `filter()` below. The set of matching
    // elements is the set of opcodes we need this entry to apply to
    // in handlers[].
    const toMatch = new RegExp('^' +
                               insn.b1.bits
                               .replace(/[A-Z]/g, '.')
                               + '$');
    _.range(0, 0x100)
      .filter(op => !!(op | 0x1000).toString(2).slice(-8).match(toMatch))
      .forEach(op => {
        if (handlers[op]) 
          console.error(`\
In ${insn.mnemonic} handler, \
already defined for ${toHex2(op)} as ${handlers[op].mnemonic}`);
        handlers[op] = insn;
      });
  });

  // Make sure we define all 256 handlers
  handlers
    .forEach((h, op) =>
             h || console.error(`Handler not defined for ${toHex2(op)}`));

  // Generate the code for the simulator function for each opcode.
  const code = handlers.map((h, op) => {
    h.handlerSource = codegenOpcode(h, op).join(';\n      ') + ';';

    // Precompile the handler to simulate this opcode
    h.script = new vm.Script(h.handlerSource, {
      filename: 'generated code for simulator',
      displayErrors: true,
    });

    return `\

  // ${toHex2(op)}: ${h.mnemonic} ${h.operands}
  { n: ${h.n}, mnemonic: "${h.mnemonic}", operands: "${h.operands}",
    opFunction() {
      const pc0 = this.pc;
      ${h.handlerSource}
    },
  },
`;
  }).join('\n');

  return `\
'use strict';
module.exports.opcodes = [
${code}
];
`;
}
